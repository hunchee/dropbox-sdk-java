/* DO NOT EDIT */
/* This file was generated from team.babel */

package com.dropbox.core.v2;

import java.io.IOException;
import java.util.regex.Pattern;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.dropbox.core.DbxApiException;
import com.dropbox.core.v2.DbxRawClientV2;
import com.dropbox.core.DbxException;
import com.dropbox.core.DbxRequestUtil;
import com.dropbox.core.LocalizedText;
import com.dropbox.core.http.HttpRequestor;
import com.dropbox.core.json.JsonArrayReader;
import com.dropbox.core.json.JsonDateReader;
import com.dropbox.core.json.JsonReader;
import com.dropbox.core.json.JsonReadException;
import com.dropbox.core.json.JsonWriter;

/**
 * Classes and routes in namespace "team".
 */
public final class DbxTeam {
    // namespace team

    private final DbxRawClientV2 client;

    DbxTeam(DbxRawClientV2 client) {
        this.client = client;
    }


    /**
     * The user's status as a member of a specific team.
     */
    public static final class TeamMemberStatus {
        // union TeamMemberStatus

        /**
         * The discriminating tag type for {@link TeamMemberStatus}.
         */
        public enum Tag {
            /**
             * User has successfully joined the team.
             */
            ACTIVE,
            /**
             * User has been invited to a team, but has not joined the team yet.
             */
            INVITED,
            /**
             * User is no longer a member of the team, but the account can be
             * un-suspended, re-establishing the user as a team member.
             */
            SUSPENDED
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code TeamMemberStatus}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * User has successfully joined the team.
         */
        private static final TeamMemberStatus ACTIVE_INSTANCE = new TeamMemberStatus(Tag.ACTIVE);

        /**
         * Returns an instance of {@code TeamMemberStatus} that has its tag set
         * to {@link Tag#ACTIVE}.
         *
         * <p> User has successfully joined the team. </p>
         *
         * @return Instance of {@code TeamMemberStatus} with its tag set to
         *     {@link Tag#ACTIVE}.
         */
        public static TeamMemberStatus active() {
            return TeamMemberStatus.ACTIVE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#ACTIVE},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#ACTIVE}, {@code false} otherwise.
         */
        public boolean isActive() {
            return this.tag == Tag.ACTIVE;
        }

        /**
         * User has been invited to a team, but has not joined the team yet.
         */
        private static final TeamMemberStatus INVITED_INSTANCE = new TeamMemberStatus(Tag.INVITED);

        /**
         * Returns an instance of {@code TeamMemberStatus} that has its tag set
         * to {@link Tag#INVITED}.
         *
         * <p> User has been invited to a team, but has not joined the team yet.
         * </p>
         *
         * @return Instance of {@code TeamMemberStatus} with its tag set to
         *     {@link Tag#INVITED}.
         */
        public static TeamMemberStatus invited() {
            return TeamMemberStatus.INVITED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#INVITED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#INVITED}, {@code false} otherwise.
         */
        public boolean isInvited() {
            return this.tag == Tag.INVITED;
        }

        /**
         * User is no longer a member of the team, but the account can be
         * un-suspended, re-establishing the user as a team member.
         */
        private static final TeamMemberStatus SUSPENDED_INSTANCE = new TeamMemberStatus(Tag.SUSPENDED);

        /**
         * Returns an instance of {@code TeamMemberStatus} that has its tag set
         * to {@link Tag#SUSPENDED}.
         *
         * <p> User is no longer a member of the team, but the account can be
         * un-suspended, re-establishing the user as a team member. </p>
         *
         * @return Instance of {@code TeamMemberStatus} with its tag set to
         *     {@link Tag#SUSPENDED}.
         */
        public static TeamMemberStatus suspended() {
            return TeamMemberStatus.SUSPENDED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#SUSPENDED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#SUSPENDED}, {@code false} otherwise.
         */
        public boolean isSuspended() {
            return this.tag == Tag.SUSPENDED;
        }

        private TeamMemberStatus(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case ACTIVE:
                case INVITED:
                case SUSPENDED:
                    break;
            }
        }

        static final JsonWriter<TeamMemberStatus> _writer = new JsonWriter<TeamMemberStatus>()
        {
            public final void write(TeamMemberStatus x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case ACTIVE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("active");
                        g.writeEndObject();
                        break;
                    case INVITED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("invited");
                        g.writeEndObject();
                        break;
                    case SUSPENDED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("suspended");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<TeamMemberStatus> _reader = new JsonReader<TeamMemberStatus>()
        {
            public final TeamMemberStatus read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case ACTIVE: return TeamMemberStatus.active();
                        case INVITED: return TeamMemberStatus.invited();
                        case SUSPENDED: return TeamMemberStatus.suspended();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                TeamMemberStatus value = null;
                if (tag != null) {
                    switch (tag) {
                        case ACTIVE: {
                            value = TeamMemberStatus.active();
                            break;
                        }
                        case INVITED: {
                            value = TeamMemberStatus.invited();
                            break;
                        }
                        case SUSPENDED: {
                            value = TeamMemberStatus.suspended();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("active", Tag.ACTIVE);
            _values.put("invited", Tag.INVITED);
            _values.put("suspended", Tag.SUSPENDED);
        }

        public String toString() {
            return "TeamMemberStatus." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "TeamMemberStatus." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static TeamMemberStatus fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Basic member profile.
     */
    public static class MemberProfile {
        // struct MemberProfile
        /**
         * ID of user as a member of a team.
         */
        public final String teamMemberId;
        /**
         * External ID that a team can attach to the user. An application using
         * the API may find it easier to use their own IDs instead of Dropbox
         * IDs like account_id or team_member_id.
         */
        public final String externalId;
        /**
         * Email address of user.
         */
        public final String email;
        /**
         * Is true if the user's email is verified to be owned by the user.
         */
        public final boolean emailVerified;
        /**
         * The user's status as a member of a specific team.
         */
        public final TeamMemberStatus status;
        /**
         * Representations for a person's name.
         */
        public final DbxUsers.Name name;

        /**
         * Basic member profile.
         *
         * @param teamMemberId  ID of user as a member of a team. {@code
         *     teamMemberId} must not be {@code null}.
         * @param email  Email address of user. {@code email} must not be {@code
         *     null}.
         * @param emailVerified  Is true if the user's email is verified to be
         *     owned by the user.
         * @param status  The user's status as a member of a specific team.
         *     {@code status} must not be {@code null}.
         * @param name  Representations for a person's name. {@code name} must
         *     not be {@code null}.
         * @param externalId  External ID that a team can attach to the user. An
         *     application using the API may find it easier to use their own IDs
         *     instead of Dropbox IDs like account_id or team_member_id.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MemberProfile(String teamMemberId, String email, boolean emailVerified, TeamMemberStatus status, DbxUsers.Name name, String externalId) {
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
            this.externalId = externalId;
            this.email = email;
            if (email == null) {
                throw new IllegalArgumentException("Required value for 'email' is null");
            }
            this.emailVerified = emailVerified;
            this.status = status;
            if (status == null) {
                throw new IllegalArgumentException("Required value for 'status' is null");
            }
            this.name = name;
            if (name == null) {
                throw new IllegalArgumentException("Required value for 'name' is null");
            }
        }

        static final JsonWriter<MemberProfile> _writer = new JsonWriter<MemberProfile>()
        {
            public final void write(MemberProfile x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MemberProfile._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MemberProfile x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("team_member_id", x.teamMemberId);
                if (x.externalId != null) {
                    g.writeFieldName("external_id");
                    g.writeString(x.externalId);
                }
                g.writeStringField("email", x.email);
                g.writeBooleanField("email_verified", x.emailVerified);
                g.writeFieldName("status");
                TeamMemberStatus._writer.write(x.status, g);
                g.writeFieldName("name");
                DbxUsers.Name._writer.write(x.name, g);
            }
        };

        public static final JsonReader<MemberProfile> _reader = new JsonReader<MemberProfile>() {

            public final MemberProfile read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MemberProfile result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MemberProfile readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String teamMemberId = null;
                String email = null;
                Boolean emailVerified = null;
                TeamMemberStatus status = null;
                DbxUsers.Name name = null;
                String externalId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("email".equals(fieldName)) {
                        email = JsonReader.StringReader
                            .readField(parser, "email", email);
                    }
                    else if ("email_verified".equals(fieldName)) {
                        emailVerified = JsonReader.BooleanReader
                            .readField(parser, "email_verified", emailVerified);
                    }
                    else if ("status".equals(fieldName)) {
                        status = TeamMemberStatus._reader
                            .readField(parser, "status", status);
                    }
                    else if ("name".equals(fieldName)) {
                        name = DbxUsers.Name._reader
                            .readField(parser, "name", name);
                    }
                    else if ("external_id".equals(fieldName)) {
                        externalId = JsonReader.StringReader
                            .readField(parser, "external_id", externalId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                if (email == null) {
                    throw new JsonReadException("Required field \"email\" is missing.", parser.getTokenLocation());
                }
                if (emailVerified == null) {
                    throw new JsonReadException("Required field \"email_verified\" is missing.", parser.getTokenLocation());
                }
                if (status == null) {
                    throw new JsonReadException("Required field \"status\" is missing.", parser.getTokenLocation());
                }
                if (name == null) {
                    throw new JsonReadException("Required field \"name\" is missing.", parser.getTokenLocation());
                }
                return new MemberProfile(teamMemberId, email, emailVerified, status, name, externalId);
            }
        };

        public String toString() {
            return "MemberProfile." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MemberProfile." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MemberProfile fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Argument for selecting a single user, either by team_member_id,
     * external_id or email.
     */
    public static final class UserSelectorArg {
        // union UserSelectorArg

        /**
         * The discriminating tag type for {@link UserSelectorArg}.
         */
        public enum Tag {
            TEAM_MEMBER_ID,  // String
            EXTERNAL_ID,  // String
            EMAIL  // String
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code UserSelectorArg}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final String teamMemberIdValue;

        private UserSelectorArg(Tag tag, String value) {
            this.tag = tag;
            this.teamMemberIdValue = value;
            validate();
        }

        /**
         * None
         *
         * <p> This instance must be tagged as {@link Tag#TEAM_MEMBER_ID}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isTeamMemberId} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isTeamMemberId} is {@code
         *     false}.
         */
        public String getTeamMemberIdValue() {
            if (this.tag != Tag.TEAM_MEMBER_ID) {
                throw new IllegalStateException("getTeamMemberIdValue() requires tag==TEAM_MEMBER_ID, actual tag==" + tag);
            }
            return teamMemberIdValue;
        }

        /**
         * Returns an instance of {@code UserSelectorArg} that has its tag set
         * to {@link Tag#TEAM_MEMBER_ID}.
         *
         * <p> None </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code UserSelectorArg} with its tag set to
         *     {@link Tag#TEAM_MEMBER_ID}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static UserSelectorArg teamMemberId(String value) {
            return new UserSelectorArg(Tag.TEAM_MEMBER_ID, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TEAM_MEMBER_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TEAM_MEMBER_ID}, {@code false} otherwise.
         */
        public boolean isTeamMemberId() {
            return this.tag == Tag.TEAM_MEMBER_ID;
        }

        // Reusing teamMemberIdValue for externalId

        /**
         * None
         *
         * <p> This instance must be tagged as {@link Tag#EXTERNAL_ID}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isExternalId} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isExternalId} is {@code
         *     false}.
         */
        public String getExternalIdValue() {
            if (this.tag != Tag.EXTERNAL_ID) {
                throw new IllegalStateException("getExternalIdValue() requires tag==EXTERNAL_ID, actual tag==" + tag);
            }
            return teamMemberIdValue;
        }

        /**
         * Returns an instance of {@code UserSelectorArg} that has its tag set
         * to {@link Tag#EXTERNAL_ID}.
         *
         * <p> None </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code UserSelectorArg} with its tag set to
         *     {@link Tag#EXTERNAL_ID}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static UserSelectorArg externalId(String value) {
            return new UserSelectorArg(Tag.EXTERNAL_ID, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#EXTERNAL_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EXTERNAL_ID}, {@code false} otherwise.
         */
        public boolean isExternalId() {
            return this.tag == Tag.EXTERNAL_ID;
        }

        // Reusing teamMemberIdValue for email

        /**
         * None
         *
         * <p> This instance must be tagged as {@link Tag#EMAIL}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isEmail} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isEmail} is {@code false}.
         */
        public String getEmailValue() {
            if (this.tag != Tag.EMAIL) {
                throw new IllegalStateException("getEmailValue() requires tag==EMAIL, actual tag==" + tag);
            }
            return teamMemberIdValue;
        }

        /**
         * Returns an instance of {@code UserSelectorArg} that has its tag set
         * to {@link Tag#EMAIL}.
         *
         * <p> None </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code UserSelectorArg} with its tag set to
         *     {@link Tag#EMAIL}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static UserSelectorArg email(String value) {
            return new UserSelectorArg(Tag.EMAIL, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#EMAIL},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#EMAIL},
         *     {@code false} otherwise.
         */
        public boolean isEmail() {
            return this.tag == Tag.EMAIL;
        }


        private final void validate() {
            switch (this.tag) {
                case TEAM_MEMBER_ID:
                    if (this.teamMemberIdValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case EXTERNAL_ID:
                    if (this.teamMemberIdValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case EMAIL:
                    if (this.teamMemberIdValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
            }
        }

        static final JsonWriter<UserSelectorArg> _writer = new JsonWriter<UserSelectorArg>()
        {
            public final void write(UserSelectorArg x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case TEAM_MEMBER_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("team_member_id");
                        g.writeStringField("team_member_id", x.teamMemberIdValue);
                        g.writeEndObject();
                        break;
                    case EXTERNAL_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("external_id");
                        g.writeStringField("external_id", x.teamMemberIdValue);
                        g.writeEndObject();
                        break;
                    case EMAIL:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("email");
                        g.writeStringField("email", x.teamMemberIdValue);
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<UserSelectorArg> _reader = new JsonReader<UserSelectorArg>()
        {
            public final UserSelectorArg read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                UserSelectorArg value = null;
                if (tag != null) {
                    switch (tag) {
                        case TEAM_MEMBER_ID: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "team_member_id", v);
                            value = UserSelectorArg.teamMemberId(v);
                            break;
                        }
                        case EXTERNAL_ID: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "external_id", v);
                            value = UserSelectorArg.externalId(v);
                            break;
                        }
                        case EMAIL: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "email", v);
                            value = UserSelectorArg.email(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("team_member_id", Tag.TEAM_MEMBER_ID);
            _values.put("external_id", Tag.EXTERNAL_ID);
            _values.put("email", Tag.EMAIL);
        }

        public String toString() {
            return "UserSelectorArg." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "UserSelectorArg." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static UserSelectorArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error that can be returned whenever a struct derived from {@link
     * UserSelectorArg} is used.
     */
    public static final class UserSelectorError {
        // union UserSelectorError

        /**
         * The discriminating tag type for {@link UserSelectorError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code UserSelectorError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final UserSelectorError USER_NOT_FOUND_INSTANCE = new UserSelectorError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code UserSelectorError} that has its tag set
         * to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code UserSelectorError} with its tag set to
         *     {@link Tag#USER_NOT_FOUND}.
         */
        public static UserSelectorError userNotFound() {
            return UserSelectorError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        private UserSelectorError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                    break;
            }
        }

        static final JsonWriter<UserSelectorError> _writer = new JsonWriter<UserSelectorError>()
        {
            public final void write(UserSelectorError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<UserSelectorError> _reader = new JsonReader<UserSelectorError>()
        {
            public final UserSelectorError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case USER_NOT_FOUND: return UserSelectorError.userNotFound();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                UserSelectorError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = UserSelectorError.userNotFound();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("user_not_found", Tag.USER_NOT_FOUND);
        }

        public String toString() {
            return "UserSelectorError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "UserSelectorError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static UserSelectorError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Argument for selecting a list of users, either by team_member_ids,
     * external_ids or emails.
     */
    public static final class UsersSelectorArg {
        // union UsersSelectorArg

        /**
         * The discriminating tag type for {@link UsersSelectorArg}.
         */
        public enum Tag {
            /**
             * List of member IDs.
             */
            TEAM_MEMBER_IDS,  // List
            /**
             * List of external user IDs.
             */
            EXTERNAL_IDS,  // List
            /**
             * List of email addresses.
             */
            EMAILS  // List
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code UsersSelectorArg}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final java.util.List<String> teamMemberIdsValue;

        private UsersSelectorArg(Tag tag, java.util.List<String> value) {
            this.tag = tag;
            this.teamMemberIdsValue = value;
            validate();
        }

        /**
         * List of member IDs.
         *
         * <p> This instance must be tagged as {@link Tag#TEAM_MEMBER_IDS}. </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isTeamMemberIds} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isTeamMemberIds} is {@code
         *     false}.
         */
        public java.util.List<String> getTeamMemberIdsValue() {
            if (this.tag != Tag.TEAM_MEMBER_IDS) {
                throw new IllegalStateException("getTeamMemberIdsValue() requires tag==TEAM_MEMBER_IDS, actual tag==" + tag);
            }
            return teamMemberIdsValue;
        }

        /**
         * Returns an instance of {@code UsersSelectorArg} that has its tag set
         * to {@link Tag#TEAM_MEMBER_IDS}.
         *
         * <p> List of member IDs. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code UsersSelectorArg} with its tag set to
         *     {@link Tag#TEAM_MEMBER_IDS}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static UsersSelectorArg teamMemberIds(java.util.List<String> value) {
            return new UsersSelectorArg(Tag.TEAM_MEMBER_IDS, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TEAM_MEMBER_IDS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TEAM_MEMBER_IDS}, {@code false} otherwise.
         */
        public boolean isTeamMemberIds() {
            return this.tag == Tag.TEAM_MEMBER_IDS;
        }

        // Reusing teamMemberIdsValue for externalIds

        /**
         * List of external user IDs.
         *
         * <p> This instance must be tagged as {@link Tag#EXTERNAL_IDS}. </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isExternalIds} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isExternalIds} is {@code
         *     false}.
         */
        public java.util.List<String> getExternalIdsValue() {
            if (this.tag != Tag.EXTERNAL_IDS) {
                throw new IllegalStateException("getExternalIdsValue() requires tag==EXTERNAL_IDS, actual tag==" + tag);
            }
            return teamMemberIdsValue;
        }

        /**
         * Returns an instance of {@code UsersSelectorArg} that has its tag set
         * to {@link Tag#EXTERNAL_IDS}.
         *
         * <p> List of external user IDs. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code UsersSelectorArg} with its tag set to
         *     {@link Tag#EXTERNAL_IDS}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static UsersSelectorArg externalIds(java.util.List<String> value) {
            return new UsersSelectorArg(Tag.EXTERNAL_IDS, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#EXTERNAL_IDS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EXTERNAL_IDS}, {@code false} otherwise.
         */
        public boolean isExternalIds() {
            return this.tag == Tag.EXTERNAL_IDS;
        }

        // Reusing teamMemberIdsValue for emails

        /**
         * List of email addresses.
         *
         * <p> This instance must be tagged as {@link Tag#EMAILS}. </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isEmails} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isEmails} is {@code false}.
         */
        public java.util.List<String> getEmailsValue() {
            if (this.tag != Tag.EMAILS) {
                throw new IllegalStateException("getEmailsValue() requires tag==EMAILS, actual tag==" + tag);
            }
            return teamMemberIdsValue;
        }

        /**
         * Returns an instance of {@code UsersSelectorArg} that has its tag set
         * to {@link Tag#EMAILS}.
         *
         * <p> List of email addresses. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code UsersSelectorArg} with its tag set to
         *     {@link Tag#EMAILS}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static UsersSelectorArg emails(java.util.List<String> value) {
            return new UsersSelectorArg(Tag.EMAILS, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#EMAILS},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EMAILS}, {@code false} otherwise.
         */
        public boolean isEmails() {
            return this.tag == Tag.EMAILS;
        }


        private final void validate() {
            switch (this.tag) {
                case TEAM_MEMBER_IDS:
                    if (this.teamMemberIdsValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (String x : this.teamMemberIdsValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
                case EXTERNAL_IDS:
                    if (this.teamMemberIdsValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (String x : this.teamMemberIdsValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
                case EMAILS:
                    if (this.teamMemberIdsValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (String x : this.teamMemberIdsValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
            }
        }

        static final JsonWriter<UsersSelectorArg> _writer = new JsonWriter<UsersSelectorArg>()
        {
            public final void write(UsersSelectorArg x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case TEAM_MEMBER_IDS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("team_member_ids");
                        g.writeFieldName("team_member_ids");
                        g.writeStartArray();
                        for (String item: x.teamMemberIdsValue) {
                            if (item != null) {
                                g.writeString(item);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                    case EXTERNAL_IDS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("external_ids");
                        g.writeFieldName("external_ids");
                        g.writeStartArray();
                        for (String item: x.teamMemberIdsValue) {
                            if (item != null) {
                                g.writeString(item);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                    case EMAILS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("emails");
                        g.writeFieldName("emails");
                        g.writeStartArray();
                        for (String item: x.teamMemberIdsValue) {
                            if (item != null) {
                                g.writeString(item);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<UsersSelectorArg> _reader = new JsonReader<UsersSelectorArg>()
        {
            public final UsersSelectorArg read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                UsersSelectorArg value = null;
                if (tag != null) {
                    switch (tag) {
                        case TEAM_MEMBER_IDS: {
                            java.util.List<String> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(JsonReader.StringReader)
                                .readField(parser, "team_member_ids", v);
                            value = UsersSelectorArg.teamMemberIds(v);
                            break;
                        }
                        case EXTERNAL_IDS: {
                            java.util.List<String> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(JsonReader.StringReader)
                                .readField(parser, "external_ids", v);
                            value = UsersSelectorArg.externalIds(v);
                            break;
                        }
                        case EMAILS: {
                            java.util.List<String> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(JsonReader.StringReader)
                                .readField(parser, "emails", v);
                            value = UsersSelectorArg.emails(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("team_member_ids", Tag.TEAM_MEMBER_IDS);
            _values.put("external_ids", Tag.EXTERNAL_IDS);
            _values.put("emails", Tag.EMAILS);
        }

        public String toString() {
            return "UsersSelectorArg." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "UsersSelectorArg." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static UsersSelectorArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class EmmState {
        // union EmmState

        /**
         * The discriminating tag type for {@link EmmState}.
         */
        public enum Tag {
            /**
             * Emm token is disabled
             */
            DISABLED,
            /**
             * Emm token is optional
             */
            OPTIONAL,
            /**
             * Emm token is required
             */
            REQUIRED,
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code EmmState}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Emm token is disabled
         */
        private static final EmmState DISABLED_INSTANCE = new EmmState(Tag.DISABLED);

        /**
         * Returns an instance of {@code EmmState} that has its tag set to
         * {@link Tag#DISABLED}.
         *
         * <p> Emm token is disabled </p>
         *
         * @return Instance of {@code EmmState} with its tag set to {@link
         *     Tag#DISABLED}.
         */
        public static EmmState disabled() {
            return EmmState.DISABLED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#DISABLED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#DISABLED}, {@code false} otherwise.
         */
        public boolean isDisabled() {
            return this.tag == Tag.DISABLED;
        }

        /**
         * Emm token is optional
         */
        private static final EmmState OPTIONAL_INSTANCE = new EmmState(Tag.OPTIONAL);

        /**
         * Returns an instance of {@code EmmState} that has its tag set to
         * {@link Tag#OPTIONAL}.
         *
         * <p> Emm token is optional </p>
         *
         * @return Instance of {@code EmmState} with its tag set to {@link
         *     Tag#OPTIONAL}.
         */
        public static EmmState optional() {
            return EmmState.OPTIONAL_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#OPTIONAL}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#OPTIONAL}, {@code false} otherwise.
         */
        public boolean isOptional() {
            return this.tag == Tag.OPTIONAL;
        }

        /**
         * Emm token is required
         */
        private static final EmmState REQUIRED_INSTANCE = new EmmState(Tag.REQUIRED);

        /**
         * Returns an instance of {@code EmmState} that has its tag set to
         * {@link Tag#REQUIRED}.
         *
         * <p> Emm token is required </p>
         *
         * @return Instance of {@code EmmState} with its tag set to {@link
         *     Tag#REQUIRED}.
         */
        public static EmmState required() {
            return EmmState.REQUIRED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#REQUIRED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#REQUIRED}, {@code false} otherwise.
         */
        public boolean isRequired() {
            return this.tag == Tag.REQUIRED;
        }

        private static final EmmState OTHER_INSTANCE = new EmmState(Tag.OTHER);

        /**
         * Returns an instance of {@code EmmState} that has its tag set to
         * {@link Tag#OTHER}.
         *
         * @return Instance of {@code EmmState} with its tag set to {@link
         *     Tag#OTHER}.
         */
        public static EmmState other() {
            return EmmState.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private EmmState(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case DISABLED:
                case OPTIONAL:
                case REQUIRED:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<EmmState> _writer = new JsonWriter<EmmState>()
        {
            public final void write(EmmState x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case DISABLED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("disabled");
                        g.writeEndObject();
                        break;
                    case OPTIONAL:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("optional");
                        g.writeEndObject();
                        break;
                    case REQUIRED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("required");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<EmmState> _reader = new JsonReader<EmmState>()
        {
            public final EmmState read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return EmmState.other(); }
                    switch (tag) {
                        case DISABLED: return EmmState.disabled();
                        case OPTIONAL: return EmmState.optional();
                        case REQUIRED: return EmmState.required();
                        case OTHER: return EmmState.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                EmmState value = null;
                if (tag != null) {
                    switch (tag) {
                        case DISABLED: {
                            value = EmmState.disabled();
                            break;
                        }
                        case OPTIONAL: {
                            value = EmmState.optional();
                            break;
                        }
                        case REQUIRED: {
                            value = EmmState.required();
                            break;
                        }
                        case OTHER: {
                            value = EmmState.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return EmmState.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("disabled", Tag.DISABLED);
            _values.put("optional", Tag.OPTIONAL);
            _values.put("required", Tag.REQUIRED);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "EmmState." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "EmmState." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static EmmState fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class TeamGetInfoResult {
        // struct TeamGetInfoResult
        /**
         * The name of the team.
         */
        public final String name;
        /**
         * The ID of the team.
         */
        public final String teamId;
        /**
         * The number of licenses available to the team.
         */
        public final long numLicensedUsers;
        /**
         * The number of accounts that have been invited or are already active
         * members of the team.
         */
        public final long numProvisionedUsers;
        public final TeamPolicies policies;

        /**
         *
         * @param name  The name of the team. {@code name} must not be {@code
         *     null}.
         * @param teamId  The ID of the team. {@code teamId} must not be {@code
         *     null}.
         * @param numLicensedUsers  The number of licenses available to the
         *     team.
         * @param numProvisionedUsers  The number of accounts that have been
         *     invited or are already active members of the team.
         * @param policies  . {@code policies} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public TeamGetInfoResult(String name, String teamId, long numLicensedUsers, long numProvisionedUsers, TeamPolicies policies) {
            this.name = name;
            if (name == null) {
                throw new IllegalArgumentException("Required value for 'name' is null");
            }
            this.teamId = teamId;
            if (teamId == null) {
                throw new IllegalArgumentException("Required value for 'teamId' is null");
            }
            this.numLicensedUsers = numLicensedUsers;
            this.numProvisionedUsers = numProvisionedUsers;
            this.policies = policies;
            if (policies == null) {
                throw new IllegalArgumentException("Required value for 'policies' is null");
            }
        }

        static final JsonWriter<TeamGetInfoResult> _writer = new JsonWriter<TeamGetInfoResult>()
        {
            public final void write(TeamGetInfoResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                TeamGetInfoResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(TeamGetInfoResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("name", x.name);
                g.writeStringField("team_id", x.teamId);
                g.writeNumberField("num_licensed_users", x.numLicensedUsers);
                g.writeNumberField("num_provisioned_users", x.numProvisionedUsers);
                g.writeFieldName("policies");
                TeamPolicies._writer.write(x.policies, g);
            }
        };

        public static final JsonReader<TeamGetInfoResult> _reader = new JsonReader<TeamGetInfoResult>() {

            public final TeamGetInfoResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                TeamGetInfoResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final TeamGetInfoResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String name = null;
                String teamId = null;
                Long numLicensedUsers = null;
                Long numProvisionedUsers = null;
                TeamPolicies policies = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("name".equals(fieldName)) {
                        name = JsonReader.StringReader
                            .readField(parser, "name", name);
                    }
                    else if ("team_id".equals(fieldName)) {
                        teamId = JsonReader.StringReader
                            .readField(parser, "team_id", teamId);
                    }
                    else if ("num_licensed_users".equals(fieldName)) {
                        numLicensedUsers = JsonReader.UInt32Reader
                            .readField(parser, "num_licensed_users", numLicensedUsers);
                    }
                    else if ("num_provisioned_users".equals(fieldName)) {
                        numProvisionedUsers = JsonReader.UInt32Reader
                            .readField(parser, "num_provisioned_users", numProvisionedUsers);
                    }
                    else if ("policies".equals(fieldName)) {
                        policies = TeamPolicies._reader
                            .readField(parser, "policies", policies);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (name == null) {
                    throw new JsonReadException("Required field \"name\" is missing.", parser.getTokenLocation());
                }
                if (teamId == null) {
                    throw new JsonReadException("Required field \"team_id\" is missing.", parser.getTokenLocation());
                }
                if (numLicensedUsers == null) {
                    throw new JsonReadException("Required field \"num_licensed_users\" is missing.", parser.getTokenLocation());
                }
                if (numProvisionedUsers == null) {
                    throw new JsonReadException("Required field \"num_provisioned_users\" is missing.", parser.getTokenLocation());
                }
                if (policies == null) {
                    throw new JsonReadException("Required field \"policies\" is missing.", parser.getTokenLocation());
                }
                return new TeamGetInfoResult(name, teamId, numLicensedUsers, numProvisionedUsers, policies);
            }
        };

        public String toString() {
            return "TeamGetInfoResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "TeamGetInfoResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static TeamGetInfoResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Policies governing team members.
     */
    public static class TeamPolicies {
        // struct TeamPolicies
        /**
         * Policies governing sharing.
         */
        public final TeamSharingPolicies sharing;
        /**
         * This describes the Enterprise Mobility Management (EMM) state for
         * this team. This information can be used to understand if an
         * organization is integrating with a third-party EMM vendor to further
         * manage and apply restrictions upon the team's Dropbox usage on mobile
         * devices. This is a new feature and in the future we'll be adding more
         * new fields and additional documentation.
         */
        public final EmmState emmState;

        /**
         * Policies governing team members.
         *
         * @param sharing  Policies governing sharing. {@code sharing} must not
         *     be {@code null}.
         * @param emmState  This describes the Enterprise Mobility Management
         *     (EMM) state for this team. This information can be used to
         *     understand if an organization is integrating with a third-party
         *     EMM vendor to further manage and apply restrictions upon the
         *     team's Dropbox usage on mobile devices. This is a new feature and
         *     in the future we'll be adding more new fields and additional
         *     documentation. {@code emmState} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public TeamPolicies(TeamSharingPolicies sharing, EmmState emmState) {
            this.sharing = sharing;
            if (sharing == null) {
                throw new IllegalArgumentException("Required value for 'sharing' is null");
            }
            this.emmState = emmState;
            if (emmState == null) {
                throw new IllegalArgumentException("Required value for 'emmState' is null");
            }
        }

        static final JsonWriter<TeamPolicies> _writer = new JsonWriter<TeamPolicies>()
        {
            public final void write(TeamPolicies x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                TeamPolicies._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(TeamPolicies x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("sharing");
                TeamSharingPolicies._writer.write(x.sharing, g);
                g.writeFieldName("emm_state");
                EmmState._writer.write(x.emmState, g);
            }
        };

        public static final JsonReader<TeamPolicies> _reader = new JsonReader<TeamPolicies>() {

            public final TeamPolicies read(JsonParser parser)
                throws IOException, JsonReadException
            {
                TeamPolicies result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final TeamPolicies readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                TeamSharingPolicies sharing = null;
                EmmState emmState = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("sharing".equals(fieldName)) {
                        sharing = TeamSharingPolicies._reader
                            .readField(parser, "sharing", sharing);
                    }
                    else if ("emm_state".equals(fieldName)) {
                        emmState = EmmState._reader
                            .readField(parser, "emm_state", emmState);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sharing == null) {
                    throw new JsonReadException("Required field \"sharing\" is missing.", parser.getTokenLocation());
                }
                if (emmState == null) {
                    throw new JsonReadException("Required field \"emm_state\" is missing.", parser.getTokenLocation());
                }
                return new TeamPolicies(sharing, emmState);
            }
        };

        public String toString() {
            return "TeamPolicies." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "TeamPolicies." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static TeamPolicies fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Policies governing sharing within and outside of the team.
     */
    public static class TeamSharingPolicies {
        // struct TeamSharingPolicies
        /**
         * Who can join folders shared by team members.
         */
        public final SharedFolderMemberPolicy sharedFolderMemberPolicy;
        /**
         * Which shared folders team members can join.
         */
        public final SharedFolderJoinPolicy sharedFolderJoinPolicy;

        /**
         * Policies governing sharing within and outside of the team.
         *
         * @param sharedFolderMemberPolicy  Who can join folders shared by team
         *     members. {@code sharedFolderMemberPolicy} must not be {@code
         *     null}.
         * @param sharedFolderJoinPolicy  Which shared folders team members can
         *     join. {@code sharedFolderJoinPolicy} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public TeamSharingPolicies(SharedFolderMemberPolicy sharedFolderMemberPolicy, SharedFolderJoinPolicy sharedFolderJoinPolicy) {
            this.sharedFolderMemberPolicy = sharedFolderMemberPolicy;
            if (sharedFolderMemberPolicy == null) {
                throw new IllegalArgumentException("Required value for 'sharedFolderMemberPolicy' is null");
            }
            this.sharedFolderJoinPolicy = sharedFolderJoinPolicy;
            if (sharedFolderJoinPolicy == null) {
                throw new IllegalArgumentException("Required value for 'sharedFolderJoinPolicy' is null");
            }
        }

        static final JsonWriter<TeamSharingPolicies> _writer = new JsonWriter<TeamSharingPolicies>()
        {
            public final void write(TeamSharingPolicies x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                TeamSharingPolicies._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(TeamSharingPolicies x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("shared_folder_member_policy");
                SharedFolderMemberPolicy._writer.write(x.sharedFolderMemberPolicy, g);
                g.writeFieldName("shared_folder_join_policy");
                SharedFolderJoinPolicy._writer.write(x.sharedFolderJoinPolicy, g);
            }
        };

        public static final JsonReader<TeamSharingPolicies> _reader = new JsonReader<TeamSharingPolicies>() {

            public final TeamSharingPolicies read(JsonParser parser)
                throws IOException, JsonReadException
            {
                TeamSharingPolicies result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final TeamSharingPolicies readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                SharedFolderMemberPolicy sharedFolderMemberPolicy = null;
                SharedFolderJoinPolicy sharedFolderJoinPolicy = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("shared_folder_member_policy".equals(fieldName)) {
                        sharedFolderMemberPolicy = SharedFolderMemberPolicy._reader
                            .readField(parser, "shared_folder_member_policy", sharedFolderMemberPolicy);
                    }
                    else if ("shared_folder_join_policy".equals(fieldName)) {
                        sharedFolderJoinPolicy = SharedFolderJoinPolicy._reader
                            .readField(parser, "shared_folder_join_policy", sharedFolderJoinPolicy);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sharedFolderMemberPolicy == null) {
                    throw new JsonReadException("Required field \"shared_folder_member_policy\" is missing.", parser.getTokenLocation());
                }
                if (sharedFolderJoinPolicy == null) {
                    throw new JsonReadException("Required field \"shared_folder_join_policy\" is missing.", parser.getTokenLocation());
                }
                return new TeamSharingPolicies(sharedFolderMemberPolicy, sharedFolderJoinPolicy);
            }
        };

        public String toString() {
            return "TeamSharingPolicies." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "TeamSharingPolicies." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static TeamSharingPolicies fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Policy governing who can be a member of a folder shared by a team member.
     */
    public static final class SharedFolderMemberPolicy {
        // union SharedFolderMemberPolicy

        /**
         * The discriminating tag type for {@link SharedFolderMemberPolicy}.
         */
        public enum Tag {
            /**
             * Only a teammate can be a member of a folder shared by a team
             * member.
             */
            TEAM,
            /**
             * Anyone can be a member of a folder shared by a team member.
             */
            ANYONE,
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code SharedFolderMemberPolicy}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Only a teammate can be a member of a folder shared by a team member.
         */
        private static final SharedFolderMemberPolicy TEAM_INSTANCE = new SharedFolderMemberPolicy(Tag.TEAM);

        /**
         * Returns an instance of {@code SharedFolderMemberPolicy} that has its
         * tag set to {@link Tag#TEAM}.
         *
         * <p> Only a teammate can be a member of a folder shared by a team
         * member. </p>
         *
         * @return Instance of {@code SharedFolderMemberPolicy} with its tag set
         *     to {@link Tag#TEAM}.
         */
        public static SharedFolderMemberPolicy team() {
            return SharedFolderMemberPolicy.TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#TEAM},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#TEAM},
         *     {@code false} otherwise.
         */
        public boolean isTeam() {
            return this.tag == Tag.TEAM;
        }

        /**
         * Anyone can be a member of a folder shared by a team member.
         */
        private static final SharedFolderMemberPolicy ANYONE_INSTANCE = new SharedFolderMemberPolicy(Tag.ANYONE);

        /**
         * Returns an instance of {@code SharedFolderMemberPolicy} that has its
         * tag set to {@link Tag#ANYONE}.
         *
         * <p> Anyone can be a member of a folder shared by a team member. </p>
         *
         * @return Instance of {@code SharedFolderMemberPolicy} with its tag set
         *     to {@link Tag#ANYONE}.
         */
        public static SharedFolderMemberPolicy anyone() {
            return SharedFolderMemberPolicy.ANYONE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#ANYONE},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#ANYONE}, {@code false} otherwise.
         */
        public boolean isAnyone() {
            return this.tag == Tag.ANYONE;
        }

        private static final SharedFolderMemberPolicy OTHER_INSTANCE = new SharedFolderMemberPolicy(Tag.OTHER);

        /**
         * Returns an instance of {@code SharedFolderMemberPolicy} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code SharedFolderMemberPolicy} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static SharedFolderMemberPolicy other() {
            return SharedFolderMemberPolicy.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private SharedFolderMemberPolicy(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case TEAM:
                case ANYONE:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<SharedFolderMemberPolicy> _writer = new JsonWriter<SharedFolderMemberPolicy>()
        {
            public final void write(SharedFolderMemberPolicy x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("team");
                        g.writeEndObject();
                        break;
                    case ANYONE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("anyone");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<SharedFolderMemberPolicy> _reader = new JsonReader<SharedFolderMemberPolicy>()
        {
            public final SharedFolderMemberPolicy read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return SharedFolderMemberPolicy.other(); }
                    switch (tag) {
                        case TEAM: return SharedFolderMemberPolicy.team();
                        case ANYONE: return SharedFolderMemberPolicy.anyone();
                        case OTHER: return SharedFolderMemberPolicy.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                SharedFolderMemberPolicy value = null;
                if (tag != null) {
                    switch (tag) {
                        case TEAM: {
                            value = SharedFolderMemberPolicy.team();
                            break;
                        }
                        case ANYONE: {
                            value = SharedFolderMemberPolicy.anyone();
                            break;
                        }
                        case OTHER: {
                            value = SharedFolderMemberPolicy.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return SharedFolderMemberPolicy.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("team", Tag.TEAM);
            _values.put("anyone", Tag.ANYONE);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "SharedFolderMemberPolicy." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "SharedFolderMemberPolicy." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static SharedFolderMemberPolicy fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Policy governing which shared folders a team member can join.
     */
    public static final class SharedFolderJoinPolicy {
        // union SharedFolderJoinPolicy

        /**
         * The discriminating tag type for {@link SharedFolderJoinPolicy}.
         */
        public enum Tag {
            /**
             * Team members can only join folders shared by teammates.
             */
            FROM_TEAM_ONLY,
            /**
             * Team members can join any shared folder, including those shared
             * by users outside the team.
             */
            FROM_ANYONE,
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code SharedFolderJoinPolicy}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Team members can only join folders shared by teammates.
         */
        private static final SharedFolderJoinPolicy FROM_TEAM_ONLY_INSTANCE = new SharedFolderJoinPolicy(Tag.FROM_TEAM_ONLY);

        /**
         * Returns an instance of {@code SharedFolderJoinPolicy} that has its
         * tag set to {@link Tag#FROM_TEAM_ONLY}.
         *
         * <p> Team members can only join folders shared by teammates. </p>
         *
         * @return Instance of {@code SharedFolderJoinPolicy} with its tag set
         *     to {@link Tag#FROM_TEAM_ONLY}.
         */
        public static SharedFolderJoinPolicy fromTeamOnly() {
            return SharedFolderJoinPolicy.FROM_TEAM_ONLY_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#FROM_TEAM_ONLY}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#FROM_TEAM_ONLY}, {@code false} otherwise.
         */
        public boolean isFromTeamOnly() {
            return this.tag == Tag.FROM_TEAM_ONLY;
        }

        /**
         * Team members can join any shared folder, including those shared by
         * users outside the team.
         */
        private static final SharedFolderJoinPolicy FROM_ANYONE_INSTANCE = new SharedFolderJoinPolicy(Tag.FROM_ANYONE);

        /**
         * Returns an instance of {@code SharedFolderJoinPolicy} that has its
         * tag set to {@link Tag#FROM_ANYONE}.
         *
         * <p> Team members can join any shared folder, including those shared
         * by users outside the team. </p>
         *
         * @return Instance of {@code SharedFolderJoinPolicy} with its tag set
         *     to {@link Tag#FROM_ANYONE}.
         */
        public static SharedFolderJoinPolicy fromAnyone() {
            return SharedFolderJoinPolicy.FROM_ANYONE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#FROM_ANYONE}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#FROM_ANYONE}, {@code false} otherwise.
         */
        public boolean isFromAnyone() {
            return this.tag == Tag.FROM_ANYONE;
        }

        private static final SharedFolderJoinPolicy OTHER_INSTANCE = new SharedFolderJoinPolicy(Tag.OTHER);

        /**
         * Returns an instance of {@code SharedFolderJoinPolicy} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code SharedFolderJoinPolicy} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static SharedFolderJoinPolicy other() {
            return SharedFolderJoinPolicy.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private SharedFolderJoinPolicy(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case FROM_TEAM_ONLY:
                case FROM_ANYONE:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<SharedFolderJoinPolicy> _writer = new JsonWriter<SharedFolderJoinPolicy>()
        {
            public final void write(SharedFolderJoinPolicy x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case FROM_TEAM_ONLY:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("from_team_only");
                        g.writeEndObject();
                        break;
                    case FROM_ANYONE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("from_anyone");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<SharedFolderJoinPolicy> _reader = new JsonReader<SharedFolderJoinPolicy>()
        {
            public final SharedFolderJoinPolicy read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return SharedFolderJoinPolicy.other(); }
                    switch (tag) {
                        case FROM_TEAM_ONLY: return SharedFolderJoinPolicy.fromTeamOnly();
                        case FROM_ANYONE: return SharedFolderJoinPolicy.fromAnyone();
                        case OTHER: return SharedFolderJoinPolicy.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                SharedFolderJoinPolicy value = null;
                if (tag != null) {
                    switch (tag) {
                        case FROM_TEAM_ONLY: {
                            value = SharedFolderJoinPolicy.fromTeamOnly();
                            break;
                        }
                        case FROM_ANYONE: {
                            value = SharedFolderJoinPolicy.fromAnyone();
                            break;
                        }
                        case OTHER: {
                            value = SharedFolderJoinPolicy.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return SharedFolderJoinPolicy.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("from_team_only", Tag.FROM_TEAM_ONLY);
            _values.put("from_anyone", Tag.FROM_ANYONE);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "SharedFolderJoinPolicy." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "SharedFolderJoinPolicy." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static SharedFolderJoinPolicy fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information about a group.
     */
    public static class GroupSummary {
        // struct GroupSummary
        public final String groupName;
        public final String groupId;
        /**
         * External ID of group. This is an arbitrary ID that an admin can
         * attach to a group.
         */
        public final String groupExternalId;
        /**
         * The number of members in the group.
         */
        public final long memberCount;

        /**
         * Information about a group.
         *
         * @param groupName  . {@code groupName} must not be {@code null}.
         * @param groupId  . {@code groupId} must not be {@code null}.
         * @param memberCount  The number of members in the group.
         * @param groupExternalId  External ID of group. This is an arbitrary ID
         *     that an admin can attach to a group.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupSummary(String groupName, String groupId, long memberCount, String groupExternalId) {
            this.groupName = groupName;
            if (groupName == null) {
                throw new IllegalArgumentException("Required value for 'groupName' is null");
            }
            this.groupId = groupId;
            if (groupId == null) {
                throw new IllegalArgumentException("Required value for 'groupId' is null");
            }
            this.groupExternalId = groupExternalId;
            this.memberCount = memberCount;
        }

        static final JsonWriter<GroupSummary> _writer = new JsonWriter<GroupSummary>()
        {
            public final void write(GroupSummary x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupSummary._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupSummary x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("group_name", x.groupName);
                g.writeStringField("group_id", x.groupId);
                if (x.groupExternalId != null) {
                    g.writeFieldName("group_external_id");
                    g.writeString(x.groupExternalId);
                }
                g.writeNumberField("member_count", x.memberCount);
            }
        };

        public static final JsonReader<GroupSummary> _reader = new JsonReader<GroupSummary>() {

            public final GroupSummary read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupSummary result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupSummary readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String groupName = null;
                String groupId = null;
                Long memberCount = null;
                String groupExternalId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group_name".equals(fieldName)) {
                        groupName = JsonReader.StringReader
                            .readField(parser, "group_name", groupName);
                    }
                    else if ("group_id".equals(fieldName)) {
                        groupId = JsonReader.StringReader
                            .readField(parser, "group_id", groupId);
                    }
                    else if ("member_count".equals(fieldName)) {
                        memberCount = JsonReader.UInt32Reader
                            .readField(parser, "member_count", memberCount);
                    }
                    else if ("group_external_id".equals(fieldName)) {
                        groupExternalId = JsonReader.StringReader
                            .readField(parser, "group_external_id", groupExternalId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (groupName == null) {
                    throw new JsonReadException("Required field \"group_name\" is missing.", parser.getTokenLocation());
                }
                if (groupId == null) {
                    throw new JsonReadException("Required field \"group_id\" is missing.", parser.getTokenLocation());
                }
                if (memberCount == null) {
                    throw new JsonReadException("Required field \"member_count\" is missing.", parser.getTokenLocation());
                }
                return new GroupSummary(groupName, groupId, memberCount, groupExternalId);
            }
        };

        public String toString() {
            return "GroupSummary." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupSummary." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupSummary fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class ListMemberDevicesArg {
        // struct ListMemberDevicesArg
        /**
         * The team's member id
         */
        public final String teamMemberId;
        /**
         * Whether to list web sessions of the team's member
         */
        public final boolean includeWebSessions;
        /**
         * Whether to list linked desktop devices of the team's member
         */
        public final boolean includeDesktopClients;
        /**
         * Whether to list linked mobile devices of the team's member
         */
        public final boolean includeMobileClients;

        /**
         *
         * @param teamMemberId  The team's member id. {@code teamMemberId} must
         *     not be {@code null}.
         * @param includeWebSessions  Whether to list web sessions of the team's
         *     member.
         * @param includeDesktopClients  Whether to list linked desktop devices
         *     of the team's member.
         * @param includeMobileClients  Whether to list linked mobile devices of
         *     the team's member.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ListMemberDevicesArg(String teamMemberId, Boolean includeWebSessions, Boolean includeDesktopClients, Boolean includeMobileClients) {
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
            if (includeWebSessions != null) {
                this.includeWebSessions = includeWebSessions.booleanValue();
            }
            else {
                this.includeWebSessions = true;
            }
            if (includeDesktopClients != null) {
                this.includeDesktopClients = includeDesktopClients.booleanValue();
            }
            else {
                this.includeDesktopClients = true;
            }
            if (includeMobileClients != null) {
                this.includeMobileClients = includeMobileClients.booleanValue();
            }
            else {
                this.includeMobileClients = true;
            }
        }

        static final JsonWriter<ListMemberDevicesArg> _writer = new JsonWriter<ListMemberDevicesArg>()
        {
            public final void write(ListMemberDevicesArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListMemberDevicesArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListMemberDevicesArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("team_member_id", x.teamMemberId);
                g.writeBooleanField("include_web_sessions", x.includeWebSessions);
                g.writeBooleanField("include_desktop_clients", x.includeDesktopClients);
                g.writeBooleanField("include_mobile_clients", x.includeMobileClients);
            }
        };

        public static final JsonReader<ListMemberDevicesArg> _reader = new JsonReader<ListMemberDevicesArg>() {

            public final ListMemberDevicesArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListMemberDevicesArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListMemberDevicesArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String teamMemberId = null;
                Boolean includeWebSessions = null;
                Boolean includeDesktopClients = null;
                Boolean includeMobileClients = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("include_web_sessions".equals(fieldName)) {
                        includeWebSessions = JsonReader.BooleanReader
                            .readField(parser, "include_web_sessions", includeWebSessions);
                    }
                    else if ("include_desktop_clients".equals(fieldName)) {
                        includeDesktopClients = JsonReader.BooleanReader
                            .readField(parser, "include_desktop_clients", includeDesktopClients);
                    }
                    else if ("include_mobile_clients".equals(fieldName)) {
                        includeMobileClients = JsonReader.BooleanReader
                            .readField(parser, "include_mobile_clients", includeMobileClients);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                return new ListMemberDevicesArg(teamMemberId, includeWebSessions, includeDesktopClients, includeMobileClients);
            }
        };

        public String toString() {
            return "ListMemberDevicesArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListMemberDevicesArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListMemberDevicesArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class DeviceSession {
        // struct DeviceSession
        /**
         * The session id
         */
        public final String sessionId;
        /**
         * The IP address of the last activity from this session
         */
        public final String ipAddress;
        /**
         * The country from which the last activity from this session was made
         */
        public final String country;
        /**
         * The time this session was created
         */
        public final java.util.Date created;
        /**
         * The time of the last activity from this session
         */
        public final java.util.Date updated;

        /**
         *
         * @param sessionId  The session id. {@code sessionId} must not be
         *     {@code null}.
         * @param ipAddress  The IP address of the last activity from this
         *     session.
         * @param country  The country from which the last activity from this
         *     session was made.
         * @param created  The time this session was created.
         * @param updated  The time of the last activity from this session.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public DeviceSession(String sessionId, String ipAddress, String country, java.util.Date created, java.util.Date updated) {
            this.sessionId = sessionId;
            if (sessionId == null) {
                throw new IllegalArgumentException("Required value for 'sessionId' is null");
            }
            this.ipAddress = ipAddress;
            this.country = country;
            this.created = created;
            this.updated = updated;
        }

        static final JsonWriter<DeviceSession> _writer = new JsonWriter<DeviceSession>()
        {
            public final void write(DeviceSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DeviceSession._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(DeviceSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("session_id", x.sessionId);
                if (x.ipAddress != null) {
                    g.writeFieldName("ip_address");
                    g.writeString(x.ipAddress);
                }
                if (x.country != null) {
                    g.writeFieldName("country");
                    g.writeString(x.country);
                }
                if (x.created != null) {
                    g.writeFieldName("created");
                    writeDateIso(x.created, g);
                }
                if (x.updated != null) {
                    g.writeFieldName("updated");
                    writeDateIso(x.updated, g);
                }
            }
        };

        public static final JsonReader<DeviceSession> _reader = new JsonReader<DeviceSession>() {

            public final DeviceSession read(JsonParser parser)
                throws IOException, JsonReadException
            {
                DeviceSession result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final DeviceSession readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String sessionId = null;
                String ipAddress = null;
                String country = null;
                java.util.Date created = null;
                java.util.Date updated = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("session_id".equals(fieldName)) {
                        sessionId = JsonReader.StringReader
                            .readField(parser, "session_id", sessionId);
                    }
                    else if ("ip_address".equals(fieldName)) {
                        ipAddress = JsonReader.StringReader
                            .readField(parser, "ip_address", ipAddress);
                    }
                    else if ("country".equals(fieldName)) {
                        country = JsonReader.StringReader
                            .readField(parser, "country", country);
                    }
                    else if ("created".equals(fieldName)) {
                        created = JsonDateReader.DropboxV2
                            .readField(parser, "created", created);
                    }
                    else if ("updated".equals(fieldName)) {
                        updated = JsonDateReader.DropboxV2
                            .readField(parser, "updated", updated);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sessionId == null) {
                    throw new JsonReadException("Required field \"session_id\" is missing.", parser.getTokenLocation());
                }
                return new DeviceSession(sessionId, ipAddress, country, created, updated);
            }
        };

        public String toString() {
            return "DeviceSession." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "DeviceSession." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static DeviceSession fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information on active web sessions
     */
    public static class ActiveWebSession extends DeviceSession  {
        // struct ActiveWebSession
        /**
         * Information on the hosting device
         */
        public final String userAgent;
        /**
         * Information on the hosting operating system
         */
        public final String os;
        /**
         * Information on the browser used for this web session
         */
        public final String browser;

        /**
         * Information on active web sessions
         *
         * @param sessionId  The session id. {@code sessionId} must not be
         *     {@code null}.
         * @param userAgent  Information on the hosting device. {@code
         *     userAgent} must not be {@code null}.
         * @param os  Information on the hosting operating system. {@code os}
         *     must not be {@code null}.
         * @param browser  Information on the browser used for this web session.
         *     {@code browser} must not be {@code null}.
         * @param ipAddress  The IP address of the last activity from this
         *     session.
         * @param country  The country from which the last activity from this
         *     session was made.
         * @param created  The time this session was created.
         * @param updated  The time of the last activity from this session.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ActiveWebSession(String sessionId, String userAgent, String os, String browser, String ipAddress, String country, java.util.Date created, java.util.Date updated) {
            super(sessionId, ipAddress, country, created, updated);
            this.userAgent = userAgent;
            if (userAgent == null) {
                throw new IllegalArgumentException("Required value for 'userAgent' is null");
            }
            this.os = os;
            if (os == null) {
                throw new IllegalArgumentException("Required value for 'os' is null");
            }
            this.browser = browser;
            if (browser == null) {
                throw new IllegalArgumentException("Required value for 'browser' is null");
            }
        }

        static final JsonWriter<ActiveWebSession> _writer = new JsonWriter<ActiveWebSession>()
        {
            public final void write(ActiveWebSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DeviceSession._writer.writeFields(x, g);
                ActiveWebSession._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ActiveWebSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("user_agent", x.userAgent);
                g.writeStringField("os", x.os);
                g.writeStringField("browser", x.browser);
            }
        };

        public static final JsonReader<ActiveWebSession> _reader = new JsonReader<ActiveWebSession>() {

            public final ActiveWebSession read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ActiveWebSession result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ActiveWebSession readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String sessionId = null;
                String userAgent = null;
                String os = null;
                String browser = null;
                String ipAddress = null;
                String country = null;
                java.util.Date created = null;
                java.util.Date updated = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("session_id".equals(fieldName)) {
                        sessionId = JsonReader.StringReader
                            .readField(parser, "session_id", sessionId);
                    }
                    else if ("user_agent".equals(fieldName)) {
                        userAgent = JsonReader.StringReader
                            .readField(parser, "user_agent", userAgent);
                    }
                    else if ("os".equals(fieldName)) {
                        os = JsonReader.StringReader
                            .readField(parser, "os", os);
                    }
                    else if ("browser".equals(fieldName)) {
                        browser = JsonReader.StringReader
                            .readField(parser, "browser", browser);
                    }
                    else if ("ip_address".equals(fieldName)) {
                        ipAddress = JsonReader.StringReader
                            .readField(parser, "ip_address", ipAddress);
                    }
                    else if ("country".equals(fieldName)) {
                        country = JsonReader.StringReader
                            .readField(parser, "country", country);
                    }
                    else if ("created".equals(fieldName)) {
                        created = JsonDateReader.DropboxV2
                            .readField(parser, "created", created);
                    }
                    else if ("updated".equals(fieldName)) {
                        updated = JsonDateReader.DropboxV2
                            .readField(parser, "updated", updated);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sessionId == null) {
                    throw new JsonReadException("Required field \"session_id\" is missing.", parser.getTokenLocation());
                }
                if (userAgent == null) {
                    throw new JsonReadException("Required field \"user_agent\" is missing.", parser.getTokenLocation());
                }
                if (os == null) {
                    throw new JsonReadException("Required field \"os\" is missing.", parser.getTokenLocation());
                }
                if (browser == null) {
                    throw new JsonReadException("Required field \"browser\" is missing.", parser.getTokenLocation());
                }
                return new ActiveWebSession(sessionId, userAgent, os, browser, ipAddress, country, created, updated);
            }
        };

        public String toString() {
            return "ActiveWebSession." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ActiveWebSession." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ActiveWebSession fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class DesktopPlatform {
        // union DesktopPlatform

        /**
         * The discriminating tag type for {@link DesktopPlatform}.
         */
        public enum Tag {
            /**
             * Official Windows Dropbox desktop client
             */
            WINDOWS,
            /**
             * Official Mac Dropbox desktop client
             */
            MAC,
            /**
             * Official Linux Dropbox desktop client
             */
            LINUX,
            /**
             * Official Dropbox desktop client for another platform
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code DesktopPlatform}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Official Windows Dropbox desktop client
         */
        private static final DesktopPlatform WINDOWS_INSTANCE = new DesktopPlatform(Tag.WINDOWS);

        /**
         * Returns an instance of {@code DesktopPlatform} that has its tag set
         * to {@link Tag#WINDOWS}.
         *
         * <p> Official Windows Dropbox desktop client </p>
         *
         * @return Instance of {@code DesktopPlatform} with its tag set to
         *     {@link Tag#WINDOWS}.
         */
        public static DesktopPlatform windows() {
            return DesktopPlatform.WINDOWS_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#WINDOWS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#WINDOWS}, {@code false} otherwise.
         */
        public boolean isWindows() {
            return this.tag == Tag.WINDOWS;
        }

        /**
         * Official Mac Dropbox desktop client
         */
        private static final DesktopPlatform MAC_INSTANCE = new DesktopPlatform(Tag.MAC);

        /**
         * Returns an instance of {@code DesktopPlatform} that has its tag set
         * to {@link Tag#MAC}.
         *
         * <p> Official Mac Dropbox desktop client </p>
         *
         * @return Instance of {@code DesktopPlatform} with its tag set to
         *     {@link Tag#MAC}.
         */
        public static DesktopPlatform mac() {
            return DesktopPlatform.MAC_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#MAC},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#MAC},
         *     {@code false} otherwise.
         */
        public boolean isMac() {
            return this.tag == Tag.MAC;
        }

        /**
         * Official Linux Dropbox desktop client
         */
        private static final DesktopPlatform LINUX_INSTANCE = new DesktopPlatform(Tag.LINUX);

        /**
         * Returns an instance of {@code DesktopPlatform} that has its tag set
         * to {@link Tag#LINUX}.
         *
         * <p> Official Linux Dropbox desktop client </p>
         *
         * @return Instance of {@code DesktopPlatform} with its tag set to
         *     {@link Tag#LINUX}.
         */
        public static DesktopPlatform linux() {
            return DesktopPlatform.LINUX_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#LINUX},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#LINUX},
         *     {@code false} otherwise.
         */
        public boolean isLinux() {
            return this.tag == Tag.LINUX;
        }

        /**
         * Official Dropbox desktop client for another platform
         */
        private static final DesktopPlatform OTHER_INSTANCE = new DesktopPlatform(Tag.OTHER);

        /**
         * Returns an instance of {@code DesktopPlatform} that has its tag set
         * to {@link Tag#OTHER}.
         *
         * <p> Official Dropbox desktop client for another platform </p>
         *
         * @return Instance of {@code DesktopPlatform} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static DesktopPlatform other() {
            return DesktopPlatform.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private DesktopPlatform(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case WINDOWS:
                case MAC:
                case LINUX:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<DesktopPlatform> _writer = new JsonWriter<DesktopPlatform>()
        {
            public final void write(DesktopPlatform x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case WINDOWS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("windows");
                        g.writeEndObject();
                        break;
                    case MAC:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("mac");
                        g.writeEndObject();
                        break;
                    case LINUX:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("linux");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<DesktopPlatform> _reader = new JsonReader<DesktopPlatform>()
        {
            public final DesktopPlatform read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return DesktopPlatform.other(); }
                    switch (tag) {
                        case WINDOWS: return DesktopPlatform.windows();
                        case MAC: return DesktopPlatform.mac();
                        case LINUX: return DesktopPlatform.linux();
                        case OTHER: return DesktopPlatform.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                DesktopPlatform value = null;
                if (tag != null) {
                    switch (tag) {
                        case WINDOWS: {
                            value = DesktopPlatform.windows();
                            break;
                        }
                        case MAC: {
                            value = DesktopPlatform.mac();
                            break;
                        }
                        case LINUX: {
                            value = DesktopPlatform.linux();
                            break;
                        }
                        case OTHER: {
                            value = DesktopPlatform.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return DesktopPlatform.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("windows", Tag.WINDOWS);
            _values.put("mac", Tag.MAC);
            _values.put("linux", Tag.LINUX);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "DesktopPlatform." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "DesktopPlatform." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static DesktopPlatform fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information about linked Dropbox desktop client sessions
     */
    public static class DesktopClientSession extends DeviceSession  {
        // struct DesktopClientSession
        /**
         * Name of the hosting desktop
         */
        public final String hostName;
        /**
         * The Dropbox desktop client type
         */
        public final DesktopPlatform clientType;
        /**
         * The Dropbox client version
         */
        public final String clientVersion;
        /**
         * Information on the hosting platform
         */
        public final String platform;
        /**
         * Whether it's possible to delete all of the account files upon
         * unlinking
         */
        public final boolean isDeleteOnUnlinkSupported;

        /**
         * Information about linked Dropbox desktop client sessions
         *
         * @param sessionId  The session id. {@code sessionId} must not be
         *     {@code null}.
         * @param hostName  Name of the hosting desktop. {@code hostName} must
         *     not be {@code null}.
         * @param clientType  The Dropbox desktop client type. {@code
         *     clientType} must not be {@code null}.
         * @param clientVersion  The Dropbox client version. {@code
         *     clientVersion} must not be {@code null}.
         * @param platform  Information on the hosting platform. {@code
         *     platform} must not be {@code null}.
         * @param isDeleteOnUnlinkSupported  Whether it's possible to delete all
         *     of the account files upon unlinking.
         * @param ipAddress  The IP address of the last activity from this
         *     session.
         * @param country  The country from which the last activity from this
         *     session was made.
         * @param created  The time this session was created.
         * @param updated  The time of the last activity from this session.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public DesktopClientSession(String sessionId, String hostName, DesktopPlatform clientType, String clientVersion, String platform, boolean isDeleteOnUnlinkSupported, String ipAddress, String country, java.util.Date created, java.util.Date updated) {
            super(sessionId, ipAddress, country, created, updated);
            this.hostName = hostName;
            if (hostName == null) {
                throw new IllegalArgumentException("Required value for 'hostName' is null");
            }
            this.clientType = clientType;
            if (clientType == null) {
                throw new IllegalArgumentException("Required value for 'clientType' is null");
            }
            this.clientVersion = clientVersion;
            if (clientVersion == null) {
                throw new IllegalArgumentException("Required value for 'clientVersion' is null");
            }
            this.platform = platform;
            if (platform == null) {
                throw new IllegalArgumentException("Required value for 'platform' is null");
            }
            this.isDeleteOnUnlinkSupported = isDeleteOnUnlinkSupported;
        }

        static final JsonWriter<DesktopClientSession> _writer = new JsonWriter<DesktopClientSession>()
        {
            public final void write(DesktopClientSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DeviceSession._writer.writeFields(x, g);
                DesktopClientSession._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(DesktopClientSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("host_name", x.hostName);
                g.writeFieldName("client_type");
                DesktopPlatform._writer.write(x.clientType, g);
                g.writeStringField("client_version", x.clientVersion);
                g.writeStringField("platform", x.platform);
                g.writeBooleanField("is_delete_on_unlink_supported", x.isDeleteOnUnlinkSupported);
            }
        };

        public static final JsonReader<DesktopClientSession> _reader = new JsonReader<DesktopClientSession>() {

            public final DesktopClientSession read(JsonParser parser)
                throws IOException, JsonReadException
            {
                DesktopClientSession result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final DesktopClientSession readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String sessionId = null;
                String hostName = null;
                DesktopPlatform clientType = null;
                String clientVersion = null;
                String platform = null;
                Boolean isDeleteOnUnlinkSupported = null;
                String ipAddress = null;
                String country = null;
                java.util.Date created = null;
                java.util.Date updated = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("session_id".equals(fieldName)) {
                        sessionId = JsonReader.StringReader
                            .readField(parser, "session_id", sessionId);
                    }
                    else if ("host_name".equals(fieldName)) {
                        hostName = JsonReader.StringReader
                            .readField(parser, "host_name", hostName);
                    }
                    else if ("client_type".equals(fieldName)) {
                        clientType = DesktopPlatform._reader
                            .readField(parser, "client_type", clientType);
                    }
                    else if ("client_version".equals(fieldName)) {
                        clientVersion = JsonReader.StringReader
                            .readField(parser, "client_version", clientVersion);
                    }
                    else if ("platform".equals(fieldName)) {
                        platform = JsonReader.StringReader
                            .readField(parser, "platform", platform);
                    }
                    else if ("is_delete_on_unlink_supported".equals(fieldName)) {
                        isDeleteOnUnlinkSupported = JsonReader.BooleanReader
                            .readField(parser, "is_delete_on_unlink_supported", isDeleteOnUnlinkSupported);
                    }
                    else if ("ip_address".equals(fieldName)) {
                        ipAddress = JsonReader.StringReader
                            .readField(parser, "ip_address", ipAddress);
                    }
                    else if ("country".equals(fieldName)) {
                        country = JsonReader.StringReader
                            .readField(parser, "country", country);
                    }
                    else if ("created".equals(fieldName)) {
                        created = JsonDateReader.DropboxV2
                            .readField(parser, "created", created);
                    }
                    else if ("updated".equals(fieldName)) {
                        updated = JsonDateReader.DropboxV2
                            .readField(parser, "updated", updated);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sessionId == null) {
                    throw new JsonReadException("Required field \"session_id\" is missing.", parser.getTokenLocation());
                }
                if (hostName == null) {
                    throw new JsonReadException("Required field \"host_name\" is missing.", parser.getTokenLocation());
                }
                if (clientType == null) {
                    throw new JsonReadException("Required field \"client_type\" is missing.", parser.getTokenLocation());
                }
                if (clientVersion == null) {
                    throw new JsonReadException("Required field \"client_version\" is missing.", parser.getTokenLocation());
                }
                if (platform == null) {
                    throw new JsonReadException("Required field \"platform\" is missing.", parser.getTokenLocation());
                }
                if (isDeleteOnUnlinkSupported == null) {
                    throw new JsonReadException("Required field \"is_delete_on_unlink_supported\" is missing.", parser.getTokenLocation());
                }
                return new DesktopClientSession(sessionId, hostName, clientType, clientVersion, platform, isDeleteOnUnlinkSupported, ipAddress, country, created, updated);
            }
        };

        public String toString() {
            return "DesktopClientSession." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "DesktopClientSession." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static DesktopClientSession fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MobileClientPlatform {
        // union MobileClientPlatform

        /**
         * The discriminating tag type for {@link MobileClientPlatform}.
         */
        public enum Tag {
            /**
             * Official Dropbox iPhone client
             */
            IPHONE,
            /**
             * Official Dropbox iPad client
             */
            IPAD,
            /**
             * Official Dropbox Android client
             */
            ANDROID,
            /**
             * Official Dropbox Windows phone client
             */
            WINDOWS_PHONE,
            /**
             * Official Dropbox Blackberry client
             */
            BLACKBERRY,
            /**
             * Official Dropbox client for another platform
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MobileClientPlatform}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Official Dropbox iPhone client
         */
        private static final MobileClientPlatform IPHONE_INSTANCE = new MobileClientPlatform(Tag.IPHONE);

        /**
         * Returns an instance of {@code MobileClientPlatform} that has its tag
         * set to {@link Tag#IPHONE}.
         *
         * <p> Official Dropbox iPhone client </p>
         *
         * @return Instance of {@code MobileClientPlatform} with its tag set to
         *     {@link Tag#IPHONE}.
         */
        public static MobileClientPlatform iphone() {
            return MobileClientPlatform.IPHONE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#IPHONE},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#IPHONE}, {@code false} otherwise.
         */
        public boolean isIphone() {
            return this.tag == Tag.IPHONE;
        }

        /**
         * Official Dropbox iPad client
         */
        private static final MobileClientPlatform IPAD_INSTANCE = new MobileClientPlatform(Tag.IPAD);

        /**
         * Returns an instance of {@code MobileClientPlatform} that has its tag
         * set to {@link Tag#IPAD}.
         *
         * <p> Official Dropbox iPad client </p>
         *
         * @return Instance of {@code MobileClientPlatform} with its tag set to
         *     {@link Tag#IPAD}.
         */
        public static MobileClientPlatform ipad() {
            return MobileClientPlatform.IPAD_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#IPAD},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#IPAD},
         *     {@code false} otherwise.
         */
        public boolean isIpad() {
            return this.tag == Tag.IPAD;
        }

        /**
         * Official Dropbox Android client
         */
        private static final MobileClientPlatform ANDROID_INSTANCE = new MobileClientPlatform(Tag.ANDROID);

        /**
         * Returns an instance of {@code MobileClientPlatform} that has its tag
         * set to {@link Tag#ANDROID}.
         *
         * <p> Official Dropbox Android client </p>
         *
         * @return Instance of {@code MobileClientPlatform} with its tag set to
         *     {@link Tag#ANDROID}.
         */
        public static MobileClientPlatform android() {
            return MobileClientPlatform.ANDROID_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#ANDROID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#ANDROID}, {@code false} otherwise.
         */
        public boolean isAndroid() {
            return this.tag == Tag.ANDROID;
        }

        /**
         * Official Dropbox Windows phone client
         */
        private static final MobileClientPlatform WINDOWS_PHONE_INSTANCE = new MobileClientPlatform(Tag.WINDOWS_PHONE);

        /**
         * Returns an instance of {@code MobileClientPlatform} that has its tag
         * set to {@link Tag#WINDOWS_PHONE}.
         *
         * <p> Official Dropbox Windows phone client </p>
         *
         * @return Instance of {@code MobileClientPlatform} with its tag set to
         *     {@link Tag#WINDOWS_PHONE}.
         */
        public static MobileClientPlatform windowsPhone() {
            return MobileClientPlatform.WINDOWS_PHONE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#WINDOWS_PHONE}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#WINDOWS_PHONE}, {@code false} otherwise.
         */
        public boolean isWindowsPhone() {
            return this.tag == Tag.WINDOWS_PHONE;
        }

        /**
         * Official Dropbox Blackberry client
         */
        private static final MobileClientPlatform BLACKBERRY_INSTANCE = new MobileClientPlatform(Tag.BLACKBERRY);

        /**
         * Returns an instance of {@code MobileClientPlatform} that has its tag
         * set to {@link Tag#BLACKBERRY}.
         *
         * <p> Official Dropbox Blackberry client </p>
         *
         * @return Instance of {@code MobileClientPlatform} with its tag set to
         *     {@link Tag#BLACKBERRY}.
         */
        public static MobileClientPlatform blackberry() {
            return MobileClientPlatform.BLACKBERRY_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#BLACKBERRY}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#BLACKBERRY}, {@code false} otherwise.
         */
        public boolean isBlackberry() {
            return this.tag == Tag.BLACKBERRY;
        }

        /**
         * Official Dropbox client for another platform
         */
        private static final MobileClientPlatform OTHER_INSTANCE = new MobileClientPlatform(Tag.OTHER);

        /**
         * Returns an instance of {@code MobileClientPlatform} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> Official Dropbox client for another platform </p>
         *
         * @return Instance of {@code MobileClientPlatform} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static MobileClientPlatform other() {
            return MobileClientPlatform.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MobileClientPlatform(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case IPHONE:
                case IPAD:
                case ANDROID:
                case WINDOWS_PHONE:
                case BLACKBERRY:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MobileClientPlatform> _writer = new JsonWriter<MobileClientPlatform>()
        {
            public final void write(MobileClientPlatform x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case IPHONE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("iphone");
                        g.writeEndObject();
                        break;
                    case IPAD:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("ipad");
                        g.writeEndObject();
                        break;
                    case ANDROID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("android");
                        g.writeEndObject();
                        break;
                    case WINDOWS_PHONE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("windows_phone");
                        g.writeEndObject();
                        break;
                    case BLACKBERRY:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("blackberry");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MobileClientPlatform> _reader = new JsonReader<MobileClientPlatform>()
        {
            public final MobileClientPlatform read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MobileClientPlatform.other(); }
                    switch (tag) {
                        case IPHONE: return MobileClientPlatform.iphone();
                        case IPAD: return MobileClientPlatform.ipad();
                        case ANDROID: return MobileClientPlatform.android();
                        case WINDOWS_PHONE: return MobileClientPlatform.windowsPhone();
                        case BLACKBERRY: return MobileClientPlatform.blackberry();
                        case OTHER: return MobileClientPlatform.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MobileClientPlatform value = null;
                if (tag != null) {
                    switch (tag) {
                        case IPHONE: {
                            value = MobileClientPlatform.iphone();
                            break;
                        }
                        case IPAD: {
                            value = MobileClientPlatform.ipad();
                            break;
                        }
                        case ANDROID: {
                            value = MobileClientPlatform.android();
                            break;
                        }
                        case WINDOWS_PHONE: {
                            value = MobileClientPlatform.windowsPhone();
                            break;
                        }
                        case BLACKBERRY: {
                            value = MobileClientPlatform.blackberry();
                            break;
                        }
                        case OTHER: {
                            value = MobileClientPlatform.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MobileClientPlatform.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("iphone", Tag.IPHONE);
            _values.put("ipad", Tag.IPAD);
            _values.put("android", Tag.ANDROID);
            _values.put("windows_phone", Tag.WINDOWS_PHONE);
            _values.put("blackberry", Tag.BLACKBERRY);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MobileClientPlatform." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MobileClientPlatform." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MobileClientPlatform fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information about linked Dropbox mobile client sessions
     */
    public static class MobileClientSession extends DeviceSession  {
        // struct MobileClientSession
        /**
         * The device name
         */
        public final String deviceName;
        /**
         * The mobile application type
         */
        public final MobileClientPlatform clientType;
        /**
         * The dropbox client version
         */
        public final String clientVersion;
        /**
         * The hosting OS version
         */
        public final String osVersion;
        /**
         * last carrier used by the device
         */
        public final String lastCarrier;

        /**
         * Information about linked Dropbox mobile client sessions
         *
         * @param sessionId  The session id. {@code sessionId} must not be
         *     {@code null}.
         * @param deviceName  The device name. {@code deviceName} must not be
         *     {@code null}.
         * @param clientType  The mobile application type. {@code clientType}
         *     must not be {@code null}.
         * @param ipAddress  The IP address of the last activity from this
         *     session.
         * @param country  The country from which the last activity from this
         *     session was made.
         * @param created  The time this session was created.
         * @param updated  The time of the last activity from this session.
         * @param clientVersion  The dropbox client version.
         * @param osVersion  The hosting OS version.
         * @param lastCarrier  last carrier used by the device.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MobileClientSession(String sessionId, String deviceName, MobileClientPlatform clientType, String ipAddress, String country, java.util.Date created, java.util.Date updated, String clientVersion, String osVersion, String lastCarrier) {
            super(sessionId, ipAddress, country, created, updated);
            this.deviceName = deviceName;
            if (deviceName == null) {
                throw new IllegalArgumentException("Required value for 'deviceName' is null");
            }
            this.clientType = clientType;
            if (clientType == null) {
                throw new IllegalArgumentException("Required value for 'clientType' is null");
            }
            this.clientVersion = clientVersion;
            this.osVersion = osVersion;
            this.lastCarrier = lastCarrier;
        }

        static final JsonWriter<MobileClientSession> _writer = new JsonWriter<MobileClientSession>()
        {
            public final void write(MobileClientSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DeviceSession._writer.writeFields(x, g);
                MobileClientSession._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MobileClientSession x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("device_name", x.deviceName);
                g.writeFieldName("client_type");
                MobileClientPlatform._writer.write(x.clientType, g);
                if (x.clientVersion != null) {
                    g.writeFieldName("client_version");
                    g.writeString(x.clientVersion);
                }
                if (x.osVersion != null) {
                    g.writeFieldName("os_version");
                    g.writeString(x.osVersion);
                }
                if (x.lastCarrier != null) {
                    g.writeFieldName("last_carrier");
                    g.writeString(x.lastCarrier);
                }
            }
        };

        public static final JsonReader<MobileClientSession> _reader = new JsonReader<MobileClientSession>() {

            public final MobileClientSession read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MobileClientSession result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MobileClientSession readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String sessionId = null;
                String deviceName = null;
                MobileClientPlatform clientType = null;
                String ipAddress = null;
                String country = null;
                java.util.Date created = null;
                java.util.Date updated = null;
                String clientVersion = null;
                String osVersion = null;
                String lastCarrier = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("session_id".equals(fieldName)) {
                        sessionId = JsonReader.StringReader
                            .readField(parser, "session_id", sessionId);
                    }
                    else if ("device_name".equals(fieldName)) {
                        deviceName = JsonReader.StringReader
                            .readField(parser, "device_name", deviceName);
                    }
                    else if ("client_type".equals(fieldName)) {
                        clientType = MobileClientPlatform._reader
                            .readField(parser, "client_type", clientType);
                    }
                    else if ("ip_address".equals(fieldName)) {
                        ipAddress = JsonReader.StringReader
                            .readField(parser, "ip_address", ipAddress);
                    }
                    else if ("country".equals(fieldName)) {
                        country = JsonReader.StringReader
                            .readField(parser, "country", country);
                    }
                    else if ("created".equals(fieldName)) {
                        created = JsonDateReader.DropboxV2
                            .readField(parser, "created", created);
                    }
                    else if ("updated".equals(fieldName)) {
                        updated = JsonDateReader.DropboxV2
                            .readField(parser, "updated", updated);
                    }
                    else if ("client_version".equals(fieldName)) {
                        clientVersion = JsonReader.StringReader
                            .readField(parser, "client_version", clientVersion);
                    }
                    else if ("os_version".equals(fieldName)) {
                        osVersion = JsonReader.StringReader
                            .readField(parser, "os_version", osVersion);
                    }
                    else if ("last_carrier".equals(fieldName)) {
                        lastCarrier = JsonReader.StringReader
                            .readField(parser, "last_carrier", lastCarrier);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sessionId == null) {
                    throw new JsonReadException("Required field \"session_id\" is missing.", parser.getTokenLocation());
                }
                if (deviceName == null) {
                    throw new JsonReadException("Required field \"device_name\" is missing.", parser.getTokenLocation());
                }
                if (clientType == null) {
                    throw new JsonReadException("Required field \"client_type\" is missing.", parser.getTokenLocation());
                }
                return new MobileClientSession(sessionId, deviceName, clientType, ipAddress, country, created, updated, clientVersion, osVersion, lastCarrier);
            }
        };

        public String toString() {
            return "MobileClientSession." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MobileClientSession." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MobileClientSession fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class ListMemberDevicesResult {
        // struct ListMemberDevicesResult
        /**
         * List of web sessions made by this team member
         */
        public final java.util.List<ActiveWebSession> activeWebSessions;
        /**
         * List of desktop clients used by this team member
         */
        public final java.util.List<DesktopClientSession> desktopClientSessions;
        /**
         * List of mobile client used by this team member
         */
        public final java.util.List<MobileClientSession> mobileClientSessions;

        /**
         *
         * @param activeWebSessions  List of web sessions made by this team
         *     member. {@code activeWebSessions} must not contain a {@code null}
         *     item.
         * @param desktopClientSessions  List of desktop clients used by this
         *     team member. {@code desktopClientSessions} must not contain a
         *     {@code null} item.
         * @param mobileClientSessions  List of mobile client used by this team
         *     member. {@code mobileClientSessions} must not contain a {@code
         *     null} item.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ListMemberDevicesResult(java.util.List<ActiveWebSession> activeWebSessions, java.util.List<DesktopClientSession> desktopClientSessions, java.util.List<MobileClientSession> mobileClientSessions) {
            this.activeWebSessions = activeWebSessions;
            if (activeWebSessions != null) {
                for (ActiveWebSession x : activeWebSessions) {
                    if (x == null) {
                        throw new IllegalArgumentException("An item in list 'activeWebSessions' is null");
                    }
                }
            }
            this.desktopClientSessions = desktopClientSessions;
            if (desktopClientSessions != null) {
                for (DesktopClientSession x : desktopClientSessions) {
                    if (x == null) {
                        throw new IllegalArgumentException("An item in list 'desktopClientSessions' is null");
                    }
                }
            }
            this.mobileClientSessions = mobileClientSessions;
            if (mobileClientSessions != null) {
                for (MobileClientSession x : mobileClientSessions) {
                    if (x == null) {
                        throw new IllegalArgumentException("An item in list 'mobileClientSessions' is null");
                    }
                }
            }
        }

        static final JsonWriter<ListMemberDevicesResult> _writer = new JsonWriter<ListMemberDevicesResult>()
        {
            public final void write(ListMemberDevicesResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListMemberDevicesResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListMemberDevicesResult x, JsonGenerator g)
             throws IOException
            {
                if (x.activeWebSessions != null) {
                    g.writeFieldName("active_web_sessions");
                    g.writeStartArray();
                    for (ActiveWebSession item: x.activeWebSessions) {
                        if (item != null) {
                            ActiveWebSession._writer.write(item, g);
                        }
                    }
                    g.writeEndArray();
                }
                if (x.desktopClientSessions != null) {
                    g.writeFieldName("desktop_client_sessions");
                    g.writeStartArray();
                    for (DesktopClientSession item: x.desktopClientSessions) {
                        if (item != null) {
                            DesktopClientSession._writer.write(item, g);
                        }
                    }
                    g.writeEndArray();
                }
                if (x.mobileClientSessions != null) {
                    g.writeFieldName("mobile_client_sessions");
                    g.writeStartArray();
                    for (MobileClientSession item: x.mobileClientSessions) {
                        if (item != null) {
                            MobileClientSession._writer.write(item, g);
                        }
                    }
                    g.writeEndArray();
                }
            }
        };

        public static final JsonReader<ListMemberDevicesResult> _reader = new JsonReader<ListMemberDevicesResult>() {

            public final ListMemberDevicesResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListMemberDevicesResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListMemberDevicesResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<ActiveWebSession> activeWebSessions = null;
                java.util.List<DesktopClientSession> desktopClientSessions = null;
                java.util.List<MobileClientSession> mobileClientSessions = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("active_web_sessions".equals(fieldName)) {
                        activeWebSessions = JsonArrayReader.mk(ActiveWebSession._reader)
                            .readField(parser, "active_web_sessions", activeWebSessions);
                    }
                    else if ("desktop_client_sessions".equals(fieldName)) {
                        desktopClientSessions = JsonArrayReader.mk(DesktopClientSession._reader)
                            .readField(parser, "desktop_client_sessions", desktopClientSessions);
                    }
                    else if ("mobile_client_sessions".equals(fieldName)) {
                        mobileClientSessions = JsonArrayReader.mk(MobileClientSession._reader)
                            .readField(parser, "mobile_client_sessions", mobileClientSessions);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                return new ListMemberDevicesResult(activeWebSessions, desktopClientSessions, mobileClientSessions);
            }
        };

        public String toString() {
            return "ListMemberDevicesResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListMemberDevicesResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListMemberDevicesResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class ListMemberDevicesError {
        // union ListMemberDevicesError

        /**
         * The discriminating tag type for {@link ListMemberDevicesError}.
         */
        public enum Tag {
            /**
             * Member not found.
             */
            MEMBER_NOT_FOUND,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code ListMemberDevicesError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Member not found.
         */
        private static final ListMemberDevicesError MEMBER_NOT_FOUND_INSTANCE = new ListMemberDevicesError(Tag.MEMBER_NOT_FOUND);

        /**
         * Returns an instance of {@code ListMemberDevicesError} that has its
         * tag set to {@link Tag#MEMBER_NOT_FOUND}.
         *
         * <p> Member not found. </p>
         *
         * @return Instance of {@code ListMemberDevicesError} with its tag set
         *     to {@link Tag#MEMBER_NOT_FOUND}.
         */
        public static ListMemberDevicesError memberNotFound() {
            return ListMemberDevicesError.MEMBER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isMemberNotFound() {
            return this.tag == Tag.MEMBER_NOT_FOUND;
        }

        /**
         * An unspecified error.
         */
        private static final ListMemberDevicesError OTHER_INSTANCE = new ListMemberDevicesError(Tag.OTHER);

        /**
         * Returns an instance of {@code ListMemberDevicesError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code ListMemberDevicesError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static ListMemberDevicesError other() {
            return ListMemberDevicesError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private ListMemberDevicesError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case MEMBER_NOT_FOUND:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<ListMemberDevicesError> _writer = new JsonWriter<ListMemberDevicesError>()
        {
            public final void write(ListMemberDevicesError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case MEMBER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<ListMemberDevicesError> _reader = new JsonReader<ListMemberDevicesError>()
        {
            public final ListMemberDevicesError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return ListMemberDevicesError.other(); }
                    switch (tag) {
                        case MEMBER_NOT_FOUND: return ListMemberDevicesError.memberNotFound();
                        case OTHER: return ListMemberDevicesError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                ListMemberDevicesError value = null;
                if (tag != null) {
                    switch (tag) {
                        case MEMBER_NOT_FOUND: {
                            value = ListMemberDevicesError.memberNotFound();
                            break;
                        }
                        case OTHER: {
                            value = ListMemberDevicesError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return ListMemberDevicesError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("member_not_found", Tag.MEMBER_NOT_FOUND);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "ListMemberDevicesError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "ListMemberDevicesError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static ListMemberDevicesError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class ListTeamDevicesArg {
        // struct ListTeamDevicesArg
        /**
         * At the first call to the {@link
         * DbxTeam#devicesListTeamDevicesBuilder} the cursor shouldn't be
         * passed. Then, if the result of the call includes a cursor, the
         * following requests should include the received cursors in order to
         * receive the next sub list of team devices
         */
        public final String cursor;
        /**
         * Whether to list web sessions of the team members
         */
        public final boolean includeWebSessions;
        /**
         * Whether to list desktop clients of the team members
         */
        public final boolean includeDesktopClients;
        /**
         * Whether to list mobile clients of the team members
         */
        public final boolean includeMobileClients;

        /**
         *
         * @param cursor  At the first call to the {@link
         *     DbxTeam#devicesListTeamDevicesBuilder} the cursor shouldn't be
         *     passed. Then, if the result of the call includes a cursor, the
         *     following requests should include the received cursors in order
         *     to receive the next sub list of team devices.
         * @param includeWebSessions  Whether to list web sessions of the team
         *     members.
         * @param includeDesktopClients  Whether to list desktop clients of the
         *     team members.
         * @param includeMobileClients  Whether to list mobile clients of the
         *     team members.
         */
        public ListTeamDevicesArg(String cursor, Boolean includeWebSessions, Boolean includeDesktopClients, Boolean includeMobileClients) {
            this.cursor = cursor;
            if (includeWebSessions != null) {
                this.includeWebSessions = includeWebSessions.booleanValue();
            }
            else {
                this.includeWebSessions = true;
            }
            if (includeDesktopClients != null) {
                this.includeDesktopClients = includeDesktopClients.booleanValue();
            }
            else {
                this.includeDesktopClients = true;
            }
            if (includeMobileClients != null) {
                this.includeMobileClients = includeMobileClients.booleanValue();
            }
            else {
                this.includeMobileClients = true;
            }
        }

        static final JsonWriter<ListTeamDevicesArg> _writer = new JsonWriter<ListTeamDevicesArg>()
        {
            public final void write(ListTeamDevicesArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListTeamDevicesArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListTeamDevicesArg x, JsonGenerator g)
             throws IOException
            {
                if (x.cursor != null) {
                    g.writeFieldName("cursor");
                    g.writeString(x.cursor);
                }
                g.writeBooleanField("include_web_sessions", x.includeWebSessions);
                g.writeBooleanField("include_desktop_clients", x.includeDesktopClients);
                g.writeBooleanField("include_mobile_clients", x.includeMobileClients);
            }
        };

        public static final JsonReader<ListTeamDevicesArg> _reader = new JsonReader<ListTeamDevicesArg>() {

            public final ListTeamDevicesArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListTeamDevicesArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListTeamDevicesArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String cursor = null;
                Boolean includeWebSessions = null;
                Boolean includeDesktopClients = null;
                Boolean includeMobileClients = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else if ("include_web_sessions".equals(fieldName)) {
                        includeWebSessions = JsonReader.BooleanReader
                            .readField(parser, "include_web_sessions", includeWebSessions);
                    }
                    else if ("include_desktop_clients".equals(fieldName)) {
                        includeDesktopClients = JsonReader.BooleanReader
                            .readField(parser, "include_desktop_clients", includeDesktopClients);
                    }
                    else if ("include_mobile_clients".equals(fieldName)) {
                        includeMobileClients = JsonReader.BooleanReader
                            .readField(parser, "include_mobile_clients", includeMobileClients);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                return new ListTeamDevicesArg(cursor, includeWebSessions, includeDesktopClients, includeMobileClients);
            }
        };

        public String toString() {
            return "ListTeamDevicesArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListTeamDevicesArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListTeamDevicesArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information on devices of a team's member.
     */
    public static class MemberDevices {
        // struct MemberDevices
        /**
         * The member unique Id
         */
        public final String teamMemberId;
        /**
         * List of web sessions made by this team member
         */
        public final java.util.List<ActiveWebSession> webSessions;
        /**
         * List of desktop clients by this team member
         */
        public final java.util.List<DesktopClientSession> desktopClients;
        /**
         * List of mobile clients by this team member
         */
        public final java.util.List<MobileClientSession> mobileClients;

        /**
         * Information on devices of a team's member.
         *
         * @param teamMemberId  The member unique Id. {@code teamMemberId} must
         *     not be {@code null}.
         * @param webSessions  List of web sessions made by this team member.
         *     {@code webSessions} must not contain a {@code null} item.
         * @param desktopClients  List of desktop clients by this team member.
         *     {@code desktopClients} must not contain a {@code null} item.
         * @param mobileClients  List of mobile clients by this team member.
         *     {@code mobileClients} must not contain a {@code null} item.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MemberDevices(String teamMemberId, java.util.List<ActiveWebSession> webSessions, java.util.List<DesktopClientSession> desktopClients, java.util.List<MobileClientSession> mobileClients) {
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
            this.webSessions = webSessions;
            if (webSessions != null) {
                for (ActiveWebSession x : webSessions) {
                    if (x == null) {
                        throw new IllegalArgumentException("An item in list 'webSessions' is null");
                    }
                }
            }
            this.desktopClients = desktopClients;
            if (desktopClients != null) {
                for (DesktopClientSession x : desktopClients) {
                    if (x == null) {
                        throw new IllegalArgumentException("An item in list 'desktopClients' is null");
                    }
                }
            }
            this.mobileClients = mobileClients;
            if (mobileClients != null) {
                for (MobileClientSession x : mobileClients) {
                    if (x == null) {
                        throw new IllegalArgumentException("An item in list 'mobileClients' is null");
                    }
                }
            }
        }

        static final JsonWriter<MemberDevices> _writer = new JsonWriter<MemberDevices>()
        {
            public final void write(MemberDevices x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MemberDevices._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MemberDevices x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("team_member_id", x.teamMemberId);
                if (x.webSessions != null) {
                    g.writeFieldName("web_sessions");
                    g.writeStartArray();
                    for (ActiveWebSession item: x.webSessions) {
                        if (item != null) {
                            ActiveWebSession._writer.write(item, g);
                        }
                    }
                    g.writeEndArray();
                }
                if (x.desktopClients != null) {
                    g.writeFieldName("desktop_clients");
                    g.writeStartArray();
                    for (DesktopClientSession item: x.desktopClients) {
                        if (item != null) {
                            DesktopClientSession._writer.write(item, g);
                        }
                    }
                    g.writeEndArray();
                }
                if (x.mobileClients != null) {
                    g.writeFieldName("mobile_clients");
                    g.writeStartArray();
                    for (MobileClientSession item: x.mobileClients) {
                        if (item != null) {
                            MobileClientSession._writer.write(item, g);
                        }
                    }
                    g.writeEndArray();
                }
            }
        };

        public static final JsonReader<MemberDevices> _reader = new JsonReader<MemberDevices>() {

            public final MemberDevices read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MemberDevices result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MemberDevices readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String teamMemberId = null;
                java.util.List<ActiveWebSession> webSessions = null;
                java.util.List<DesktopClientSession> desktopClients = null;
                java.util.List<MobileClientSession> mobileClients = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("web_sessions".equals(fieldName)) {
                        webSessions = JsonArrayReader.mk(ActiveWebSession._reader)
                            .readField(parser, "web_sessions", webSessions);
                    }
                    else if ("desktop_clients".equals(fieldName)) {
                        desktopClients = JsonArrayReader.mk(DesktopClientSession._reader)
                            .readField(parser, "desktop_clients", desktopClients);
                    }
                    else if ("mobile_clients".equals(fieldName)) {
                        mobileClients = JsonArrayReader.mk(MobileClientSession._reader)
                            .readField(parser, "mobile_clients", mobileClients);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                return new MemberDevices(teamMemberId, webSessions, desktopClients, mobileClients);
            }
        };

        public String toString() {
            return "MemberDevices." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MemberDevices." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MemberDevices fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class ListTeamDevicesResult {
        // struct ListTeamDevicesResult
        /**
         * The devices of each member of the team
         */
        public final java.util.List<MemberDevices> devices;
        /**
         * If true, then there are more devices available. Pass the cursor to
         * {@link DbxTeam#devicesListTeamDevicesBuilder} to retrieve the rest.
         */
        public final boolean hasMore;
        /**
         * Pass the cursor into {@link DbxTeam#devicesListTeamDevicesBuilder} to
         * receive the next sub list of team's devices.
         */
        public final String cursor;

        /**
         *
         * @param devices  The devices of each member of the team. {@code
         *     devices} must not contain a {@code null} item and not be {@code
         *     null}.
         * @param hasMore  If true, then there are more devices available. Pass
         *     the cursor to {@link DbxTeam#devicesListTeamDevicesBuilder} to
         *     retrieve the rest.
         * @param cursor  Pass the cursor into {@link
         *     DbxTeam#devicesListTeamDevicesBuilder} to receive the next sub
         *     list of team's devices.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ListTeamDevicesResult(java.util.List<MemberDevices> devices, boolean hasMore, String cursor) {
            this.devices = devices;
            if (devices == null) {
                throw new IllegalArgumentException("Required value for 'devices' is null");
            }
            for (MemberDevices x : devices) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'devices' is null");
                }
            }
            this.hasMore = hasMore;
            this.cursor = cursor;
        }

        static final JsonWriter<ListTeamDevicesResult> _writer = new JsonWriter<ListTeamDevicesResult>()
        {
            public final void write(ListTeamDevicesResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListTeamDevicesResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListTeamDevicesResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("devices");
                g.writeStartArray();
                for (MemberDevices item: x.devices) {
                    if (item != null) {
                        MemberDevices._writer.write(item, g);
                    }
                }
                g.writeEndArray();
                g.writeBooleanField("has_more", x.hasMore);
                if (x.cursor != null) {
                    g.writeFieldName("cursor");
                    g.writeString(x.cursor);
                }
            }
        };

        public static final JsonReader<ListTeamDevicesResult> _reader = new JsonReader<ListTeamDevicesResult>() {

            public final ListTeamDevicesResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListTeamDevicesResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListTeamDevicesResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<MemberDevices> devices = null;
                Boolean hasMore = null;
                String cursor = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("devices".equals(fieldName)) {
                        devices = JsonArrayReader.mk(MemberDevices._reader)
                            .readField(parser, "devices", devices);
                    }
                    else if ("has_more".equals(fieldName)) {
                        hasMore = JsonReader.BooleanReader
                            .readField(parser, "has_more", hasMore);
                    }
                    else if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (devices == null) {
                    throw new JsonReadException("Required field \"devices\" is missing.", parser.getTokenLocation());
                }
                if (hasMore == null) {
                    throw new JsonReadException("Required field \"has_more\" is missing.", parser.getTokenLocation());
                }
                return new ListTeamDevicesResult(devices, hasMore, cursor);
            }
        };

        public String toString() {
            return "ListTeamDevicesResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListTeamDevicesResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListTeamDevicesResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class ListTeamDevicesError {
        // union ListTeamDevicesError

        /**
         * The discriminating tag type for {@link ListTeamDevicesError}.
         */
        public enum Tag {
            /**
             * Indicates that the cursor has been invalidated. Call {@link
             * DbxTeam#devicesListTeamDevicesBuilder} again with an empty cursor
             * to obtain a new cursor.
             */
            RESET,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code ListTeamDevicesError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Indicates that the cursor has been invalidated. Call {@link
         * DbxTeam#devicesListTeamDevicesBuilder} again with an empty cursor to
         * obtain a new cursor.
         */
        private static final ListTeamDevicesError RESET_INSTANCE = new ListTeamDevicesError(Tag.RESET);

        /**
         * Returns an instance of {@code ListTeamDevicesError} that has its tag
         * set to {@link Tag#RESET}.
         *
         * <p> Indicates that the cursor has been invalidated. Call {@link
         * DbxTeam#devicesListTeamDevicesBuilder} again with an empty cursor to
         * obtain a new cursor. </p>
         *
         * @return Instance of {@code ListTeamDevicesError} with its tag set to
         *     {@link Tag#RESET}.
         */
        public static ListTeamDevicesError reset() {
            return ListTeamDevicesError.RESET_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#RESET},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#RESET},
         *     {@code false} otherwise.
         */
        public boolean isReset() {
            return this.tag == Tag.RESET;
        }

        /**
         * An unspecified error.
         */
        private static final ListTeamDevicesError OTHER_INSTANCE = new ListTeamDevicesError(Tag.OTHER);

        /**
         * Returns an instance of {@code ListTeamDevicesError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code ListTeamDevicesError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static ListTeamDevicesError other() {
            return ListTeamDevicesError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private ListTeamDevicesError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case RESET:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<ListTeamDevicesError> _writer = new JsonWriter<ListTeamDevicesError>()
        {
            public final void write(ListTeamDevicesError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case RESET:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("reset");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<ListTeamDevicesError> _reader = new JsonReader<ListTeamDevicesError>()
        {
            public final ListTeamDevicesError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return ListTeamDevicesError.other(); }
                    switch (tag) {
                        case RESET: return ListTeamDevicesError.reset();
                        case OTHER: return ListTeamDevicesError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                ListTeamDevicesError value = null;
                if (tag != null) {
                    switch (tag) {
                        case RESET: {
                            value = ListTeamDevicesError.reset();
                            break;
                        }
                        case OTHER: {
                            value = ListTeamDevicesError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return ListTeamDevicesError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("reset", Tag.RESET);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "ListTeamDevicesError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "ListTeamDevicesError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static ListTeamDevicesError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class DeviceSessionArg {
        // struct DeviceSessionArg
        /**
         * The session id
         */
        public final String sessionId;
        /**
         * The unique id of the member owning the device
         */
        public final String teamMemberId;

        /**
         *
         * @param sessionId  The session id. {@code sessionId} must not be
         *     {@code null}.
         * @param teamMemberId  The unique id of the member owning the device.
         *     {@code teamMemberId} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public DeviceSessionArg(String sessionId, String teamMemberId) {
            this.sessionId = sessionId;
            if (sessionId == null) {
                throw new IllegalArgumentException("Required value for 'sessionId' is null");
            }
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
        }

        static final JsonWriter<DeviceSessionArg> _writer = new JsonWriter<DeviceSessionArg>()
        {
            public final void write(DeviceSessionArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DeviceSessionArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(DeviceSessionArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("session_id", x.sessionId);
                g.writeStringField("team_member_id", x.teamMemberId);
            }
        };

        public static final JsonReader<DeviceSessionArg> _reader = new JsonReader<DeviceSessionArg>() {

            public final DeviceSessionArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                DeviceSessionArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final DeviceSessionArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String sessionId = null;
                String teamMemberId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("session_id".equals(fieldName)) {
                        sessionId = JsonReader.StringReader
                            .readField(parser, "session_id", sessionId);
                    }
                    else if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sessionId == null) {
                    throw new JsonReadException("Required field \"session_id\" is missing.", parser.getTokenLocation());
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                return new DeviceSessionArg(sessionId, teamMemberId);
            }
        };

        public String toString() {
            return "DeviceSessionArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "DeviceSessionArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static DeviceSessionArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeDesktopClientArg extends DeviceSessionArg  {
        // struct RevokeDesktopClientArg
        /**
         * Whether to delete all files of the account (this is possible only if
         * supported by the desktop client and  will be made the next time the
         * client access the account)
         */
        public final boolean deleteOnUnlink;

        /**
         *
         * @param sessionId  The session id. {@code sessionId} must not be
         *     {@code null}.
         * @param teamMemberId  The unique id of the member owning the device.
         *     {@code teamMemberId} must not be {@code null}.
         * @param deleteOnUnlink  Whether to delete all files of the account
         *     (this is possible only if supported by the desktop client and
         *     will be made the next time the client access the account).
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public RevokeDesktopClientArg(String sessionId, String teamMemberId, Boolean deleteOnUnlink) {
            super(sessionId, teamMemberId);
            if (deleteOnUnlink != null) {
                this.deleteOnUnlink = deleteOnUnlink.booleanValue();
            }
            else {
                this.deleteOnUnlink = false;
            }
        }

        static final JsonWriter<RevokeDesktopClientArg> _writer = new JsonWriter<RevokeDesktopClientArg>()
        {
            public final void write(RevokeDesktopClientArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DeviceSessionArg._writer.writeFields(x, g);
                RevokeDesktopClientArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeDesktopClientArg x, JsonGenerator g)
             throws IOException
            {
                g.writeBooleanField("delete_on_unlink", x.deleteOnUnlink);
            }
        };

        public static final JsonReader<RevokeDesktopClientArg> _reader = new JsonReader<RevokeDesktopClientArg>() {

            public final RevokeDesktopClientArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeDesktopClientArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeDesktopClientArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String sessionId = null;
                String teamMemberId = null;
                Boolean deleteOnUnlink = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("session_id".equals(fieldName)) {
                        sessionId = JsonReader.StringReader
                            .readField(parser, "session_id", sessionId);
                    }
                    else if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("delete_on_unlink".equals(fieldName)) {
                        deleteOnUnlink = JsonReader.BooleanReader
                            .readField(parser, "delete_on_unlink", deleteOnUnlink);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (sessionId == null) {
                    throw new JsonReadException("Required field \"session_id\" is missing.", parser.getTokenLocation());
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                return new RevokeDesktopClientArg(sessionId, teamMemberId, deleteOnUnlink);
            }
        };

        public String toString() {
            return "RevokeDesktopClientArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeDesktopClientArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeDesktopClientArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class RevokeDeviceSessionArg {
        // union RevokeDeviceSessionArg

        /**
         * The discriminating tag type for {@link RevokeDeviceSessionArg}.
         */
        public enum Tag {
            /**
             * End an active session
             */
            WEB_SESSION,  // DeviceSessionArg
            /**
             * Unlink a linked desktop device
             */
            DESKTOP_CLIENT,  // RevokeDesktopClientArg
            /**
             * Unlink a linked mobile device
             */
            MOBILE_CLIENT  // DeviceSessionArg
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code RevokeDeviceSessionArg}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final DeviceSessionArg webSessionValue;

        private RevokeDeviceSessionArg(Tag tag, DeviceSessionArg value) {
            this.tag = tag;
            this.webSessionValue = value;
            this.desktopClientValue = null;
            validate();
        }

        /**
         * End an active session
         *
         * <p> This instance must be tagged as {@link Tag#WEB_SESSION}. </p>
         *
         * @return The {@link DeviceSessionArg} value associated with this
         *     instance if {@link #isWebSession} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isWebSession} is {@code
         *     false}.
         */
        public DeviceSessionArg getWebSessionValue() {
            if (this.tag != Tag.WEB_SESSION) {
                throw new IllegalStateException("getWebSessionValue() requires tag==WEB_SESSION, actual tag==" + tag);
            }
            return webSessionValue;
        }

        /**
         * Returns an instance of {@code RevokeDeviceSessionArg} that has its
         * tag set to {@link Tag#WEB_SESSION}.
         *
         * <p> End an active session </p>
         *
         * @param value  {@link DeviceSessionArg} value to assign to this
         *     instance.
         *
         * @return Instance of {@code RevokeDeviceSessionArg} with its tag set
         *     to {@link Tag#WEB_SESSION}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static RevokeDeviceSessionArg webSession(DeviceSessionArg value) {
            return new RevokeDeviceSessionArg(Tag.WEB_SESSION, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#WEB_SESSION}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#WEB_SESSION}, {@code false} otherwise.
         */
        public boolean isWebSession() {
            return this.tag == Tag.WEB_SESSION;
        }

        private final RevokeDesktopClientArg desktopClientValue;

        private RevokeDeviceSessionArg(Tag tag, RevokeDesktopClientArg value) {
            this.tag = tag;
            this.webSessionValue = null;
            this.desktopClientValue = value;
            validate();
        }

        /**
         * Unlink a linked desktop device
         *
         * <p> This instance must be tagged as {@link Tag#DESKTOP_CLIENT}. </p>
         *
         * @return The {@link RevokeDesktopClientArg} value associated with this
         *     instance if {@link #isDesktopClient} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isDesktopClient} is {@code
         *     false}.
         */
        public RevokeDesktopClientArg getDesktopClientValue() {
            if (this.tag != Tag.DESKTOP_CLIENT) {
                throw new IllegalStateException("getDesktopClientValue() requires tag==DESKTOP_CLIENT, actual tag==" + tag);
            }
            return desktopClientValue;
        }

        /**
         * Returns an instance of {@code RevokeDeviceSessionArg} that has its
         * tag set to {@link Tag#DESKTOP_CLIENT}.
         *
         * <p> Unlink a linked desktop device </p>
         *
         * @param value  {@link RevokeDesktopClientArg} value to assign to this
         *     instance.
         *
         * @return Instance of {@code RevokeDeviceSessionArg} with its tag set
         *     to {@link Tag#DESKTOP_CLIENT}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static RevokeDeviceSessionArg desktopClient(RevokeDesktopClientArg value) {
            return new RevokeDeviceSessionArg(Tag.DESKTOP_CLIENT, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#DESKTOP_CLIENT}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#DESKTOP_CLIENT}, {@code false} otherwise.
         */
        public boolean isDesktopClient() {
            return this.tag == Tag.DESKTOP_CLIENT;
        }

        // Reusing webSessionValue for mobileClient

        /**
         * Unlink a linked mobile device
         *
         * <p> This instance must be tagged as {@link Tag#MOBILE_CLIENT}. </p>
         *
         * @return The {@link DeviceSessionArg} value associated with this
         *     instance if {@link #isMobileClient} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isMobileClient} is {@code
         *     false}.
         */
        public DeviceSessionArg getMobileClientValue() {
            if (this.tag != Tag.MOBILE_CLIENT) {
                throw new IllegalStateException("getMobileClientValue() requires tag==MOBILE_CLIENT, actual tag==" + tag);
            }
            return webSessionValue;
        }

        /**
         * Returns an instance of {@code RevokeDeviceSessionArg} that has its
         * tag set to {@link Tag#MOBILE_CLIENT}.
         *
         * <p> Unlink a linked mobile device </p>
         *
         * @param value  {@link DeviceSessionArg} value to assign to this
         *     instance.
         *
         * @return Instance of {@code RevokeDeviceSessionArg} with its tag set
         *     to {@link Tag#MOBILE_CLIENT}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static RevokeDeviceSessionArg mobileClient(DeviceSessionArg value) {
            return new RevokeDeviceSessionArg(Tag.MOBILE_CLIENT, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MOBILE_CLIENT}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MOBILE_CLIENT}, {@code false} otherwise.
         */
        public boolean isMobileClient() {
            return this.tag == Tag.MOBILE_CLIENT;
        }


        private final void validate() {
            switch (this.tag) {
                case WEB_SESSION:
                    if (this.webSessionValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case DESKTOP_CLIENT:
                    if (this.desktopClientValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case MOBILE_CLIENT:
                    if (this.webSessionValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
            }
        }

        static final JsonWriter<RevokeDeviceSessionArg> _writer = new JsonWriter<RevokeDeviceSessionArg>()
        {
            public final void write(RevokeDeviceSessionArg x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case WEB_SESSION:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("web_session");
                        DeviceSessionArg._writer.writeFields(x.webSessionValue, g);
                        g.writeEndObject();
                        break;
                    case DESKTOP_CLIENT:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("desktop_client");
                        RevokeDesktopClientArg._writer.writeFields(x.desktopClientValue, g);
                        g.writeEndObject();
                        break;
                    case MOBILE_CLIENT:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("mobile_client");
                        DeviceSessionArg._writer.writeFields(x.webSessionValue, g);
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<RevokeDeviceSessionArg> _reader = new JsonReader<RevokeDeviceSessionArg>()
        {
            public final RevokeDeviceSessionArg read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                RevokeDeviceSessionArg value = null;
                if (tag != null) {
                    switch (tag) {
                        case WEB_SESSION: {
                            DeviceSessionArg v = null;
                            v = DeviceSessionArg._reader.readFields(parser);
                            value = RevokeDeviceSessionArg.webSession(v);
                            break;
                        }
                        case DESKTOP_CLIENT: {
                            RevokeDesktopClientArg v = null;
                            v = RevokeDesktopClientArg._reader.readFields(parser);
                            value = RevokeDeviceSessionArg.desktopClient(v);
                            break;
                        }
                        case MOBILE_CLIENT: {
                            DeviceSessionArg v = null;
                            v = DeviceSessionArg._reader.readFields(parser);
                            value = RevokeDeviceSessionArg.mobileClient(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("web_session", Tag.WEB_SESSION);
            _values.put("desktop_client", Tag.DESKTOP_CLIENT);
            _values.put("mobile_client", Tag.MOBILE_CLIENT);
        }

        public String toString() {
            return "RevokeDeviceSessionArg." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "RevokeDeviceSessionArg." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static RevokeDeviceSessionArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class RevokeDeviceSessionError {
        // union RevokeDeviceSessionError

        /**
         * The discriminating tag type for {@link RevokeDeviceSessionError}.
         */
        public enum Tag {
            /**
             * Device session not found.
             */
            DEVICE_SESSION_NOT_FOUND,
            /**
             * Member not found.
             */
            MEMBER_NOT_FOUND,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code RevokeDeviceSessionError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Device session not found.
         */
        private static final RevokeDeviceSessionError DEVICE_SESSION_NOT_FOUND_INSTANCE = new RevokeDeviceSessionError(Tag.DEVICE_SESSION_NOT_FOUND);

        /**
         * Returns an instance of {@code RevokeDeviceSessionError} that has its
         * tag set to {@link Tag#DEVICE_SESSION_NOT_FOUND}.
         *
         * <p> Device session not found. </p>
         *
         * @return Instance of {@code RevokeDeviceSessionError} with its tag set
         *     to {@link Tag#DEVICE_SESSION_NOT_FOUND}.
         */
        public static RevokeDeviceSessionError deviceSessionNotFound() {
            return RevokeDeviceSessionError.DEVICE_SESSION_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#DEVICE_SESSION_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#DEVICE_SESSION_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isDeviceSessionNotFound() {
            return this.tag == Tag.DEVICE_SESSION_NOT_FOUND;
        }

        /**
         * Member not found.
         */
        private static final RevokeDeviceSessionError MEMBER_NOT_FOUND_INSTANCE = new RevokeDeviceSessionError(Tag.MEMBER_NOT_FOUND);

        /**
         * Returns an instance of {@code RevokeDeviceSessionError} that has its
         * tag set to {@link Tag#MEMBER_NOT_FOUND}.
         *
         * <p> Member not found. </p>
         *
         * @return Instance of {@code RevokeDeviceSessionError} with its tag set
         *     to {@link Tag#MEMBER_NOT_FOUND}.
         */
        public static RevokeDeviceSessionError memberNotFound() {
            return RevokeDeviceSessionError.MEMBER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isMemberNotFound() {
            return this.tag == Tag.MEMBER_NOT_FOUND;
        }

        /**
         * An unspecified error.
         */
        private static final RevokeDeviceSessionError OTHER_INSTANCE = new RevokeDeviceSessionError(Tag.OTHER);

        /**
         * Returns an instance of {@code RevokeDeviceSessionError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code RevokeDeviceSessionError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static RevokeDeviceSessionError other() {
            return RevokeDeviceSessionError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private RevokeDeviceSessionError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case DEVICE_SESSION_NOT_FOUND:
                case MEMBER_NOT_FOUND:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<RevokeDeviceSessionError> _writer = new JsonWriter<RevokeDeviceSessionError>()
        {
            public final void write(RevokeDeviceSessionError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case DEVICE_SESSION_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("device_session_not_found");
                        g.writeEndObject();
                        break;
                    case MEMBER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<RevokeDeviceSessionError> _reader = new JsonReader<RevokeDeviceSessionError>()
        {
            public final RevokeDeviceSessionError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return RevokeDeviceSessionError.other(); }
                    switch (tag) {
                        case DEVICE_SESSION_NOT_FOUND: return RevokeDeviceSessionError.deviceSessionNotFound();
                        case MEMBER_NOT_FOUND: return RevokeDeviceSessionError.memberNotFound();
                        case OTHER: return RevokeDeviceSessionError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                RevokeDeviceSessionError value = null;
                if (tag != null) {
                    switch (tag) {
                        case DEVICE_SESSION_NOT_FOUND: {
                            value = RevokeDeviceSessionError.deviceSessionNotFound();
                            break;
                        }
                        case MEMBER_NOT_FOUND: {
                            value = RevokeDeviceSessionError.memberNotFound();
                            break;
                        }
                        case OTHER: {
                            value = RevokeDeviceSessionError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return RevokeDeviceSessionError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("device_session_not_found", Tag.DEVICE_SESSION_NOT_FOUND);
            _values.put("member_not_found", Tag.MEMBER_NOT_FOUND);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "RevokeDeviceSessionError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "RevokeDeviceSessionError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static RevokeDeviceSessionError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeDeviceSessionBatchArg {
        // struct RevokeDeviceSessionBatchArg
        public final java.util.List<RevokeDeviceSessionArg> revokeDevices;

        /**
         *
         * @param revokeDevices  . {@code revokeDevices} must not contain a
         *     {@code null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public RevokeDeviceSessionBatchArg(java.util.List<RevokeDeviceSessionArg> revokeDevices) {
            this.revokeDevices = revokeDevices;
            if (revokeDevices == null) {
                throw new IllegalArgumentException("Required value for 'revokeDevices' is null");
            }
            for (RevokeDeviceSessionArg x : revokeDevices) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'revokeDevices' is null");
                }
            }
        }

        static final JsonWriter<RevokeDeviceSessionBatchArg> _writer = new JsonWriter<RevokeDeviceSessionBatchArg>()
        {
            public final void write(RevokeDeviceSessionBatchArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                RevokeDeviceSessionBatchArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeDeviceSessionBatchArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("revoke_devices");
                g.writeStartArray();
                for (RevokeDeviceSessionArg item: x.revokeDevices) {
                    if (item != null) {
                        RevokeDeviceSessionArg._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<RevokeDeviceSessionBatchArg> _reader = new JsonReader<RevokeDeviceSessionBatchArg>() {

            public final RevokeDeviceSessionBatchArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeDeviceSessionBatchArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeDeviceSessionBatchArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<RevokeDeviceSessionArg> revokeDevices = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("revoke_devices".equals(fieldName)) {
                        revokeDevices = JsonArrayReader.mk(RevokeDeviceSessionArg._reader)
                            .readField(parser, "revoke_devices", revokeDevices);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (revokeDevices == null) {
                    throw new JsonReadException("Required field \"revoke_devices\" is missing.", parser.getTokenLocation());
                }
                return new RevokeDeviceSessionBatchArg(revokeDevices);
            }
        };

        public String toString() {
            return "RevokeDeviceSessionBatchArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeDeviceSessionBatchArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeDeviceSessionBatchArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeDeviceSessionStatus {
        // struct RevokeDeviceSessionStatus
        /**
         * Result of the revoking request
         */
        public final boolean success;
        /**
         * The error cause in case of a failure
         */
        public final RevokeDeviceSessionError errorType;

        /**
         *
         * @param success  Result of the revoking request.
         * @param errorType  The error cause in case of a failure.
         */
        public RevokeDeviceSessionStatus(boolean success, RevokeDeviceSessionError errorType) {
            this.success = success;
            this.errorType = errorType;
        }

        static final JsonWriter<RevokeDeviceSessionStatus> _writer = new JsonWriter<RevokeDeviceSessionStatus>()
        {
            public final void write(RevokeDeviceSessionStatus x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                RevokeDeviceSessionStatus._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeDeviceSessionStatus x, JsonGenerator g)
             throws IOException
            {
                g.writeBooleanField("success", x.success);
                if (x.errorType != null) {
                    g.writeFieldName("error_type");
                    RevokeDeviceSessionError._writer.write(x.errorType, g);
                }
            }
        };

        public static final JsonReader<RevokeDeviceSessionStatus> _reader = new JsonReader<RevokeDeviceSessionStatus>() {

            public final RevokeDeviceSessionStatus read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeDeviceSessionStatus result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeDeviceSessionStatus readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                Boolean success = null;
                RevokeDeviceSessionError errorType = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("success".equals(fieldName)) {
                        success = JsonReader.BooleanReader
                            .readField(parser, "success", success);
                    }
                    else if ("error_type".equals(fieldName)) {
                        errorType = RevokeDeviceSessionError._reader
                            .readField(parser, "error_type", errorType);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (success == null) {
                    throw new JsonReadException("Required field \"success\" is missing.", parser.getTokenLocation());
                }
                return new RevokeDeviceSessionStatus(success, errorType);
            }
        };

        public String toString() {
            return "RevokeDeviceSessionStatus." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeDeviceSessionStatus." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeDeviceSessionStatus fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeDeviceSessionBatchResult {
        // struct RevokeDeviceSessionBatchResult
        public final java.util.List<RevokeDeviceSessionStatus> revokeDevicesStatus;

        /**
         *
         * @param revokeDevicesStatus  . {@code revokeDevicesStatus} must not
         *     contain a {@code null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public RevokeDeviceSessionBatchResult(java.util.List<RevokeDeviceSessionStatus> revokeDevicesStatus) {
            this.revokeDevicesStatus = revokeDevicesStatus;
            if (revokeDevicesStatus == null) {
                throw new IllegalArgumentException("Required value for 'revokeDevicesStatus' is null");
            }
            for (RevokeDeviceSessionStatus x : revokeDevicesStatus) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'revokeDevicesStatus' is null");
                }
            }
        }

        static final JsonWriter<RevokeDeviceSessionBatchResult> _writer = new JsonWriter<RevokeDeviceSessionBatchResult>()
        {
            public final void write(RevokeDeviceSessionBatchResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                RevokeDeviceSessionBatchResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeDeviceSessionBatchResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("revoke_devices_status");
                g.writeStartArray();
                for (RevokeDeviceSessionStatus item: x.revokeDevicesStatus) {
                    if (item != null) {
                        RevokeDeviceSessionStatus._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<RevokeDeviceSessionBatchResult> _reader = new JsonReader<RevokeDeviceSessionBatchResult>() {

            public final RevokeDeviceSessionBatchResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeDeviceSessionBatchResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeDeviceSessionBatchResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<RevokeDeviceSessionStatus> revokeDevicesStatus = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("revoke_devices_status".equals(fieldName)) {
                        revokeDevicesStatus = JsonArrayReader.mk(RevokeDeviceSessionStatus._reader)
                            .readField(parser, "revoke_devices_status", revokeDevicesStatus);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (revokeDevicesStatus == null) {
                    throw new JsonReadException("Required field \"revoke_devices_status\" is missing.", parser.getTokenLocation());
                }
                return new RevokeDeviceSessionBatchResult(revokeDevicesStatus);
            }
        };

        public String toString() {
            return "RevokeDeviceSessionBatchResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeDeviceSessionBatchResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeDeviceSessionBatchResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class RevokeDeviceSessionBatchError {
        // union RevokeDeviceSessionBatchError

        /**
         * The discriminating tag type for {@link
         * RevokeDeviceSessionBatchError}.
         */
        public enum Tag {
            /**
             * An unspecified error.
             */
            UNSPECIFIED  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code RevokeDeviceSessionBatchError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * An unspecified error.
         */
        private static final RevokeDeviceSessionBatchError UNSPECIFIED_INSTANCE = new RevokeDeviceSessionBatchError(Tag.UNSPECIFIED);

        /**
         * Returns an instance of {@code RevokeDeviceSessionBatchError} that has
         * its tag set to {@link Tag#UNSPECIFIED}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code RevokeDeviceSessionBatchError} with its
         *     tag set to {@link Tag#UNSPECIFIED}.
         */
        public static RevokeDeviceSessionBatchError unspecified() {
            return RevokeDeviceSessionBatchError.UNSPECIFIED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#UNSPECIFIED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#UNSPECIFIED}, {@code false} otherwise.
         */
        public boolean isUnspecified() {
            return this.tag == Tag.UNSPECIFIED;
        }

        private RevokeDeviceSessionBatchError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case UNSPECIFIED:
                    break;
            }
        }

        static final JsonWriter<RevokeDeviceSessionBatchError> _writer = new JsonWriter<RevokeDeviceSessionBatchError>()
        {
            public final void write(RevokeDeviceSessionBatchError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case UNSPECIFIED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("unspecified");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<RevokeDeviceSessionBatchError> _reader = new JsonReader<RevokeDeviceSessionBatchError>()
        {
            public final RevokeDeviceSessionBatchError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return RevokeDeviceSessionBatchError.unspecified(); }
                    switch (tag) {
                        case UNSPECIFIED: return RevokeDeviceSessionBatchError.unspecified();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                RevokeDeviceSessionBatchError value = null;
                if (tag != null) {
                    switch (tag) {
                        case UNSPECIFIED: {
                            value = RevokeDeviceSessionBatchError.unspecified();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return RevokeDeviceSessionBatchError.unspecified(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("unspecified", Tag.UNSPECIFIED);
        }

        public String toString() {
            return "RevokeDeviceSessionBatchError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "RevokeDeviceSessionBatchError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static RevokeDeviceSessionBatchError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Role of a user in group.
     */
    public static final class GroupAccessType {
        // union GroupAccessType

        /**
         * The discriminating tag type for {@link GroupAccessType}.
         */
        public enum Tag {
            /**
             * User is a member of the group, but has no special permissions.
             */
            MEMBER,
            /**
             * A group owner can rename the group, and add/remove members.
             */
            OWNER
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupAccessType}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * User is a member of the group, but has no special permissions.
         */
        private static final GroupAccessType MEMBER_INSTANCE = new GroupAccessType(Tag.MEMBER);

        /**
         * Returns an instance of {@code GroupAccessType} that has its tag set
         * to {@link Tag#MEMBER}.
         *
         * <p> User is a member of the group, but has no special permissions.
         * </p>
         *
         * @return Instance of {@code GroupAccessType} with its tag set to
         *     {@link Tag#MEMBER}.
         */
        public static GroupAccessType member() {
            return GroupAccessType.MEMBER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#MEMBER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER}, {@code false} otherwise.
         */
        public boolean isMember() {
            return this.tag == Tag.MEMBER;
        }

        /**
         * A group owner can rename the group, and add/remove members.
         */
        private static final GroupAccessType OWNER_INSTANCE = new GroupAccessType(Tag.OWNER);

        /**
         * Returns an instance of {@code GroupAccessType} that has its tag set
         * to {@link Tag#OWNER}.
         *
         * <p> A group owner can rename the group, and add/remove members. </p>
         *
         * @return Instance of {@code GroupAccessType} with its tag set to
         *     {@link Tag#OWNER}.
         */
        public static GroupAccessType owner() {
            return GroupAccessType.OWNER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OWNER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OWNER},
         *     {@code false} otherwise.
         */
        public boolean isOwner() {
            return this.tag == Tag.OWNER;
        }

        private GroupAccessType(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case MEMBER:
                case OWNER:
                    break;
            }
        }

        static final JsonWriter<GroupAccessType> _writer = new JsonWriter<GroupAccessType>()
        {
            public final void write(GroupAccessType x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case MEMBER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member");
                        g.writeEndObject();
                        break;
                    case OWNER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("owner");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupAccessType> _reader = new JsonReader<GroupAccessType>()
        {
            public final GroupAccessType read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case MEMBER: return GroupAccessType.member();
                        case OWNER: return GroupAccessType.owner();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupAccessType value = null;
                if (tag != null) {
                    switch (tag) {
                        case MEMBER: {
                            value = GroupAccessType.member();
                            break;
                        }
                        case OWNER: {
                            value = GroupAccessType.owner();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("member", Tag.MEMBER);
            _values.put("owner", Tag.OWNER);
        }

        public String toString() {
            return "GroupAccessType." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupAccessType." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupAccessType fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Argument for selecting a single group, either by group_id or by external
     * group ID.
     */
    public static final class GroupSelector {
        // union GroupSelector

        /**
         * The discriminating tag type for {@link GroupSelector}.
         */
        public enum Tag {
            /**
             * Group ID.
             */
            GROUP_ID,  // String
            /**
             * External ID of the group.
             */
            GROUP_EXTERNAL_ID  // String
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupSelector}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final String groupIdValue;

        private GroupSelector(Tag tag, String value) {
            this.tag = tag;
            this.groupIdValue = value;
            validate();
        }

        /**
         * Group ID.
         *
         * <p> This instance must be tagged as {@link Tag#GROUP_ID}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isGroupId} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isGroupId} is {@code
         *     false}.
         */
        public String getGroupIdValue() {
            if (this.tag != Tag.GROUP_ID) {
                throw new IllegalStateException("getGroupIdValue() requires tag==GROUP_ID, actual tag==" + tag);
            }
            return groupIdValue;
        }

        /**
         * Returns an instance of {@code GroupSelector} that has its tag set to
         * {@link Tag#GROUP_ID}.
         *
         * <p> Group ID. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code GroupSelector} with its tag set to {@link
         *     Tag#GROUP_ID}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static GroupSelector groupId(String value) {
            return new GroupSelector(Tag.GROUP_ID, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_ID}, {@code false} otherwise.
         */
        public boolean isGroupId() {
            return this.tag == Tag.GROUP_ID;
        }

        // Reusing groupIdValue for groupExternalId

        /**
         * External ID of the group.
         *
         * <p> This instance must be tagged as {@link Tag#GROUP_EXTERNAL_ID}.
         * </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isGroupExternalId} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isGroupExternalId} is
         *     {@code false}.
         */
        public String getGroupExternalIdValue() {
            if (this.tag != Tag.GROUP_EXTERNAL_ID) {
                throw new IllegalStateException("getGroupExternalIdValue() requires tag==GROUP_EXTERNAL_ID, actual tag==" + tag);
            }
            return groupIdValue;
        }

        /**
         * Returns an instance of {@code GroupSelector} that has its tag set to
         * {@link Tag#GROUP_EXTERNAL_ID}.
         *
         * <p> External ID of the group. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code GroupSelector} with its tag set to {@link
         *     Tag#GROUP_EXTERNAL_ID}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static GroupSelector groupExternalId(String value) {
            return new GroupSelector(Tag.GROUP_EXTERNAL_ID, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_EXTERNAL_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_EXTERNAL_ID}, {@code false} otherwise.
         */
        public boolean isGroupExternalId() {
            return this.tag == Tag.GROUP_EXTERNAL_ID;
        }


        private final void validate() {
            switch (this.tag) {
                case GROUP_ID:
                    if (this.groupIdValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case GROUP_EXTERNAL_ID:
                    if (this.groupIdValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
            }
        }

        static final JsonWriter<GroupSelector> _writer = new JsonWriter<GroupSelector>()
        {
            public final void write(GroupSelector x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_id");
                        g.writeStringField("group_id", x.groupIdValue);
                        g.writeEndObject();
                        break;
                    case GROUP_EXTERNAL_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_external_id");
                        g.writeStringField("group_external_id", x.groupIdValue);
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupSelector> _reader = new JsonReader<GroupSelector>()
        {
            public final GroupSelector read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupSelector value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_ID: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "group_id", v);
                            value = GroupSelector.groupId(v);
                            break;
                        }
                        case GROUP_EXTERNAL_ID: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "group_external_id", v);
                            value = GroupSelector.groupExternalId(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("group_id", Tag.GROUP_ID);
            _values.put("group_external_id", Tag.GROUP_EXTERNAL_ID);
        }

        public String toString() {
            return "GroupSelector." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupSelector." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupSelector fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error that can be raised when {@link GroupSelector}is used.
     */
    public static final class GroupSelectorError {
        // union GroupSelectorError

        /**
         * The discriminating tag type for {@link GroupSelectorError}.
         */
        public enum Tag {
            /**
             * No matching group found. No groups match the specified group ID.
             */
            GROUP_NOT_FOUND,
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupSelectorError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching group found. No groups match the specified group ID.
         */
        private static final GroupSelectorError GROUP_NOT_FOUND_INSTANCE = new GroupSelectorError(Tag.GROUP_NOT_FOUND);

        /**
         * Returns an instance of {@code GroupSelectorError} that has its tag
         * set to {@link Tag#GROUP_NOT_FOUND}.
         *
         * <p> No matching group found. No groups match the specified group ID.
         * </p>
         *
         * @return Instance of {@code GroupSelectorError} with its tag set to
         *     {@link Tag#GROUP_NOT_FOUND}.
         */
        public static GroupSelectorError groupNotFound() {
            return GroupSelectorError.GROUP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isGroupNotFound() {
            return this.tag == Tag.GROUP_NOT_FOUND;
        }

        private static final GroupSelectorError OTHER_INSTANCE = new GroupSelectorError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupSelectorError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupSelectorError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static GroupSelectorError other() {
            return GroupSelectorError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private GroupSelectorError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_FOUND:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<GroupSelectorError> _writer = new JsonWriter<GroupSelectorError>()
        {
            public final void write(GroupSelectorError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupSelectorError> _reader = new JsonReader<GroupSelectorError>()
        {
            public final GroupSelectorError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return GroupSelectorError.other(); }
                    switch (tag) {
                        case GROUP_NOT_FOUND: return GroupSelectorError.groupNotFound();
                        case OTHER: return GroupSelectorError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupSelectorError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_FOUND: {
                            value = GroupSelectorError.groupNotFound();
                            break;
                        }
                        case OTHER: {
                            value = GroupSelectorError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return GroupSelectorError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("group_not_found", Tag.GROUP_NOT_FOUND);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "GroupSelectorError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupSelectorError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupSelectorError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Argument for selecting a list of groups, either by group_ids, or external
     * group IDs.
     */
    public static final class GroupsSelector {
        // union GroupsSelector

        /**
         * The discriminating tag type for {@link GroupsSelector}.
         */
        public enum Tag {
            /**
             * List of group IDs.
             */
            GROUP_IDS,  // List
            /**
             * List of external IDs of groups.
             */
            GROUP_EXTERNAL_IDS  // List
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupsSelector}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final java.util.List<String> groupIdsValue;

        private GroupsSelector(Tag tag, java.util.List<String> value) {
            this.tag = tag;
            this.groupIdsValue = value;
            validate();
        }

        /**
         * List of group IDs.
         *
         * <p> This instance must be tagged as {@link Tag#GROUP_IDS}. </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isGroupIds} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isGroupIds} is {@code
         *     false}.
         */
        public java.util.List<String> getGroupIdsValue() {
            if (this.tag != Tag.GROUP_IDS) {
                throw new IllegalStateException("getGroupIdsValue() requires tag==GROUP_IDS, actual tag==" + tag);
            }
            return groupIdsValue;
        }

        /**
         * Returns an instance of {@code GroupsSelector} that has its tag set to
         * {@link Tag#GROUP_IDS}.
         *
         * <p> List of group IDs. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code GroupsSelector} with its tag set to {@link
         *     Tag#GROUP_IDS}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static GroupsSelector groupIds(java.util.List<String> value) {
            return new GroupsSelector(Tag.GROUP_IDS, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_IDS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_IDS}, {@code false} otherwise.
         */
        public boolean isGroupIds() {
            return this.tag == Tag.GROUP_IDS;
        }

        // Reusing groupIdsValue for groupExternalIds

        /**
         * List of external IDs of groups.
         *
         * <p> This instance must be tagged as {@link Tag#GROUP_EXTERNAL_IDS}.
         * </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isGroupExternalIds} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isGroupExternalIds} is
         *     {@code false}.
         */
        public java.util.List<String> getGroupExternalIdsValue() {
            if (this.tag != Tag.GROUP_EXTERNAL_IDS) {
                throw new IllegalStateException("getGroupExternalIdsValue() requires tag==GROUP_EXTERNAL_IDS, actual tag==" + tag);
            }
            return groupIdsValue;
        }

        /**
         * Returns an instance of {@code GroupsSelector} that has its tag set to
         * {@link Tag#GROUP_EXTERNAL_IDS}.
         *
         * <p> List of external IDs of groups. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code GroupsSelector} with its tag set to {@link
         *     Tag#GROUP_EXTERNAL_IDS}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static GroupsSelector groupExternalIds(java.util.List<String> value) {
            return new GroupsSelector(Tag.GROUP_EXTERNAL_IDS, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_EXTERNAL_IDS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_EXTERNAL_IDS}, {@code false} otherwise.
         */
        public boolean isGroupExternalIds() {
            return this.tag == Tag.GROUP_EXTERNAL_IDS;
        }


        private final void validate() {
            switch (this.tag) {
                case GROUP_IDS:
                    if (this.groupIdsValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (String x : this.groupIdsValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
                case GROUP_EXTERNAL_IDS:
                    if (this.groupIdsValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (String x : this.groupIdsValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
            }
        }

        static final JsonWriter<GroupsSelector> _writer = new JsonWriter<GroupsSelector>()
        {
            public final void write(GroupsSelector x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_IDS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_ids");
                        g.writeFieldName("group_ids");
                        g.writeStartArray();
                        for (String item: x.groupIdsValue) {
                            if (item != null) {
                                g.writeString(item);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                    case GROUP_EXTERNAL_IDS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_external_ids");
                        g.writeFieldName("group_external_ids");
                        g.writeStartArray();
                        for (String item: x.groupIdsValue) {
                            if (item != null) {
                                g.writeString(item);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupsSelector> _reader = new JsonReader<GroupsSelector>()
        {
            public final GroupsSelector read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupsSelector value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_IDS: {
                            java.util.List<String> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(JsonReader.StringReader)
                                .readField(parser, "group_ids", v);
                            value = GroupsSelector.groupIds(v);
                            break;
                        }
                        case GROUP_EXTERNAL_IDS: {
                            java.util.List<String> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(JsonReader.StringReader)
                                .readField(parser, "group_external_ids", v);
                            value = GroupsSelector.groupExternalIds(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("group_ids", Tag.GROUP_IDS);
            _values.put("group_external_ids", Tag.GROUP_EXTERNAL_IDS);
        }

        public String toString() {
            return "GroupsSelector." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupsSelector." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupsSelector fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Argument for selecting a group and a single user.
     */
    public static class GroupMemberSelector {
        // struct GroupMemberSelector
        /**
         * Specify a group.
         */
        public final GroupSelector group;
        /**
         * Identity of a user that is a member of {@link
         * GroupMemberSelector#group}.
         */
        public final UserSelectorArg user;

        /**
         * Argument for selecting a group and a single user.
         *
         * @param group  Specify a group. {@code group} must not be {@code
         *     null}.
         * @param user  Identity of a user that is a member of {@code group}.
         *     {@code user} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupMemberSelector(GroupSelector group, UserSelectorArg user) {
            this.group = group;
            if (group == null) {
                throw new IllegalArgumentException("Required value for 'group' is null");
            }
            this.user = user;
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
        }

        static final JsonWriter<GroupMemberSelector> _writer = new JsonWriter<GroupMemberSelector>()
        {
            public final void write(GroupMemberSelector x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupMemberSelector._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupMemberSelector x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("group");
                GroupSelector._writer.write(x.group, g);
                g.writeFieldName("user");
                UserSelectorArg._writer.write(x.user, g);
            }
        };

        public static final JsonReader<GroupMemberSelector> _reader = new JsonReader<GroupMemberSelector>() {

            public final GroupMemberSelector read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupMemberSelector result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupMemberSelector readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupSelector group = null;
                UserSelectorArg user = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group".equals(fieldName)) {
                        group = GroupSelector._reader
                            .readField(parser, "group", group);
                    }
                    else if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (group == null) {
                    throw new JsonReadException("Required field \"group\" is missing.", parser.getTokenLocation());
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                return new GroupMemberSelector(group, user);
            }
        };

        public String toString() {
            return "GroupMemberSelector." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupMemberSelector." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupMemberSelector fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error that can be raised when {@link GroupMemberSelector} is used, and
     * the user is required to be a member of the specified group.
     */
    public static final class GroupMemberSelectorError {
        // union GroupMemberSelectorError

        /**
         * The discriminating tag type for {@link GroupMemberSelectorError}.
         */
        public enum Tag {
            /**
             * No matching group found. No groups match the specified group ID.
             */
            GROUP_NOT_FOUND,
            OTHER,
            /**
             * The specified user is not a member of this group.
             */
            MEMBER_NOT_IN_GROUP
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupMemberSelectorError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching group found. No groups match the specified group ID.
         */
        private static final GroupMemberSelectorError GROUP_NOT_FOUND_INSTANCE = new GroupMemberSelectorError(Tag.GROUP_NOT_FOUND);

        /**
         * Returns an instance of {@code GroupMemberSelectorError} that has its
         * tag set to {@link Tag#GROUP_NOT_FOUND}.
         *
         * <p> No matching group found. No groups match the specified group ID.
         * </p>
         *
         * @return Instance of {@code GroupMemberSelectorError} with its tag set
         *     to {@link Tag#GROUP_NOT_FOUND}.
         */
        public static GroupMemberSelectorError groupNotFound() {
            return GroupMemberSelectorError.GROUP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isGroupNotFound() {
            return this.tag == Tag.GROUP_NOT_FOUND;
        }

        private static final GroupMemberSelectorError OTHER_INSTANCE = new GroupMemberSelectorError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupMemberSelectorError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupMemberSelectorError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static GroupMemberSelectorError other() {
            return GroupMemberSelectorError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * The specified user is not a member of this group.
         */
        private static final GroupMemberSelectorError MEMBER_NOT_IN_GROUP_INSTANCE = new GroupMemberSelectorError(Tag.MEMBER_NOT_IN_GROUP);

        /**
         * Returns an instance of {@code GroupMemberSelectorError} that has its
         * tag set to {@link Tag#MEMBER_NOT_IN_GROUP}.
         *
         * <p> The specified user is not a member of this group. </p>
         *
         * @return Instance of {@code GroupMemberSelectorError} with its tag set
         *     to {@link Tag#MEMBER_NOT_IN_GROUP}.
         */
        public static GroupMemberSelectorError memberNotInGroup() {
            return GroupMemberSelectorError.MEMBER_NOT_IN_GROUP_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_NOT_IN_GROUP}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_NOT_IN_GROUP}, {@code false} otherwise.
         */
        public boolean isMemberNotInGroup() {
            return this.tag == Tag.MEMBER_NOT_IN_GROUP;
        }

        private GroupMemberSelectorError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_FOUND:
                case OTHER:
                case MEMBER_NOT_IN_GROUP:
                    break;
            }
        }

        static final JsonWriter<GroupMemberSelectorError> _writer = new JsonWriter<GroupMemberSelectorError>()
        {
            public final void write(GroupMemberSelectorError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case MEMBER_NOT_IN_GROUP:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_not_in_group");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupMemberSelectorError> _reader = new JsonReader<GroupMemberSelectorError>()
        {
            public final GroupMemberSelectorError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case GROUP_NOT_FOUND: return GroupMemberSelectorError.groupNotFound();
                        case OTHER: return GroupMemberSelectorError.other();
                        case MEMBER_NOT_IN_GROUP: return GroupMemberSelectorError.memberNotInGroup();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupMemberSelectorError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_FOUND: {
                            value = GroupMemberSelectorError.groupNotFound();
                            break;
                        }
                        case OTHER: {
                            value = GroupMemberSelectorError.other();
                            break;
                        }
                        case MEMBER_NOT_IN_GROUP: {
                            value = GroupMemberSelectorError.memberNotInGroup();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("member_not_in_group", Tag.MEMBER_NOT_IN_GROUP);
        }

        public String toString() {
            return "GroupMemberSelectorError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupMemberSelectorError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupMemberSelectorError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Argument for selecting a group and a list of users.
     */
    public static class GroupMembersSelector {
        // struct GroupMembersSelector
        /**
         * Specify a group.
         */
        public final GroupSelector group;
        /**
         * A list of users that are members of {@link
         * GroupMembersSelector#group}.
         */
        public final UsersSelectorArg users;

        /**
         * Argument for selecting a group and a list of users.
         *
         * @param group  Specify a group. {@code group} must not be {@code
         *     null}.
         * @param users  A list of users that are members of {@code group}.
         *     {@code users} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupMembersSelector(GroupSelector group, UsersSelectorArg users) {
            this.group = group;
            if (group == null) {
                throw new IllegalArgumentException("Required value for 'group' is null");
            }
            this.users = users;
            if (users == null) {
                throw new IllegalArgumentException("Required value for 'users' is null");
            }
        }

        static final JsonWriter<GroupMembersSelector> _writer = new JsonWriter<GroupMembersSelector>()
        {
            public final void write(GroupMembersSelector x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupMembersSelector._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupMembersSelector x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("group");
                GroupSelector._writer.write(x.group, g);
                g.writeFieldName("users");
                UsersSelectorArg._writer.write(x.users, g);
            }
        };

        public static final JsonReader<GroupMembersSelector> _reader = new JsonReader<GroupMembersSelector>() {

            public final GroupMembersSelector read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupMembersSelector result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupMembersSelector readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupSelector group = null;
                UsersSelectorArg users = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group".equals(fieldName)) {
                        group = GroupSelector._reader
                            .readField(parser, "group", group);
                    }
                    else if ("users".equals(fieldName)) {
                        users = UsersSelectorArg._reader
                            .readField(parser, "users", users);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (group == null) {
                    throw new JsonReadException("Required field \"group\" is missing.", parser.getTokenLocation());
                }
                if (users == null) {
                    throw new JsonReadException("Required field \"users\" is missing.", parser.getTokenLocation());
                }
                return new GroupMembersSelector(group, users);
            }
        };

        public String toString() {
            return "GroupMembersSelector." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupMembersSelector." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupMembersSelector fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error that can be raised when {@link GroupMembersSelector} is used, and
     * the users are required to be members of the specified group.
     */
    public static final class GroupMembersSelectorError {
        // union GroupMembersSelectorError

        /**
         * The discriminating tag type for {@link GroupMembersSelectorError}.
         */
        public enum Tag {
            /**
             * No matching group found. No groups match the specified group ID.
             */
            GROUP_NOT_FOUND,
            OTHER,
            /**
             * At least one of the specified users is not a member of the group.
             */
            MEMBER_NOT_IN_GROUP
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupMembersSelectorError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching group found. No groups match the specified group ID.
         */
        private static final GroupMembersSelectorError GROUP_NOT_FOUND_INSTANCE = new GroupMembersSelectorError(Tag.GROUP_NOT_FOUND);

        /**
         * Returns an instance of {@code GroupMembersSelectorError} that has its
         * tag set to {@link Tag#GROUP_NOT_FOUND}.
         *
         * <p> No matching group found. No groups match the specified group ID.
         * </p>
         *
         * @return Instance of {@code GroupMembersSelectorError} with its tag
         *     set to {@link Tag#GROUP_NOT_FOUND}.
         */
        public static GroupMembersSelectorError groupNotFound() {
            return GroupMembersSelectorError.GROUP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isGroupNotFound() {
            return this.tag == Tag.GROUP_NOT_FOUND;
        }

        private static final GroupMembersSelectorError OTHER_INSTANCE = new GroupMembersSelectorError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupMembersSelectorError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupMembersSelectorError} with its tag
         *     set to {@link Tag#OTHER}.
         */
        public static GroupMembersSelectorError other() {
            return GroupMembersSelectorError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * At least one of the specified users is not a member of the group.
         */
        private static final GroupMembersSelectorError MEMBER_NOT_IN_GROUP_INSTANCE = new GroupMembersSelectorError(Tag.MEMBER_NOT_IN_GROUP);

        /**
         * Returns an instance of {@code GroupMembersSelectorError} that has its
         * tag set to {@link Tag#MEMBER_NOT_IN_GROUP}.
         *
         * <p> At least one of the specified users is not a member of the group.
         * </p>
         *
         * @return Instance of {@code GroupMembersSelectorError} with its tag
         *     set to {@link Tag#MEMBER_NOT_IN_GROUP}.
         */
        public static GroupMembersSelectorError memberNotInGroup() {
            return GroupMembersSelectorError.MEMBER_NOT_IN_GROUP_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_NOT_IN_GROUP}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_NOT_IN_GROUP}, {@code false} otherwise.
         */
        public boolean isMemberNotInGroup() {
            return this.tag == Tag.MEMBER_NOT_IN_GROUP;
        }

        private GroupMembersSelectorError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_FOUND:
                case OTHER:
                case MEMBER_NOT_IN_GROUP:
                    break;
            }
        }

        static final JsonWriter<GroupMembersSelectorError> _writer = new JsonWriter<GroupMembersSelectorError>()
        {
            public final void write(GroupMembersSelectorError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case MEMBER_NOT_IN_GROUP:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_not_in_group");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupMembersSelectorError> _reader = new JsonReader<GroupMembersSelectorError>()
        {
            public final GroupMembersSelectorError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case GROUP_NOT_FOUND: return GroupMembersSelectorError.groupNotFound();
                        case OTHER: return GroupMembersSelectorError.other();
                        case MEMBER_NOT_IN_GROUP: return GroupMembersSelectorError.memberNotInGroup();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupMembersSelectorError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_FOUND: {
                            value = GroupMembersSelectorError.groupNotFound();
                            break;
                        }
                        case OTHER: {
                            value = GroupMembersSelectorError.other();
                            break;
                        }
                        case MEMBER_NOT_IN_GROUP: {
                            value = GroupMembersSelectorError.memberNotInGroup();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("member_not_in_group", Tag.MEMBER_NOT_IN_GROUP);
        }

        public String toString() {
            return "GroupMembersSelectorError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupMembersSelectorError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupMembersSelectorError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Profile of group member, and role in group.
     */
    public static class GroupMemberInfo {
        // struct GroupMemberInfo
        /**
         * Profile of group member.
         */
        public final MemberProfile profile;
        /**
         * The role that the user has in the group.
         */
        public final GroupAccessType accessType;

        /**
         * Profile of group member, and role in group.
         *
         * @param profile  Profile of group member. {@code profile} must not be
         *     {@code null}.
         * @param accessType  The role that the user has in the group. {@code
         *     accessType} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupMemberInfo(MemberProfile profile, GroupAccessType accessType) {
            this.profile = profile;
            if (profile == null) {
                throw new IllegalArgumentException("Required value for 'profile' is null");
            }
            this.accessType = accessType;
            if (accessType == null) {
                throw new IllegalArgumentException("Required value for 'accessType' is null");
            }
        }

        static final JsonWriter<GroupMemberInfo> _writer = new JsonWriter<GroupMemberInfo>()
        {
            public final void write(GroupMemberInfo x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupMemberInfo._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupMemberInfo x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("profile");
                MemberProfile._writer.write(x.profile, g);
                g.writeFieldName("access_type");
                GroupAccessType._writer.write(x.accessType, g);
            }
        };

        public static final JsonReader<GroupMemberInfo> _reader = new JsonReader<GroupMemberInfo>() {

            public final GroupMemberInfo read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupMemberInfo result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupMemberInfo readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                MemberProfile profile = null;
                GroupAccessType accessType = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("profile".equals(fieldName)) {
                        profile = MemberProfile._reader
                            .readField(parser, "profile", profile);
                    }
                    else if ("access_type".equals(fieldName)) {
                        accessType = GroupAccessType._reader
                            .readField(parser, "access_type", accessType);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (profile == null) {
                    throw new JsonReadException("Required field \"profile\" is missing.", parser.getTokenLocation());
                }
                if (accessType == null) {
                    throw new JsonReadException("Required field \"access_type\" is missing.", parser.getTokenLocation());
                }
                return new GroupMemberInfo(profile, accessType);
            }
        };

        public String toString() {
            return "GroupMemberInfo." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupMemberInfo." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupMemberInfo fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Full description of a group.
     */
    public static class GroupFullInfo extends GroupSummary  {
        // struct GroupFullInfo
        /**
         * List of group members.
         */
        public final java.util.List<GroupMemberInfo> members;
        /**
         * The group creation time as a UTC timestamp in milliseconds since the
         * Unix epoch.
         */
        public final long created;

        /**
         * Full description of a group.
         *
         * @param groupName  . {@code groupName} must not be {@code null}.
         * @param groupId  . {@code groupId} must not be {@code null}.
         * @param memberCount  The number of members in the group.
         * @param members  List of group members. {@code members} must not
         *     contain a {@code null} item and not be {@code null}.
         * @param created  The group creation time as a UTC timestamp in
         *     milliseconds since the Unix epoch.
         * @param groupExternalId  External ID of group. This is an arbitrary ID
         *     that an admin can attach to a group.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupFullInfo(String groupName, String groupId, long memberCount, java.util.List<GroupMemberInfo> members, long created, String groupExternalId) {
            super(groupName, groupId, memberCount, groupExternalId);
            this.members = members;
            if (members == null) {
                throw new IllegalArgumentException("Required value for 'members' is null");
            }
            for (GroupMemberInfo x : members) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'members' is null");
                }
            }
            this.created = created;
        }

        static final JsonWriter<GroupFullInfo> _writer = new JsonWriter<GroupFullInfo>()
        {
            public final void write(GroupFullInfo x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupSummary._writer.writeFields(x, g);
                GroupFullInfo._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupFullInfo x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("members");
                g.writeStartArray();
                for (GroupMemberInfo item: x.members) {
                    if (item != null) {
                        GroupMemberInfo._writer.write(item, g);
                    }
                }
                g.writeEndArray();
                g.writeNumberField("created", x.created);
            }
        };

        public static final JsonReader<GroupFullInfo> _reader = new JsonReader<GroupFullInfo>() {

            public final GroupFullInfo read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupFullInfo result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupFullInfo readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String groupName = null;
                String groupId = null;
                Long memberCount = null;
                java.util.List<GroupMemberInfo> members = null;
                Long created = null;
                String groupExternalId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group_name".equals(fieldName)) {
                        groupName = JsonReader.StringReader
                            .readField(parser, "group_name", groupName);
                    }
                    else if ("group_id".equals(fieldName)) {
                        groupId = JsonReader.StringReader
                            .readField(parser, "group_id", groupId);
                    }
                    else if ("member_count".equals(fieldName)) {
                        memberCount = JsonReader.UInt32Reader
                            .readField(parser, "member_count", memberCount);
                    }
                    else if ("members".equals(fieldName)) {
                        members = JsonArrayReader.mk(GroupMemberInfo._reader)
                            .readField(parser, "members", members);
                    }
                    else if ("created".equals(fieldName)) {
                        created = JsonReader.UInt64Reader
                            .readField(parser, "created", created);
                    }
                    else if ("group_external_id".equals(fieldName)) {
                        groupExternalId = JsonReader.StringReader
                            .readField(parser, "group_external_id", groupExternalId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (groupName == null) {
                    throw new JsonReadException("Required field \"group_name\" is missing.", parser.getTokenLocation());
                }
                if (groupId == null) {
                    throw new JsonReadException("Required field \"group_id\" is missing.", parser.getTokenLocation());
                }
                if (memberCount == null) {
                    throw new JsonReadException("Required field \"member_count\" is missing.", parser.getTokenLocation());
                }
                if (members == null) {
                    throw new JsonReadException("Required field \"members\" is missing.", parser.getTokenLocation());
                }
                if (created == null) {
                    throw new JsonReadException("Required field \"created\" is missing.", parser.getTokenLocation());
                }
                return new GroupFullInfo(groupName, groupId, memberCount, members, created, groupExternalId);
            }
        };

        public String toString() {
            return "GroupFullInfo." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupFullInfo." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupFullInfo fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupsListArg {
        // struct GroupsListArg
        /**
         * Number of results to return per call.
         */
        public final long limit;

        /**
         *
         * @param limit  Number of results to return per call. {@code limit}
         *     must be greater than or equal to 1 and be less than or equal to
         *     1000.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupsListArg(Long limit) {
            if (limit != null) {
                this.limit = limit.longValue();
            }
            else {
                this.limit = 1000L;
            }
            if (this.limit < 1L) {
                throw new IllegalArgumentException("Number 'this.limit' is smaller than 1L");
            }
            if (this.limit > 1000L) {
                throw new IllegalArgumentException("Number 'this.limit' is larger than 1000L");
            }
        }

        static final JsonWriter<GroupsListArg> _writer = new JsonWriter<GroupsListArg>()
        {
            public final void write(GroupsListArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupsListArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupsListArg x, JsonGenerator g)
             throws IOException
            {
                g.writeNumberField("limit", x.limit);
            }
        };

        public static final JsonReader<GroupsListArg> _reader = new JsonReader<GroupsListArg>() {

            public final GroupsListArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupsListArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupsListArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                Long limit = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("limit".equals(fieldName)) {
                        limit = JsonReader.UInt32Reader
                            .readField(parser, "limit", limit);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                return new GroupsListArg(limit);
            }
        };

        public String toString() {
            return "GroupsListArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupsListArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupsListArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupsListResult {
        // struct GroupsListResult
        public final java.util.List<GroupSummary> groups;
        /**
         * Pass the cursor into {@link DbxTeam#membersListContinue(String)} to
         * obtain the additional members.
         */
        public final String cursor;
        /**
         * Is true if there are additional team members that have not been
         * returned yet. An additional call to {@link
         * DbxTeam#membersListContinue(String)} can retrieve them.
         */
        public final boolean hasMore;

        /**
         *
         * @param groups  . {@code groups} must not contain a {@code null} item
         *     and not be {@code null}.
         * @param cursor  Pass the cursor into {@link
         *     DbxTeam#membersListContinue(String)} to obtain the additional
         *     members. {@code cursor} must not be {@code null}.
         * @param hasMore  Is true if there are additional team members that
         *     have not been returned yet. An additional call to {@link
         *     DbxTeam#membersListContinue(String)} can retrieve them.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupsListResult(java.util.List<GroupSummary> groups, String cursor, boolean hasMore) {
            this.groups = groups;
            if (groups == null) {
                throw new IllegalArgumentException("Required value for 'groups' is null");
            }
            for (GroupSummary x : groups) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'groups' is null");
                }
            }
            this.cursor = cursor;
            if (cursor == null) {
                throw new IllegalArgumentException("Required value for 'cursor' is null");
            }
            this.hasMore = hasMore;
        }

        static final JsonWriter<GroupsListResult> _writer = new JsonWriter<GroupsListResult>()
        {
            public final void write(GroupsListResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupsListResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupsListResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("groups");
                g.writeStartArray();
                for (GroupSummary item: x.groups) {
                    if (item != null) {
                        GroupSummary._writer.write(item, g);
                    }
                }
                g.writeEndArray();
                g.writeStringField("cursor", x.cursor);
                g.writeBooleanField("has_more", x.hasMore);
            }
        };

        public static final JsonReader<GroupsListResult> _reader = new JsonReader<GroupsListResult>() {

            public final GroupsListResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupsListResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupsListResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<GroupSummary> groups = null;
                String cursor = null;
                Boolean hasMore = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("groups".equals(fieldName)) {
                        groups = JsonArrayReader.mk(GroupSummary._reader)
                            .readField(parser, "groups", groups);
                    }
                    else if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else if ("has_more".equals(fieldName)) {
                        hasMore = JsonReader.BooleanReader
                            .readField(parser, "has_more", hasMore);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (groups == null) {
                    throw new JsonReadException("Required field \"groups\" is missing.", parser.getTokenLocation());
                }
                if (cursor == null) {
                    throw new JsonReadException("Required field \"cursor\" is missing.", parser.getTokenLocation());
                }
                if (hasMore == null) {
                    throw new JsonReadException("Required field \"has_more\" is missing.", parser.getTokenLocation());
                }
                return new GroupsListResult(groups, cursor, hasMore);
            }
        };

        public String toString() {
            return "GroupsListResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupsListResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupsListResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupsListContinueArg {
        // struct GroupsListContinueArg
        /**
         * Indicates from what point to get the next set of groups.
         */
        public final String cursor;

        /**
         *
         * @param cursor  Indicates from what point to get the next set of
         *     groups. {@code cursor} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupsListContinueArg(String cursor) {
            this.cursor = cursor;
            if (cursor == null) {
                throw new IllegalArgumentException("Required value for 'cursor' is null");
            }
        }

        static final JsonWriter<GroupsListContinueArg> _writer = new JsonWriter<GroupsListContinueArg>()
        {
            public final void write(GroupsListContinueArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupsListContinueArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupsListContinueArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("cursor", x.cursor);
            }
        };

        public static final JsonReader<GroupsListContinueArg> _reader = new JsonReader<GroupsListContinueArg>() {

            public final GroupsListContinueArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupsListContinueArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupsListContinueArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String cursor = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (cursor == null) {
                    throw new JsonReadException("Required field \"cursor\" is missing.", parser.getTokenLocation());
                }
                return new GroupsListContinueArg(cursor);
            }
        };

        public String toString() {
            return "GroupsListContinueArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupsListContinueArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupsListContinueArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupsListContinueError {
        // union GroupsListContinueError

        /**
         * The discriminating tag type for {@link GroupsListContinueError}.
         */
        public enum Tag {
            /**
             * The cursor is invalid.
             */
            INVALID_CURSOR,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupsListContinueError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * The cursor is invalid.
         */
        private static final GroupsListContinueError INVALID_CURSOR_INSTANCE = new GroupsListContinueError(Tag.INVALID_CURSOR);

        /**
         * Returns an instance of {@code GroupsListContinueError} that has its
         * tag set to {@link Tag#INVALID_CURSOR}.
         *
         * <p> The cursor is invalid. </p>
         *
         * @return Instance of {@code GroupsListContinueError} with its tag set
         *     to {@link Tag#INVALID_CURSOR}.
         */
        public static GroupsListContinueError invalidCursor() {
            return GroupsListContinueError.INVALID_CURSOR_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#INVALID_CURSOR}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#INVALID_CURSOR}, {@code false} otherwise.
         */
        public boolean isInvalidCursor() {
            return this.tag == Tag.INVALID_CURSOR;
        }

        /**
         * An unspecified error.
         */
        private static final GroupsListContinueError OTHER_INSTANCE = new GroupsListContinueError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupsListContinueError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code GroupsListContinueError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static GroupsListContinueError other() {
            return GroupsListContinueError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private GroupsListContinueError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case INVALID_CURSOR:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<GroupsListContinueError> _writer = new JsonWriter<GroupsListContinueError>()
        {
            public final void write(GroupsListContinueError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case INVALID_CURSOR:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("invalid_cursor");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupsListContinueError> _reader = new JsonReader<GroupsListContinueError>()
        {
            public final GroupsListContinueError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return GroupsListContinueError.other(); }
                    switch (tag) {
                        case INVALID_CURSOR: return GroupsListContinueError.invalidCursor();
                        case OTHER: return GroupsListContinueError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupsListContinueError value = null;
                if (tag != null) {
                    switch (tag) {
                        case INVALID_CURSOR: {
                            value = GroupsListContinueError.invalidCursor();
                            break;
                        }
                        case OTHER: {
                            value = GroupsListContinueError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return GroupsListContinueError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("invalid_cursor", Tag.INVALID_CURSOR);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "GroupsListContinueError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupsListContinueError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupsListContinueError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupsGetInfoItem {
        // union GroupsGetInfoItem

        /**
         * The discriminating tag type for {@link GroupsGetInfoItem}.
         */
        public enum Tag {
            /**
             * An ID that was provided as a parameter to {@link
             * DbxTeam#groupsGetInfo}, and did not match a corresponding group.
             * The ID can be a group ID, or an external ID, depending on how the
             * method was called.
             */
            ID_NOT_FOUND,  // String
            /**
             * Info about a group.
             */
            GROUP_INFO  // GroupFullInfo
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupsGetInfoItem}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final String idNotFoundValue;

        private GroupsGetInfoItem(Tag tag, String value) {
            this.tag = tag;
            this.idNotFoundValue = value;
            this.groupInfoValue = null;
            validate();
        }

        /**
         * An ID that was provided as a parameter to {@link
         * DbxTeam#groupsGetInfo}, and did not match a corresponding group. The
         * ID can be a group ID, or an external ID, depending on how the method
         * was called.
         *
         * <p> This instance must be tagged as {@link Tag#ID_NOT_FOUND}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isIdNotFound} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isIdNotFound} is {@code
         *     false}.
         */
        public String getIdNotFoundValue() {
            if (this.tag != Tag.ID_NOT_FOUND) {
                throw new IllegalStateException("getIdNotFoundValue() requires tag==ID_NOT_FOUND, actual tag==" + tag);
            }
            return idNotFoundValue;
        }

        /**
         * Returns an instance of {@code GroupsGetInfoItem} that has its tag set
         * to {@link Tag#ID_NOT_FOUND}.
         *
         * <p> An ID that was provided as a parameter to {@link
         * DbxTeam#groupsGetInfo}, and did not match a corresponding group. The
         * ID can be a group ID, or an external ID, depending on how the method
         * was called. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code GroupsGetInfoItem} with its tag set to
         *     {@link Tag#ID_NOT_FOUND}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static GroupsGetInfoItem idNotFound(String value) {
            return new GroupsGetInfoItem(Tag.ID_NOT_FOUND, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#ID_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#ID_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isIdNotFound() {
            return this.tag == Tag.ID_NOT_FOUND;
        }

        private final GroupFullInfo groupInfoValue;

        private GroupsGetInfoItem(Tag tag, GroupFullInfo value) {
            this.tag = tag;
            this.idNotFoundValue = null;
            this.groupInfoValue = value;
            validate();
        }

        /**
         * Info about a group.
         *
         * <p> This instance must be tagged as {@link Tag#GROUP_INFO}. </p>
         *
         * @return The {@link GroupFullInfo} value associated with this instance
         *     if {@link #isGroupInfo} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isGroupInfo} is {@code
         *     false}.
         */
        public GroupFullInfo getGroupInfoValue() {
            if (this.tag != Tag.GROUP_INFO) {
                throw new IllegalStateException("getGroupInfoValue() requires tag==GROUP_INFO, actual tag==" + tag);
            }
            return groupInfoValue;
        }

        /**
         * Returns an instance of {@code GroupsGetInfoItem} that has its tag set
         * to {@link Tag#GROUP_INFO}.
         *
         * <p> Info about a group. </p>
         *
         * @param value  {@link GroupFullInfo} value to assign to this instance.
         *
         * @return Instance of {@code GroupsGetInfoItem} with its tag set to
         *     {@link Tag#GROUP_INFO}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static GroupsGetInfoItem groupInfo(GroupFullInfo value) {
            return new GroupsGetInfoItem(Tag.GROUP_INFO, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_INFO}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_INFO}, {@code false} otherwise.
         */
        public boolean isGroupInfo() {
            return this.tag == Tag.GROUP_INFO;
        }


        private final void validate() {
            switch (this.tag) {
                case ID_NOT_FOUND:
                    if (this.idNotFoundValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case GROUP_INFO:
                    if (this.groupInfoValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
            }
        }

        static final JsonWriter<GroupsGetInfoItem> _writer = new JsonWriter<GroupsGetInfoItem>()
        {
            public final void write(GroupsGetInfoItem x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case ID_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("id_not_found");
                        g.writeStringField("id_not_found", x.idNotFoundValue);
                        g.writeEndObject();
                        break;
                    case GROUP_INFO:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_info");
                        GroupFullInfo._writer.writeFields(x.groupInfoValue, g);
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupsGetInfoItem> _reader = new JsonReader<GroupsGetInfoItem>()
        {
            public final GroupsGetInfoItem read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupsGetInfoItem value = null;
                if (tag != null) {
                    switch (tag) {
                        case ID_NOT_FOUND: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "id_not_found", v);
                            value = GroupsGetInfoItem.idNotFound(v);
                            break;
                        }
                        case GROUP_INFO: {
                            GroupFullInfo v = null;
                            v = GroupFullInfo._reader.readFields(parser);
                            value = GroupsGetInfoItem.groupInfo(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("id_not_found", Tag.ID_NOT_FOUND);
            _values.put("group_info", Tag.GROUP_INFO);
        }

        public String toString() {
            return "GroupsGetInfoItem." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupsGetInfoItem." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupsGetInfoItem fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupsGetInfoError {
        // union GroupsGetInfoError

        /**
         * The discriminating tag type for {@link GroupsGetInfoError}.
         */
        public enum Tag {
            /**
             * The group is not on your team.
             */
            GROUP_NOT_ON_TEAM,
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupsGetInfoError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * The group is not on your team.
         */
        private static final GroupsGetInfoError GROUP_NOT_ON_TEAM_INSTANCE = new GroupsGetInfoError(Tag.GROUP_NOT_ON_TEAM);

        /**
         * Returns an instance of {@code GroupsGetInfoError} that has its tag
         * set to {@link Tag#GROUP_NOT_ON_TEAM}.
         *
         * <p> The group is not on your team. </p>
         *
         * @return Instance of {@code GroupsGetInfoError} with its tag set to
         *     {@link Tag#GROUP_NOT_ON_TEAM}.
         */
        public static GroupsGetInfoError groupNotOnTeam() {
            return GroupsGetInfoError.GROUP_NOT_ON_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_ON_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_ON_TEAM}, {@code false} otherwise.
         */
        public boolean isGroupNotOnTeam() {
            return this.tag == Tag.GROUP_NOT_ON_TEAM;
        }

        private static final GroupsGetInfoError OTHER_INSTANCE = new GroupsGetInfoError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupsGetInfoError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupsGetInfoError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static GroupsGetInfoError other() {
            return GroupsGetInfoError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private GroupsGetInfoError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_ON_TEAM:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<GroupsGetInfoError> _writer = new JsonWriter<GroupsGetInfoError>()
        {
            public final void write(GroupsGetInfoError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_ON_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_on_team");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupsGetInfoError> _reader = new JsonReader<GroupsGetInfoError>()
        {
            public final GroupsGetInfoError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return GroupsGetInfoError.other(); }
                    switch (tag) {
                        case GROUP_NOT_ON_TEAM: return GroupsGetInfoError.groupNotOnTeam();
                        case OTHER: return GroupsGetInfoError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupsGetInfoError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_ON_TEAM: {
                            value = GroupsGetInfoError.groupNotOnTeam();
                            break;
                        }
                        case OTHER: {
                            value = GroupsGetInfoError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return GroupsGetInfoError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("group_not_on_team", Tag.GROUP_NOT_ON_TEAM);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "GroupsGetInfoError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupsGetInfoError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupsGetInfoError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupCreateArg {
        // struct GroupCreateArg
        /**
         * Group name.
         */
        public final String groupName;
        /**
         * Optional argument. The creator of a team can associate an arbitrary
         * external ID to the group.
         */
        public final String groupExternalId;

        /**
         *
         * @param groupName  Group name. {@code groupName} must not be {@code
         *     null}.
         * @param groupExternalId  Optional argument. The creator of a team can
         *     associate an arbitrary external ID to the group.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupCreateArg(String groupName, String groupExternalId) {
            this.groupName = groupName;
            if (groupName == null) {
                throw new IllegalArgumentException("Required value for 'groupName' is null");
            }
            this.groupExternalId = groupExternalId;
        }

        static final JsonWriter<GroupCreateArg> _writer = new JsonWriter<GroupCreateArg>()
        {
            public final void write(GroupCreateArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupCreateArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupCreateArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("group_name", x.groupName);
                if (x.groupExternalId != null) {
                    g.writeFieldName("group_external_id");
                    g.writeString(x.groupExternalId);
                }
            }
        };

        public static final JsonReader<GroupCreateArg> _reader = new JsonReader<GroupCreateArg>() {

            public final GroupCreateArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupCreateArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupCreateArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String groupName = null;
                String groupExternalId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group_name".equals(fieldName)) {
                        groupName = JsonReader.StringReader
                            .readField(parser, "group_name", groupName);
                    }
                    else if ("group_external_id".equals(fieldName)) {
                        groupExternalId = JsonReader.StringReader
                            .readField(parser, "group_external_id", groupExternalId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (groupName == null) {
                    throw new JsonReadException("Required field \"group_name\" is missing.", parser.getTokenLocation());
                }
                return new GroupCreateArg(groupName, groupExternalId);
            }
        };

        public String toString() {
            return "GroupCreateArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupCreateArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupCreateArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupCreateError {
        // union GroupCreateError

        /**
         * The discriminating tag type for {@link GroupCreateError}.
         */
        public enum Tag {
            /**
             * There is already an existing group with the requested name.
             */
            GROUP_NAME_ALREADY_USED,
            /**
             * Group name is empty or has invalid characters.
             */
            GROUP_NAME_INVALID,
            /**
             * The new external ID is already being used by another group.
             */
            EXTERNAL_ID_ALREADY_IN_USE,
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupCreateError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * There is already an existing group with the requested name.
         */
        private static final GroupCreateError GROUP_NAME_ALREADY_USED_INSTANCE = new GroupCreateError(Tag.GROUP_NAME_ALREADY_USED);

        /**
         * Returns an instance of {@code GroupCreateError} that has its tag set
         * to {@link Tag#GROUP_NAME_ALREADY_USED}.
         *
         * <p> There is already an existing group with the requested name. </p>
         *
         * @return Instance of {@code GroupCreateError} with its tag set to
         *     {@link Tag#GROUP_NAME_ALREADY_USED}.
         */
        public static GroupCreateError groupNameAlreadyUsed() {
            return GroupCreateError.GROUP_NAME_ALREADY_USED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NAME_ALREADY_USED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NAME_ALREADY_USED}, {@code false} otherwise.
         */
        public boolean isGroupNameAlreadyUsed() {
            return this.tag == Tag.GROUP_NAME_ALREADY_USED;
        }

        /**
         * Group name is empty or has invalid characters.
         */
        private static final GroupCreateError GROUP_NAME_INVALID_INSTANCE = new GroupCreateError(Tag.GROUP_NAME_INVALID);

        /**
         * Returns an instance of {@code GroupCreateError} that has its tag set
         * to {@link Tag#GROUP_NAME_INVALID}.
         *
         * <p> Group name is empty or has invalid characters. </p>
         *
         * @return Instance of {@code GroupCreateError} with its tag set to
         *     {@link Tag#GROUP_NAME_INVALID}.
         */
        public static GroupCreateError groupNameInvalid() {
            return GroupCreateError.GROUP_NAME_INVALID_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NAME_INVALID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NAME_INVALID}, {@code false} otherwise.
         */
        public boolean isGroupNameInvalid() {
            return this.tag == Tag.GROUP_NAME_INVALID;
        }

        /**
         * The new external ID is already being used by another group.
         */
        private static final GroupCreateError EXTERNAL_ID_ALREADY_IN_USE_INSTANCE = new GroupCreateError(Tag.EXTERNAL_ID_ALREADY_IN_USE);

        /**
         * Returns an instance of {@code GroupCreateError} that has its tag set
         * to {@link Tag#EXTERNAL_ID_ALREADY_IN_USE}.
         *
         * <p> The new external ID is already being used by another group. </p>
         *
         * @return Instance of {@code GroupCreateError} with its tag set to
         *     {@link Tag#EXTERNAL_ID_ALREADY_IN_USE}.
         */
        public static GroupCreateError externalIdAlreadyInUse() {
            return GroupCreateError.EXTERNAL_ID_ALREADY_IN_USE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#EXTERNAL_ID_ALREADY_IN_USE}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EXTERNAL_ID_ALREADY_IN_USE}, {@code false} otherwise.
         */
        public boolean isExternalIdAlreadyInUse() {
            return this.tag == Tag.EXTERNAL_ID_ALREADY_IN_USE;
        }

        private static final GroupCreateError OTHER_INSTANCE = new GroupCreateError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupCreateError} that has its tag set
         * to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupCreateError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static GroupCreateError other() {
            return GroupCreateError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private GroupCreateError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NAME_ALREADY_USED:
                case GROUP_NAME_INVALID:
                case EXTERNAL_ID_ALREADY_IN_USE:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<GroupCreateError> _writer = new JsonWriter<GroupCreateError>()
        {
            public final void write(GroupCreateError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NAME_ALREADY_USED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_name_already_used");
                        g.writeEndObject();
                        break;
                    case GROUP_NAME_INVALID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_name_invalid");
                        g.writeEndObject();
                        break;
                    case EXTERNAL_ID_ALREADY_IN_USE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("external_id_already_in_use");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupCreateError> _reader = new JsonReader<GroupCreateError>()
        {
            public final GroupCreateError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return GroupCreateError.other(); }
                    switch (tag) {
                        case GROUP_NAME_ALREADY_USED: return GroupCreateError.groupNameAlreadyUsed();
                        case GROUP_NAME_INVALID: return GroupCreateError.groupNameInvalid();
                        case EXTERNAL_ID_ALREADY_IN_USE: return GroupCreateError.externalIdAlreadyInUse();
                        case OTHER: return GroupCreateError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupCreateError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NAME_ALREADY_USED: {
                            value = GroupCreateError.groupNameAlreadyUsed();
                            break;
                        }
                        case GROUP_NAME_INVALID: {
                            value = GroupCreateError.groupNameInvalid();
                            break;
                        }
                        case EXTERNAL_ID_ALREADY_IN_USE: {
                            value = GroupCreateError.externalIdAlreadyInUse();
                            break;
                        }
                        case OTHER: {
                            value = GroupCreateError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return GroupCreateError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("group_name_already_used", Tag.GROUP_NAME_ALREADY_USED);
            _values.put("group_name_invalid", Tag.GROUP_NAME_INVALID);
            _values.put("external_id_already_in_use", Tag.EXTERNAL_ID_ALREADY_IN_USE);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "GroupCreateError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupCreateError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupCreateError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupDeleteError {
        // union GroupDeleteError

        /**
         * The discriminating tag type for {@link GroupDeleteError}.
         */
        public enum Tag {
            /**
             * No matching group found. No groups match the specified group ID.
             */
            GROUP_NOT_FOUND,
            OTHER,
            /**
             * This group has already been deleted.
             */
            GROUP_ALREADY_DELETED
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupDeleteError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching group found. No groups match the specified group ID.
         */
        private static final GroupDeleteError GROUP_NOT_FOUND_INSTANCE = new GroupDeleteError(Tag.GROUP_NOT_FOUND);

        /**
         * Returns an instance of {@code GroupDeleteError} that has its tag set
         * to {@link Tag#GROUP_NOT_FOUND}.
         *
         * <p> No matching group found. No groups match the specified group ID.
         * </p>
         *
         * @return Instance of {@code GroupDeleteError} with its tag set to
         *     {@link Tag#GROUP_NOT_FOUND}.
         */
        public static GroupDeleteError groupNotFound() {
            return GroupDeleteError.GROUP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isGroupNotFound() {
            return this.tag == Tag.GROUP_NOT_FOUND;
        }

        private static final GroupDeleteError OTHER_INSTANCE = new GroupDeleteError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupDeleteError} that has its tag set
         * to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupDeleteError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static GroupDeleteError other() {
            return GroupDeleteError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * This group has already been deleted.
         */
        private static final GroupDeleteError GROUP_ALREADY_DELETED_INSTANCE = new GroupDeleteError(Tag.GROUP_ALREADY_DELETED);

        /**
         * Returns an instance of {@code GroupDeleteError} that has its tag set
         * to {@link Tag#GROUP_ALREADY_DELETED}.
         *
         * <p> This group has already been deleted. </p>
         *
         * @return Instance of {@code GroupDeleteError} with its tag set to
         *     {@link Tag#GROUP_ALREADY_DELETED}.
         */
        public static GroupDeleteError groupAlreadyDeleted() {
            return GroupDeleteError.GROUP_ALREADY_DELETED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_ALREADY_DELETED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_ALREADY_DELETED}, {@code false} otherwise.
         */
        public boolean isGroupAlreadyDeleted() {
            return this.tag == Tag.GROUP_ALREADY_DELETED;
        }

        private GroupDeleteError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_FOUND:
                case OTHER:
                case GROUP_ALREADY_DELETED:
                    break;
            }
        }

        static final JsonWriter<GroupDeleteError> _writer = new JsonWriter<GroupDeleteError>()
        {
            public final void write(GroupDeleteError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case GROUP_ALREADY_DELETED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_already_deleted");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupDeleteError> _reader = new JsonReader<GroupDeleteError>()
        {
            public final GroupDeleteError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case GROUP_NOT_FOUND: return GroupDeleteError.groupNotFound();
                        case OTHER: return GroupDeleteError.other();
                        case GROUP_ALREADY_DELETED: return GroupDeleteError.groupAlreadyDeleted();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupDeleteError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_FOUND: {
                            value = GroupDeleteError.groupNotFound();
                            break;
                        }
                        case OTHER: {
                            value = GroupDeleteError.other();
                            break;
                        }
                        case GROUP_ALREADY_DELETED: {
                            value = GroupDeleteError.groupAlreadyDeleted();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("group_already_deleted", Tag.GROUP_ALREADY_DELETED);
        }

        public String toString() {
            return "GroupDeleteError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupDeleteError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupDeleteError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupUpdateArgs {
        // struct GroupUpdateArgs
        /**
         * Specify a group.
         */
        public final GroupSelector group;
        /**
         * Optional argument. Set group name to this if provided.
         */
        public final String newGroupName;
        /**
         * Optional argument. New group external ID. If the argument is None,
         * the group's external_id won't be updated. If the argument is empty
         * string, the group's external id will be cleared.
         */
        public final String newGroupExternalId;

        /**
         *
         * @param group  Specify a group. {@code group} must not be {@code
         *     null}.
         * @param newGroupName  Optional argument. Set group name to this if
         *     provided.
         * @param newGroupExternalId  Optional argument. New group external ID.
         *     If the argument is None, the group's external_id won't be
         *     updated. If the argument is empty string, the group's external id
         *     will be cleared.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupUpdateArgs(GroupSelector group, String newGroupName, String newGroupExternalId) {
            this.group = group;
            if (group == null) {
                throw new IllegalArgumentException("Required value for 'group' is null");
            }
            this.newGroupName = newGroupName;
            this.newGroupExternalId = newGroupExternalId;
        }

        static final JsonWriter<GroupUpdateArgs> _writer = new JsonWriter<GroupUpdateArgs>()
        {
            public final void write(GroupUpdateArgs x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupUpdateArgs._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupUpdateArgs x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("group");
                GroupSelector._writer.write(x.group, g);
                if (x.newGroupName != null) {
                    g.writeFieldName("new_group_name");
                    g.writeString(x.newGroupName);
                }
                if (x.newGroupExternalId != null) {
                    g.writeFieldName("new_group_external_id");
                    g.writeString(x.newGroupExternalId);
                }
            }
        };

        public static final JsonReader<GroupUpdateArgs> _reader = new JsonReader<GroupUpdateArgs>() {

            public final GroupUpdateArgs read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupUpdateArgs result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupUpdateArgs readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupSelector group = null;
                String newGroupName = null;
                String newGroupExternalId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group".equals(fieldName)) {
                        group = GroupSelector._reader
                            .readField(parser, "group", group);
                    }
                    else if ("new_group_name".equals(fieldName)) {
                        newGroupName = JsonReader.StringReader
                            .readField(parser, "new_group_name", newGroupName);
                    }
                    else if ("new_group_external_id".equals(fieldName)) {
                        newGroupExternalId = JsonReader.StringReader
                            .readField(parser, "new_group_external_id", newGroupExternalId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (group == null) {
                    throw new JsonReadException("Required field \"group\" is missing.", parser.getTokenLocation());
                }
                return new GroupUpdateArgs(group, newGroupName, newGroupExternalId);
            }
        };

        public String toString() {
            return "GroupUpdateArgs." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupUpdateArgs." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupUpdateArgs fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupUpdateError {
        // union GroupUpdateError

        /**
         * The discriminating tag type for {@link GroupUpdateError}.
         */
        public enum Tag {
            /**
             * No matching group found. No groups match the specified group ID.
             */
            GROUP_NOT_FOUND,
            OTHER,
            /**
             * The new external ID is already being used by another group.
             */
            EXTERNAL_ID_ALREADY_IN_USE
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupUpdateError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching group found. No groups match the specified group ID.
         */
        private static final GroupUpdateError GROUP_NOT_FOUND_INSTANCE = new GroupUpdateError(Tag.GROUP_NOT_FOUND);

        /**
         * Returns an instance of {@code GroupUpdateError} that has its tag set
         * to {@link Tag#GROUP_NOT_FOUND}.
         *
         * <p> No matching group found. No groups match the specified group ID.
         * </p>
         *
         * @return Instance of {@code GroupUpdateError} with its tag set to
         *     {@link Tag#GROUP_NOT_FOUND}.
         */
        public static GroupUpdateError groupNotFound() {
            return GroupUpdateError.GROUP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isGroupNotFound() {
            return this.tag == Tag.GROUP_NOT_FOUND;
        }

        private static final GroupUpdateError OTHER_INSTANCE = new GroupUpdateError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupUpdateError} that has its tag set
         * to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupUpdateError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static GroupUpdateError other() {
            return GroupUpdateError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * The new external ID is already being used by another group.
         */
        private static final GroupUpdateError EXTERNAL_ID_ALREADY_IN_USE_INSTANCE = new GroupUpdateError(Tag.EXTERNAL_ID_ALREADY_IN_USE);

        /**
         * Returns an instance of {@code GroupUpdateError} that has its tag set
         * to {@link Tag#EXTERNAL_ID_ALREADY_IN_USE}.
         *
         * <p> The new external ID is already being used by another group. </p>
         *
         * @return Instance of {@code GroupUpdateError} with its tag set to
         *     {@link Tag#EXTERNAL_ID_ALREADY_IN_USE}.
         */
        public static GroupUpdateError externalIdAlreadyInUse() {
            return GroupUpdateError.EXTERNAL_ID_ALREADY_IN_USE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#EXTERNAL_ID_ALREADY_IN_USE}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EXTERNAL_ID_ALREADY_IN_USE}, {@code false} otherwise.
         */
        public boolean isExternalIdAlreadyInUse() {
            return this.tag == Tag.EXTERNAL_ID_ALREADY_IN_USE;
        }

        private GroupUpdateError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_FOUND:
                case OTHER:
                case EXTERNAL_ID_ALREADY_IN_USE:
                    break;
            }
        }

        static final JsonWriter<GroupUpdateError> _writer = new JsonWriter<GroupUpdateError>()
        {
            public final void write(GroupUpdateError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case EXTERNAL_ID_ALREADY_IN_USE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("external_id_already_in_use");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupUpdateError> _reader = new JsonReader<GroupUpdateError>()
        {
            public final GroupUpdateError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case GROUP_NOT_FOUND: return GroupUpdateError.groupNotFound();
                        case OTHER: return GroupUpdateError.other();
                        case EXTERNAL_ID_ALREADY_IN_USE: return GroupUpdateError.externalIdAlreadyInUse();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupUpdateError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_FOUND: {
                            value = GroupUpdateError.groupNotFound();
                            break;
                        }
                        case OTHER: {
                            value = GroupUpdateError.other();
                            break;
                        }
                        case EXTERNAL_ID_ALREADY_IN_USE: {
                            value = GroupUpdateError.externalIdAlreadyInUse();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("external_id_already_in_use", Tag.EXTERNAL_ID_ALREADY_IN_USE);
        }

        public String toString() {
            return "GroupUpdateError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupUpdateError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupUpdateError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Result returned by {@link
     * DbxTeam#groupsMembersAdd(DbxTeam.GroupSelector,java.util.List)} and
     * {@link
     * DbxTeam#groupsMembersRemove(DbxTeam.GroupSelector,java.util.List)}.
     */
    public static class GroupMembersChangeResult {
        // struct GroupMembersChangeResult
        /**
         * Lists the group members after the member change operation has been
         * performed.
         */
        public final GroupFullInfo groupInfo;
        /**
         * An ID that can be used to obtain the status of granting/revoking
         * group-owned resources.
         */
        public final String asyncJobId;

        /**
         * Result returned by {@link
         * DbxTeam#groupsMembersAdd(DbxTeam.GroupSelector,java.util.List)} and
         * {@link
         * DbxTeam#groupsMembersRemove(DbxTeam.GroupSelector,java.util.List)}.
         *
         * @param groupInfo  Lists the group members after the member change
         *     operation has been performed. {@code groupInfo} must not be
         *     {@code null}.
         * @param asyncJobId  An ID that can be used to obtain the status of
         *     granting/revoking group-owned resources. {@code asyncJobId} must
         *     have length of at least 1 and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupMembersChangeResult(GroupFullInfo groupInfo, String asyncJobId) {
            this.groupInfo = groupInfo;
            if (groupInfo == null) {
                throw new IllegalArgumentException("Required value for 'groupInfo' is null");
            }
            this.asyncJobId = asyncJobId;
            if (asyncJobId == null) {
                throw new IllegalArgumentException("Required value for 'asyncJobId' is null");
            }
            if (asyncJobId.length() < 1) {
                throw new IllegalArgumentException("String 'asyncJobId' is shorter than 1");
            }
        }

        static final JsonWriter<GroupMembersChangeResult> _writer = new JsonWriter<GroupMembersChangeResult>()
        {
            public final void write(GroupMembersChangeResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupMembersChangeResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupMembersChangeResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("group_info");
                GroupFullInfo._writer.write(x.groupInfo, g);
                g.writeStringField("async_job_id", x.asyncJobId);
            }
        };

        public static final JsonReader<GroupMembersChangeResult> _reader = new JsonReader<GroupMembersChangeResult>() {

            public final GroupMembersChangeResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupMembersChangeResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupMembersChangeResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupFullInfo groupInfo = null;
                String asyncJobId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group_info".equals(fieldName)) {
                        groupInfo = GroupFullInfo._reader
                            .readField(parser, "group_info", groupInfo);
                    }
                    else if ("async_job_id".equals(fieldName)) {
                        asyncJobId = JsonReader.StringReader
                            .readField(parser, "async_job_id", asyncJobId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (groupInfo == null) {
                    throw new JsonReadException("Required field \"group_info\" is missing.", parser.getTokenLocation());
                }
                if (asyncJobId == null) {
                    throw new JsonReadException("Required field \"async_job_id\" is missing.", parser.getTokenLocation());
                }
                return new GroupMembersChangeResult(groupInfo, asyncJobId);
            }
        };

        public String toString() {
            return "GroupMembersChangeResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupMembersChangeResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupMembersChangeResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Specify access type a member should have when joined to a group.
     */
    public static class MemberAccess {
        // struct MemberAccess
        /**
         * Identity of a user.
         */
        public final UserSelectorArg user;
        /**
         * Access type.
         */
        public final GroupAccessType accessType;

        /**
         * Specify access type a member should have when joined to a group.
         *
         * @param user  Identity of a user. {@code user} must not be {@code
         *     null}.
         * @param accessType  Access type. {@code accessType} must not be {@code
         *     null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MemberAccess(UserSelectorArg user, GroupAccessType accessType) {
            this.user = user;
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
            this.accessType = accessType;
            if (accessType == null) {
                throw new IllegalArgumentException("Required value for 'accessType' is null");
            }
        }

        static final JsonWriter<MemberAccess> _writer = new JsonWriter<MemberAccess>()
        {
            public final void write(MemberAccess x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MemberAccess._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MemberAccess x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("user");
                UserSelectorArg._writer.write(x.user, g);
                g.writeFieldName("access_type");
                GroupAccessType._writer.write(x.accessType, g);
            }
        };

        public static final JsonReader<MemberAccess> _reader = new JsonReader<MemberAccess>() {

            public final MemberAccess read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MemberAccess result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MemberAccess readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                UserSelectorArg user = null;
                GroupAccessType accessType = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else if ("access_type".equals(fieldName)) {
                        accessType = GroupAccessType._reader
                            .readField(parser, "access_type", accessType);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                if (accessType == null) {
                    throw new JsonReadException("Required field \"access_type\" is missing.", parser.getTokenLocation());
                }
                return new MemberAccess(user, accessType);
            }
        };

        public String toString() {
            return "MemberAccess." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MemberAccess." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MemberAccess fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupMembersAddArg {
        // struct GroupMembersAddArg
        /**
         * Group to which users will be added.
         */
        public final GroupSelector group;
        /**
         * List of users to be added to the group.
         */
        public final java.util.List<MemberAccess> members;

        /**
         *
         * @param group  Group to which users will be added. {@code group} must
         *     not be {@code null}.
         * @param members  List of users to be added to the group. {@code
         *     members} must not contain a {@code null} item and not be {@code
         *     null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupMembersAddArg(GroupSelector group, java.util.List<MemberAccess> members) {
            this.group = group;
            if (group == null) {
                throw new IllegalArgumentException("Required value for 'group' is null");
            }
            this.members = members;
            if (members == null) {
                throw new IllegalArgumentException("Required value for 'members' is null");
            }
            for (MemberAccess x : members) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'members' is null");
                }
            }
        }

        static final JsonWriter<GroupMembersAddArg> _writer = new JsonWriter<GroupMembersAddArg>()
        {
            public final void write(GroupMembersAddArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupMembersAddArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupMembersAddArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("group");
                GroupSelector._writer.write(x.group, g);
                g.writeFieldName("members");
                g.writeStartArray();
                for (MemberAccess item: x.members) {
                    if (item != null) {
                        MemberAccess._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<GroupMembersAddArg> _reader = new JsonReader<GroupMembersAddArg>() {

            public final GroupMembersAddArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupMembersAddArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupMembersAddArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupSelector group = null;
                java.util.List<MemberAccess> members = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group".equals(fieldName)) {
                        group = GroupSelector._reader
                            .readField(parser, "group", group);
                    }
                    else if ("members".equals(fieldName)) {
                        members = JsonArrayReader.mk(MemberAccess._reader)
                            .readField(parser, "members", members);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (group == null) {
                    throw new JsonReadException("Required field \"group\" is missing.", parser.getTokenLocation());
                }
                if (members == null) {
                    throw new JsonReadException("Required field \"members\" is missing.", parser.getTokenLocation());
                }
                return new GroupMembersAddArg(group, members);
            }
        };

        public String toString() {
            return "GroupMembersAddArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupMembersAddArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupMembersAddArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupMembersAddError {
        // union GroupMembersAddError

        /**
         * The discriminating tag type for {@link GroupMembersAddError}.
         */
        public enum Tag {
            /**
             * No matching group found. No groups match the specified group ID.
             */
            GROUP_NOT_FOUND,
            OTHER,
            /**
             * You cannot add duplicate users. One or more of the members you
             * are trying to add is already a member of the group.
             */
            DUPLICATE_USER,
            /**
             * Group is not in this team. You cannot add members to a group that
             * is outside of your team.
             */
            GROUP_NOT_IN_TEAM,
            /**
             * These members are not part of your team. Currently, you cannot
             * add members to a group if they are not part of your team, though
             * this may change in a subsequent version. To add new members to
             * your Dropbox Business team, use the {@link
             * DbxTeam#membersAdd(java.util.List,boolean)} endpoint.
             */
            MEMBERS_NOT_IN_TEAM,  // List
            /**
             * These users were not found in Dropbox.
             */
            USERS_NOT_FOUND,  // List
            /**
             * A suspended user cannot be added to a group as owner.
             */
            USER_MUST_BE_ACTIVE_TO_BE_OWNER
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupMembersAddError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching group found. No groups match the specified group ID.
         */
        private static final GroupMembersAddError GROUP_NOT_FOUND_INSTANCE = new GroupMembersAddError(Tag.GROUP_NOT_FOUND);

        /**
         * Returns an instance of {@code GroupMembersAddError} that has its tag
         * set to {@link Tag#GROUP_NOT_FOUND}.
         *
         * <p> No matching group found. No groups match the specified group ID.
         * </p>
         *
         * @return Instance of {@code GroupMembersAddError} with its tag set to
         *     {@link Tag#GROUP_NOT_FOUND}.
         */
        public static GroupMembersAddError groupNotFound() {
            return GroupMembersAddError.GROUP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isGroupNotFound() {
            return this.tag == Tag.GROUP_NOT_FOUND;
        }

        private static final GroupMembersAddError OTHER_INSTANCE = new GroupMembersAddError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupMembersAddError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupMembersAddError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static GroupMembersAddError other() {
            return GroupMembersAddError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * You cannot add duplicate users. One or more of the members you are
         * trying to add is already a member of the group.
         */
        private static final GroupMembersAddError DUPLICATE_USER_INSTANCE = new GroupMembersAddError(Tag.DUPLICATE_USER);

        /**
         * Returns an instance of {@code GroupMembersAddError} that has its tag
         * set to {@link Tag#DUPLICATE_USER}.
         *
         * <p> You cannot add duplicate users. One or more of the members you
         * are trying to add is already a member of the group. </p>
         *
         * @return Instance of {@code GroupMembersAddError} with its tag set to
         *     {@link Tag#DUPLICATE_USER}.
         */
        public static GroupMembersAddError duplicateUser() {
            return GroupMembersAddError.DUPLICATE_USER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#DUPLICATE_USER}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#DUPLICATE_USER}, {@code false} otherwise.
         */
        public boolean isDuplicateUser() {
            return this.tag == Tag.DUPLICATE_USER;
        }

        /**
         * Group is not in this team. You cannot add members to a group that is
         * outside of your team.
         */
        private static final GroupMembersAddError GROUP_NOT_IN_TEAM_INSTANCE = new GroupMembersAddError(Tag.GROUP_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code GroupMembersAddError} that has its tag
         * set to {@link Tag#GROUP_NOT_IN_TEAM}.
         *
         * <p> Group is not in this team. You cannot add members to a group that
         * is outside of your team. </p>
         *
         * @return Instance of {@code GroupMembersAddError} with its tag set to
         *     {@link Tag#GROUP_NOT_IN_TEAM}.
         */
        public static GroupMembersAddError groupNotInTeam() {
            return GroupMembersAddError.GROUP_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isGroupNotInTeam() {
            return this.tag == Tag.GROUP_NOT_IN_TEAM;
        }

        private final java.util.List<String> membersNotInTeamValue;

        private GroupMembersAddError(Tag tag, java.util.List<String> value) {
            this.tag = tag;
            this.membersNotInTeamValue = value;
            validate();
        }

        /**
         * These members are not part of your team. Currently, you cannot add
         * members to a group if they are not part of your team, though this may
         * change in a subsequent version. To add new members to your Dropbox
         * Business team, use the {@link
         * DbxTeam#membersAdd(java.util.List,boolean)} endpoint.
         *
         * <p> This instance must be tagged as {@link Tag#MEMBERS_NOT_IN_TEAM}.
         * </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isMembersNotInTeam} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isMembersNotInTeam} is
         *     {@code false}.
         */
        public java.util.List<String> getMembersNotInTeamValue() {
            if (this.tag != Tag.MEMBERS_NOT_IN_TEAM) {
                throw new IllegalStateException("getMembersNotInTeamValue() requires tag==MEMBERS_NOT_IN_TEAM, actual tag==" + tag);
            }
            return membersNotInTeamValue;
        }

        /**
         * Returns an instance of {@code GroupMembersAddError} that has its tag
         * set to {@link Tag#MEMBERS_NOT_IN_TEAM}.
         *
         * <p> These members are not part of your team. Currently, you cannot
         * add members to a group if they are not part of your team, though this
         * may change in a subsequent version. To add new members to your
         * Dropbox Business team, use the {@link
         * DbxTeam#membersAdd(java.util.List,boolean)} endpoint. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code GroupMembersAddError} with its tag set to
         *     {@link Tag#MEMBERS_NOT_IN_TEAM}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static GroupMembersAddError membersNotInTeam(java.util.List<String> value) {
            return new GroupMembersAddError(Tag.MEMBERS_NOT_IN_TEAM, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBERS_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBERS_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isMembersNotInTeam() {
            return this.tag == Tag.MEMBERS_NOT_IN_TEAM;
        }

        // Reusing membersNotInTeamValue for usersNotFound

        /**
         * These users were not found in Dropbox.
         *
         * <p> This instance must be tagged as {@link Tag#USERS_NOT_FOUND}. </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isUsersNotFound} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isUsersNotFound} is {@code
         *     false}.
         */
        public java.util.List<String> getUsersNotFoundValue() {
            if (this.tag != Tag.USERS_NOT_FOUND) {
                throw new IllegalStateException("getUsersNotFoundValue() requires tag==USERS_NOT_FOUND, actual tag==" + tag);
            }
            return membersNotInTeamValue;
        }

        /**
         * Returns an instance of {@code GroupMembersAddError} that has its tag
         * set to {@link Tag#USERS_NOT_FOUND}.
         *
         * <p> These users were not found in Dropbox. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code GroupMembersAddError} with its tag set to
         *     {@link Tag#USERS_NOT_FOUND}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static GroupMembersAddError usersNotFound(java.util.List<String> value) {
            return new GroupMembersAddError(Tag.USERS_NOT_FOUND, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USERS_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USERS_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUsersNotFound() {
            return this.tag == Tag.USERS_NOT_FOUND;
        }

        /**
         * A suspended user cannot be added to a group as owner.
         */
        private static final GroupMembersAddError USER_MUST_BE_ACTIVE_TO_BE_OWNER_INSTANCE = new GroupMembersAddError(Tag.USER_MUST_BE_ACTIVE_TO_BE_OWNER);

        /**
         * Returns an instance of {@code GroupMembersAddError} that has its tag
         * set to {@link Tag#USER_MUST_BE_ACTIVE_TO_BE_OWNER}.
         *
         * <p> A suspended user cannot be added to a group as owner. </p>
         *
         * @return Instance of {@code GroupMembersAddError} with its tag set to
         *     {@link Tag#USER_MUST_BE_ACTIVE_TO_BE_OWNER}.
         */
        public static GroupMembersAddError userMustBeActiveToBeOwner() {
            return GroupMembersAddError.USER_MUST_BE_ACTIVE_TO_BE_OWNER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_MUST_BE_ACTIVE_TO_BE_OWNER}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_MUST_BE_ACTIVE_TO_BE_OWNER}, {@code false} otherwise.
         */
        public boolean isUserMustBeActiveToBeOwner() {
            return this.tag == Tag.USER_MUST_BE_ACTIVE_TO_BE_OWNER;
        }

        private GroupMembersAddError(Tag t) {
            tag = t;
            membersNotInTeamValue = null;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_FOUND:
                case OTHER:
                case DUPLICATE_USER:
                case GROUP_NOT_IN_TEAM:
                case USER_MUST_BE_ACTIVE_TO_BE_OWNER:
                    break;
                case MEMBERS_NOT_IN_TEAM:
                    if (this.membersNotInTeamValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (String x : this.membersNotInTeamValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
                case USERS_NOT_FOUND:
                    if (this.membersNotInTeamValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (String x : this.membersNotInTeamValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
            }
        }

        static final JsonWriter<GroupMembersAddError> _writer = new JsonWriter<GroupMembersAddError>()
        {
            public final void write(GroupMembersAddError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case DUPLICATE_USER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("duplicate_user");
                        g.writeEndObject();
                        break;
                    case GROUP_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_in_team");
                        g.writeEndObject();
                        break;
                    case MEMBERS_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("members_not_in_team");
                        g.writeFieldName("members_not_in_team");
                        g.writeStartArray();
                        for (String item: x.membersNotInTeamValue) {
                            if (item != null) {
                                g.writeString(item);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                    case USERS_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("users_not_found");
                        g.writeFieldName("users_not_found");
                        g.writeStartArray();
                        for (String item: x.membersNotInTeamValue) {
                            if (item != null) {
                                g.writeString(item);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                    case USER_MUST_BE_ACTIVE_TO_BE_OWNER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_must_be_active_to_be_owner");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupMembersAddError> _reader = new JsonReader<GroupMembersAddError>()
        {
            public final GroupMembersAddError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case GROUP_NOT_FOUND: return GroupMembersAddError.groupNotFound();
                        case OTHER: return GroupMembersAddError.other();
                        case DUPLICATE_USER: return GroupMembersAddError.duplicateUser();
                        case GROUP_NOT_IN_TEAM: return GroupMembersAddError.groupNotInTeam();
                        case USER_MUST_BE_ACTIVE_TO_BE_OWNER: return GroupMembersAddError.userMustBeActiveToBeOwner();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupMembersAddError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_FOUND: {
                            value = GroupMembersAddError.groupNotFound();
                            break;
                        }
                        case OTHER: {
                            value = GroupMembersAddError.other();
                            break;
                        }
                        case DUPLICATE_USER: {
                            value = GroupMembersAddError.duplicateUser();
                            break;
                        }
                        case GROUP_NOT_IN_TEAM: {
                            value = GroupMembersAddError.groupNotInTeam();
                            break;
                        }
                        case MEMBERS_NOT_IN_TEAM: {
                            java.util.List<String> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(JsonReader.StringReader)
                                .readField(parser, "members_not_in_team", v);
                            value = GroupMembersAddError.membersNotInTeam(v);
                            break;
                        }
                        case USERS_NOT_FOUND: {
                            java.util.List<String> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(JsonReader.StringReader)
                                .readField(parser, "users_not_found", v);
                            value = GroupMembersAddError.usersNotFound(v);
                            break;
                        }
                        case USER_MUST_BE_ACTIVE_TO_BE_OWNER: {
                            value = GroupMembersAddError.userMustBeActiveToBeOwner();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("duplicate_user", Tag.DUPLICATE_USER);
            _values.put("group_not_in_team", Tag.GROUP_NOT_IN_TEAM);
            _values.put("members_not_in_team", Tag.MEMBERS_NOT_IN_TEAM);
            _values.put("users_not_found", Tag.USERS_NOT_FOUND);
            _values.put("user_must_be_active_to_be_owner", Tag.USER_MUST_BE_ACTIVE_TO_BE_OWNER);
        }

        public String toString() {
            return "GroupMembersAddError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupMembersAddError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupMembersAddError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupMembersRemoveArg {
        // struct GroupMembersRemoveArg
        public final GroupSelector group;
        public final java.util.List<UserSelectorArg> users;

        /**
         *
         * @param group  . {@code group} must not be {@code null}.
         * @param users  . {@code users} must not contain a {@code null} item
         *     and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupMembersRemoveArg(GroupSelector group, java.util.List<UserSelectorArg> users) {
            this.group = group;
            if (group == null) {
                throw new IllegalArgumentException("Required value for 'group' is null");
            }
            this.users = users;
            if (users == null) {
                throw new IllegalArgumentException("Required value for 'users' is null");
            }
            for (UserSelectorArg x : users) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'users' is null");
                }
            }
        }

        static final JsonWriter<GroupMembersRemoveArg> _writer = new JsonWriter<GroupMembersRemoveArg>()
        {
            public final void write(GroupMembersRemoveArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupMembersRemoveArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupMembersRemoveArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("group");
                GroupSelector._writer.write(x.group, g);
                g.writeFieldName("users");
                g.writeStartArray();
                for (UserSelectorArg item: x.users) {
                    if (item != null) {
                        UserSelectorArg._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<GroupMembersRemoveArg> _reader = new JsonReader<GroupMembersRemoveArg>() {

            public final GroupMembersRemoveArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupMembersRemoveArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupMembersRemoveArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupSelector group = null;
                java.util.List<UserSelectorArg> users = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group".equals(fieldName)) {
                        group = GroupSelector._reader
                            .readField(parser, "group", group);
                    }
                    else if ("users".equals(fieldName)) {
                        users = JsonArrayReader.mk(UserSelectorArg._reader)
                            .readField(parser, "users", users);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (group == null) {
                    throw new JsonReadException("Required field \"group\" is missing.", parser.getTokenLocation());
                }
                if (users == null) {
                    throw new JsonReadException("Required field \"users\" is missing.", parser.getTokenLocation());
                }
                return new GroupMembersRemoveArg(group, users);
            }
        };

        public String toString() {
            return "GroupMembersRemoveArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupMembersRemoveArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupMembersRemoveArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupMembersRemoveError {
        // union GroupMembersRemoveError

        /**
         * The discriminating tag type for {@link GroupMembersRemoveError}.
         */
        public enum Tag {
            /**
             * No matching group found. No groups match the specified group ID.
             */
            GROUP_NOT_FOUND,
            OTHER,
            /**
             * At least one of the specified users is not a member of the group.
             */
            MEMBER_NOT_IN_GROUP,
            /**
             * Group is not in this team. You cannot remove members from a group
             * that is outside of your team.
             */
            GROUP_NOT_IN_TEAM
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupMembersRemoveError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching group found. No groups match the specified group ID.
         */
        private static final GroupMembersRemoveError GROUP_NOT_FOUND_INSTANCE = new GroupMembersRemoveError(Tag.GROUP_NOT_FOUND);

        /**
         * Returns an instance of {@code GroupMembersRemoveError} that has its
         * tag set to {@link Tag#GROUP_NOT_FOUND}.
         *
         * <p> No matching group found. No groups match the specified group ID.
         * </p>
         *
         * @return Instance of {@code GroupMembersRemoveError} with its tag set
         *     to {@link Tag#GROUP_NOT_FOUND}.
         */
        public static GroupMembersRemoveError groupNotFound() {
            return GroupMembersRemoveError.GROUP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isGroupNotFound() {
            return this.tag == Tag.GROUP_NOT_FOUND;
        }

        private static final GroupMembersRemoveError OTHER_INSTANCE = new GroupMembersRemoveError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupMembersRemoveError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> None </p>
         *
         * @return Instance of {@code GroupMembersRemoveError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static GroupMembersRemoveError other() {
            return GroupMembersRemoveError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * At least one of the specified users is not a member of the group.
         */
        private static final GroupMembersRemoveError MEMBER_NOT_IN_GROUP_INSTANCE = new GroupMembersRemoveError(Tag.MEMBER_NOT_IN_GROUP);

        /**
         * Returns an instance of {@code GroupMembersRemoveError} that has its
         * tag set to {@link Tag#MEMBER_NOT_IN_GROUP}.
         *
         * <p> At least one of the specified users is not a member of the group.
         * </p>
         *
         * @return Instance of {@code GroupMembersRemoveError} with its tag set
         *     to {@link Tag#MEMBER_NOT_IN_GROUP}.
         */
        public static GroupMembersRemoveError memberNotInGroup() {
            return GroupMembersRemoveError.MEMBER_NOT_IN_GROUP_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_NOT_IN_GROUP}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_NOT_IN_GROUP}, {@code false} otherwise.
         */
        public boolean isMemberNotInGroup() {
            return this.tag == Tag.MEMBER_NOT_IN_GROUP;
        }

        /**
         * Group is not in this team. You cannot remove members from a group
         * that is outside of your team.
         */
        private static final GroupMembersRemoveError GROUP_NOT_IN_TEAM_INSTANCE = new GroupMembersRemoveError(Tag.GROUP_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code GroupMembersRemoveError} that has its
         * tag set to {@link Tag#GROUP_NOT_IN_TEAM}.
         *
         * <p> Group is not in this team. You cannot remove members from a group
         * that is outside of your team. </p>
         *
         * @return Instance of {@code GroupMembersRemoveError} with its tag set
         *     to {@link Tag#GROUP_NOT_IN_TEAM}.
         */
        public static GroupMembersRemoveError groupNotInTeam() {
            return GroupMembersRemoveError.GROUP_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#GROUP_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#GROUP_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isGroupNotInTeam() {
            return this.tag == Tag.GROUP_NOT_IN_TEAM;
        }

        private GroupMembersRemoveError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case GROUP_NOT_FOUND:
                case OTHER:
                case MEMBER_NOT_IN_GROUP:
                case GROUP_NOT_IN_TEAM:
                    break;
            }
        }

        static final JsonWriter<GroupMembersRemoveError> _writer = new JsonWriter<GroupMembersRemoveError>()
        {
            public final void write(GroupMembersRemoveError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case GROUP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case MEMBER_NOT_IN_GROUP:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_not_in_group");
                        g.writeEndObject();
                        break;
                    case GROUP_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("group_not_in_team");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupMembersRemoveError> _reader = new JsonReader<GroupMembersRemoveError>()
        {
            public final GroupMembersRemoveError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case GROUP_NOT_FOUND: return GroupMembersRemoveError.groupNotFound();
                        case OTHER: return GroupMembersRemoveError.other();
                        case MEMBER_NOT_IN_GROUP: return GroupMembersRemoveError.memberNotInGroup();
                        case GROUP_NOT_IN_TEAM: return GroupMembersRemoveError.groupNotInTeam();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupMembersRemoveError value = null;
                if (tag != null) {
                    switch (tag) {
                        case GROUP_NOT_FOUND: {
                            value = GroupMembersRemoveError.groupNotFound();
                            break;
                        }
                        case OTHER: {
                            value = GroupMembersRemoveError.other();
                            break;
                        }
                        case MEMBER_NOT_IN_GROUP: {
                            value = GroupMembersRemoveError.memberNotInGroup();
                            break;
                        }
                        case GROUP_NOT_IN_TEAM: {
                            value = GroupMembersRemoveError.groupNotInTeam();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("group_not_in_team", Tag.GROUP_NOT_IN_TEAM);
        }

        public String toString() {
            return "GroupMembersRemoveError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupMembersRemoveError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupMembersRemoveError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class GroupMembersSetAccessTypeArg extends GroupMemberSelector  {
        // struct GroupMembersSetAccessTypeArg
        /**
         * New group access type the user will have.
         */
        public final GroupAccessType accessType;

        /**
         *
         * @param group  Specify a group. {@code group} must not be {@code
         *     null}.
         * @param user  Identity of a user that is a member of {@code group}.
         *     {@code user} must not be {@code null}.
         * @param accessType  New group access type the user will have. {@code
         *     accessType} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GroupMembersSetAccessTypeArg(GroupSelector group, UserSelectorArg user, GroupAccessType accessType) {
            super(group, user);
            this.accessType = accessType;
            if (accessType == null) {
                throw new IllegalArgumentException("Required value for 'accessType' is null");
            }
        }

        static final JsonWriter<GroupMembersSetAccessTypeArg> _writer = new JsonWriter<GroupMembersSetAccessTypeArg>()
        {
            public final void write(GroupMembersSetAccessTypeArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                GroupMemberSelector._writer.writeFields(x, g);
                GroupMembersSetAccessTypeArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GroupMembersSetAccessTypeArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("access_type");
                GroupAccessType._writer.write(x.accessType, g);
            }
        };

        public static final JsonReader<GroupMembersSetAccessTypeArg> _reader = new JsonReader<GroupMembersSetAccessTypeArg>() {

            public final GroupMembersSetAccessTypeArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupMembersSetAccessTypeArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GroupMembersSetAccessTypeArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                GroupSelector group = null;
                UserSelectorArg user = null;
                GroupAccessType accessType = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("group".equals(fieldName)) {
                        group = GroupSelector._reader
                            .readField(parser, "group", group);
                    }
                    else if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else if ("access_type".equals(fieldName)) {
                        accessType = GroupAccessType._reader
                            .readField(parser, "access_type", accessType);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (group == null) {
                    throw new JsonReadException("Required field \"group\" is missing.", parser.getTokenLocation());
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                if (accessType == null) {
                    throw new JsonReadException("Required field \"access_type\" is missing.", parser.getTokenLocation());
                }
                return new GroupMembersSetAccessTypeArg(group, user, accessType);
            }
        };

        public String toString() {
            return "GroupMembersSetAccessTypeArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GroupMembersSetAccessTypeArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GroupMembersSetAccessTypeArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class GroupsPollError {
        // union GroupsPollError

        /**
         * The discriminating tag type for {@link GroupsPollError}.
         */
        public enum Tag {
            /**
             * The job ID is invalid.
             */
            INVALID_ASYNC_JOB_ID,
            /**
             * Something went wrong with the job on Dropbox's end. You'll need
             * to verify that the action you were taking succeeded, and if not,
             * try again. This should happen very rarely.
             */
            INTERNAL_ERROR,
            /**
             * An unspecified error.
             */
            OTHER,
            /**
             * You are not allowed to poll this job.
             */
            ACCESS_DENIED
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code GroupsPollError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * The job ID is invalid.
         */
        private static final GroupsPollError INVALID_ASYNC_JOB_ID_INSTANCE = new GroupsPollError(Tag.INVALID_ASYNC_JOB_ID);

        /**
         * Returns an instance of {@code GroupsPollError} that has its tag set
         * to {@link Tag#INVALID_ASYNC_JOB_ID}.
         *
         * <p> The job ID is invalid. </p>
         *
         * @return Instance of {@code GroupsPollError} with its tag set to
         *     {@link Tag#INVALID_ASYNC_JOB_ID}.
         */
        public static GroupsPollError invalidAsyncJobId() {
            return GroupsPollError.INVALID_ASYNC_JOB_ID_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#INVALID_ASYNC_JOB_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#INVALID_ASYNC_JOB_ID}, {@code false} otherwise.
         */
        public boolean isInvalidAsyncJobId() {
            return this.tag == Tag.INVALID_ASYNC_JOB_ID;
        }

        /**
         * Something went wrong with the job on Dropbox's end. You'll need to
         * verify that the action you were taking succeeded, and if not, try
         * again. This should happen very rarely.
         */
        private static final GroupsPollError INTERNAL_ERROR_INSTANCE = new GroupsPollError(Tag.INTERNAL_ERROR);

        /**
         * Returns an instance of {@code GroupsPollError} that has its tag set
         * to {@link Tag#INTERNAL_ERROR}.
         *
         * <p> Something went wrong with the job on Dropbox's end. You'll need
         * to verify that the action you were taking succeeded, and if not, try
         * again. This should happen very rarely. </p>
         *
         * @return Instance of {@code GroupsPollError} with its tag set to
         *     {@link Tag#INTERNAL_ERROR}.
         */
        public static GroupsPollError internalError() {
            return GroupsPollError.INTERNAL_ERROR_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#INTERNAL_ERROR}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#INTERNAL_ERROR}, {@code false} otherwise.
         */
        public boolean isInternalError() {
            return this.tag == Tag.INTERNAL_ERROR;
        }

        /**
         * An unspecified error.
         */
        private static final GroupsPollError OTHER_INSTANCE = new GroupsPollError(Tag.OTHER);

        /**
         * Returns an instance of {@code GroupsPollError} that has its tag set
         * to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code GroupsPollError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static GroupsPollError other() {
            return GroupsPollError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * You are not allowed to poll this job.
         */
        private static final GroupsPollError ACCESS_DENIED_INSTANCE = new GroupsPollError(Tag.ACCESS_DENIED);

        /**
         * Returns an instance of {@code GroupsPollError} that has its tag set
         * to {@link Tag#ACCESS_DENIED}.
         *
         * <p> You are not allowed to poll this job. </p>
         *
         * @return Instance of {@code GroupsPollError} with its tag set to
         *     {@link Tag#ACCESS_DENIED}.
         */
        public static GroupsPollError accessDenied() {
            return GroupsPollError.ACCESS_DENIED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#ACCESS_DENIED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#ACCESS_DENIED}, {@code false} otherwise.
         */
        public boolean isAccessDenied() {
            return this.tag == Tag.ACCESS_DENIED;
        }

        private GroupsPollError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case INVALID_ASYNC_JOB_ID:
                case INTERNAL_ERROR:
                case OTHER:
                case ACCESS_DENIED:
                    break;
            }
        }

        static final JsonWriter<GroupsPollError> _writer = new JsonWriter<GroupsPollError>()
        {
            public final void write(GroupsPollError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case INVALID_ASYNC_JOB_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("invalid_async_job_id");
                        g.writeEndObject();
                        break;
                    case INTERNAL_ERROR:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("internal_error");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case ACCESS_DENIED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("access_denied");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<GroupsPollError> _reader = new JsonReader<GroupsPollError>()
        {
            public final GroupsPollError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case INVALID_ASYNC_JOB_ID: return GroupsPollError.invalidAsyncJobId();
                        case INTERNAL_ERROR: return GroupsPollError.internalError();
                        case OTHER: return GroupsPollError.other();
                        case ACCESS_DENIED: return GroupsPollError.accessDenied();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                GroupsPollError value = null;
                if (tag != null) {
                    switch (tag) {
                        case INVALID_ASYNC_JOB_ID: {
                            value = GroupsPollError.invalidAsyncJobId();
                            break;
                        }
                        case INTERNAL_ERROR: {
                            value = GroupsPollError.internalError();
                            break;
                        }
                        case OTHER: {
                            value = GroupsPollError.other();
                            break;
                        }
                        case ACCESS_DENIED: {
                            value = GroupsPollError.accessDenied();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("access_denied", Tag.ACCESS_DENIED);
        }

        public String toString() {
            return "GroupsPollError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "GroupsPollError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static GroupsPollError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class ListMemberAppsArg {
        // struct ListMemberAppsArg
        /**
         * The team member id
         */
        public final String teamMemberId;

        /**
         *
         * @param teamMemberId  The team member id. {@code teamMemberId} must
         *     not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ListMemberAppsArg(String teamMemberId) {
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
        }

        static final JsonWriter<ListMemberAppsArg> _writer = new JsonWriter<ListMemberAppsArg>()
        {
            public final void write(ListMemberAppsArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListMemberAppsArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListMemberAppsArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("team_member_id", x.teamMemberId);
            }
        };

        public static final JsonReader<ListMemberAppsArg> _reader = new JsonReader<ListMemberAppsArg>() {

            public final ListMemberAppsArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListMemberAppsArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListMemberAppsArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String teamMemberId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                return new ListMemberAppsArg(teamMemberId);
            }
        };

        public String toString() {
            return "ListMemberAppsArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListMemberAppsArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListMemberAppsArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information on linked third party applications
     */
    public static class ApiApp {
        // struct ApiApp
        /**
         * The application unique id
         */
        public final String appId;
        /**
         * The application name
         */
        public final String appName;
        /**
         * The application publisher name
         */
        public final String publisher;
        /**
         * The publisher's URL
         */
        public final String publisherUrl;
        /**
         * The time this application was linked
         */
        public final java.util.Date linked;
        /**
         * Whether the linked application uses a dedicated folder
         */
        public final boolean isAppFolder;

        /**
         * Information on linked third party applications
         *
         * @param appId  The application unique id. {@code appId} must not be
         *     {@code null}.
         * @param appName  The application name. {@code appName} must not be
         *     {@code null}.
         * @param isAppFolder  Whether the linked application uses a dedicated
         *     folder.
         * @param publisher  The application publisher name.
         * @param publisherUrl  The publisher's URL.
         * @param linked  The time this application was linked.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ApiApp(String appId, String appName, boolean isAppFolder, String publisher, String publisherUrl, java.util.Date linked) {
            this.appId = appId;
            if (appId == null) {
                throw new IllegalArgumentException("Required value for 'appId' is null");
            }
            this.appName = appName;
            if (appName == null) {
                throw new IllegalArgumentException("Required value for 'appName' is null");
            }
            this.publisher = publisher;
            this.publisherUrl = publisherUrl;
            this.linked = linked;
            this.isAppFolder = isAppFolder;
        }

        static final JsonWriter<ApiApp> _writer = new JsonWriter<ApiApp>()
        {
            public final void write(ApiApp x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ApiApp._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ApiApp x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("app_id", x.appId);
                g.writeStringField("app_name", x.appName);
                if (x.publisher != null) {
                    g.writeFieldName("publisher");
                    g.writeString(x.publisher);
                }
                if (x.publisherUrl != null) {
                    g.writeFieldName("publisher_url");
                    g.writeString(x.publisherUrl);
                }
                if (x.linked != null) {
                    g.writeFieldName("linked");
                    writeDateIso(x.linked, g);
                }
                g.writeBooleanField("is_app_folder", x.isAppFolder);
            }
        };

        public static final JsonReader<ApiApp> _reader = new JsonReader<ApiApp>() {

            public final ApiApp read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ApiApp result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ApiApp readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String appId = null;
                String appName = null;
                Boolean isAppFolder = null;
                String publisher = null;
                String publisherUrl = null;
                java.util.Date linked = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("app_id".equals(fieldName)) {
                        appId = JsonReader.StringReader
                            .readField(parser, "app_id", appId);
                    }
                    else if ("app_name".equals(fieldName)) {
                        appName = JsonReader.StringReader
                            .readField(parser, "app_name", appName);
                    }
                    else if ("is_app_folder".equals(fieldName)) {
                        isAppFolder = JsonReader.BooleanReader
                            .readField(parser, "is_app_folder", isAppFolder);
                    }
                    else if ("publisher".equals(fieldName)) {
                        publisher = JsonReader.StringReader
                            .readField(parser, "publisher", publisher);
                    }
                    else if ("publisher_url".equals(fieldName)) {
                        publisherUrl = JsonReader.StringReader
                            .readField(parser, "publisher_url", publisherUrl);
                    }
                    else if ("linked".equals(fieldName)) {
                        linked = JsonDateReader.DropboxV2
                            .readField(parser, "linked", linked);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (appId == null) {
                    throw new JsonReadException("Required field \"app_id\" is missing.", parser.getTokenLocation());
                }
                if (appName == null) {
                    throw new JsonReadException("Required field \"app_name\" is missing.", parser.getTokenLocation());
                }
                if (isAppFolder == null) {
                    throw new JsonReadException("Required field \"is_app_folder\" is missing.", parser.getTokenLocation());
                }
                return new ApiApp(appId, appName, isAppFolder, publisher, publisherUrl, linked);
            }
        };

        public String toString() {
            return "ApiApp." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ApiApp." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ApiApp fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class ListMemberAppsResult {
        // struct ListMemberAppsResult
        /**
         * List of third party applications linked by this team member
         */
        public final java.util.List<ApiApp> linkedApiApps;

        /**
         *
         * @param linkedApiApps  List of third party applications linked by this
         *     team member. {@code linkedApiApps} must not contain a {@code
         *     null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ListMemberAppsResult(java.util.List<ApiApp> linkedApiApps) {
            this.linkedApiApps = linkedApiApps;
            if (linkedApiApps == null) {
                throw new IllegalArgumentException("Required value for 'linkedApiApps' is null");
            }
            for (ApiApp x : linkedApiApps) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'linkedApiApps' is null");
                }
            }
        }

        static final JsonWriter<ListMemberAppsResult> _writer = new JsonWriter<ListMemberAppsResult>()
        {
            public final void write(ListMemberAppsResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListMemberAppsResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListMemberAppsResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("linked_api_apps");
                g.writeStartArray();
                for (ApiApp item: x.linkedApiApps) {
                    if (item != null) {
                        ApiApp._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<ListMemberAppsResult> _reader = new JsonReader<ListMemberAppsResult>() {

            public final ListMemberAppsResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListMemberAppsResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListMemberAppsResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<ApiApp> linkedApiApps = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("linked_api_apps".equals(fieldName)) {
                        linkedApiApps = JsonArrayReader.mk(ApiApp._reader)
                            .readField(parser, "linked_api_apps", linkedApiApps);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (linkedApiApps == null) {
                    throw new JsonReadException("Required field \"linked_api_apps\" is missing.", parser.getTokenLocation());
                }
                return new ListMemberAppsResult(linkedApiApps);
            }
        };

        public String toString() {
            return "ListMemberAppsResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListMemberAppsResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListMemberAppsResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error returned by {@link DbxTeam#linkedAppsListMemberLinkedApps(String)}.
     */
    public static final class ListMemberAppsError {
        // union ListMemberAppsError

        /**
         * The discriminating tag type for {@link ListMemberAppsError}.
         */
        public enum Tag {
            /**
             * Member not found.
             */
            MEMBER_NOT_FOUND,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code ListMemberAppsError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Member not found.
         */
        private static final ListMemberAppsError MEMBER_NOT_FOUND_INSTANCE = new ListMemberAppsError(Tag.MEMBER_NOT_FOUND);

        /**
         * Returns an instance of {@code ListMemberAppsError} that has its tag
         * set to {@link Tag#MEMBER_NOT_FOUND}.
         *
         * <p> Member not found. </p>
         *
         * @return Instance of {@code ListMemberAppsError} with its tag set to
         *     {@link Tag#MEMBER_NOT_FOUND}.
         */
        public static ListMemberAppsError memberNotFound() {
            return ListMemberAppsError.MEMBER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isMemberNotFound() {
            return this.tag == Tag.MEMBER_NOT_FOUND;
        }

        /**
         * An unspecified error.
         */
        private static final ListMemberAppsError OTHER_INSTANCE = new ListMemberAppsError(Tag.OTHER);

        /**
         * Returns an instance of {@code ListMemberAppsError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code ListMemberAppsError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static ListMemberAppsError other() {
            return ListMemberAppsError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private ListMemberAppsError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case MEMBER_NOT_FOUND:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<ListMemberAppsError> _writer = new JsonWriter<ListMemberAppsError>()
        {
            public final void write(ListMemberAppsError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case MEMBER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<ListMemberAppsError> _reader = new JsonReader<ListMemberAppsError>()
        {
            public final ListMemberAppsError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return ListMemberAppsError.other(); }
                    switch (tag) {
                        case MEMBER_NOT_FOUND: return ListMemberAppsError.memberNotFound();
                        case OTHER: return ListMemberAppsError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                ListMemberAppsError value = null;
                if (tag != null) {
                    switch (tag) {
                        case MEMBER_NOT_FOUND: {
                            value = ListMemberAppsError.memberNotFound();
                            break;
                        }
                        case OTHER: {
                            value = ListMemberAppsError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return ListMemberAppsError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("member_not_found", Tag.MEMBER_NOT_FOUND);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "ListMemberAppsError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "ListMemberAppsError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static ListMemberAppsError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Arguments for {@link DbxTeam#linkedAppsListTeamLinkedApps(String)}.
     */
    public static class ListTeamAppsArg {
        // struct ListTeamAppsArg
        /**
         * At the first call to the {@link
         * DbxTeam#linkedAppsListTeamLinkedApps(String)} the cursor shouldn't be
         * passed. Then, if the result of the call includes a cursor, the
         * following requests should include the received cursors in order to
         * receive the next sub list of the team applications
         */
        public final String cursor;

        /**
         * Arguments for {@link DbxTeam#linkedAppsListTeamLinkedApps(String)}.
         *
         * @param cursor  At the first call to the {@link
         *     DbxTeam#linkedAppsListTeamLinkedApps(String)} the cursor
         *     shouldn't be passed. Then, if the result of the call includes a
         *     cursor, the following requests should include the received
         *     cursors in order to receive the next sub list of the team
         *     applications.
         */
        public ListTeamAppsArg(String cursor) {
            this.cursor = cursor;
        }

        static final JsonWriter<ListTeamAppsArg> _writer = new JsonWriter<ListTeamAppsArg>()
        {
            public final void write(ListTeamAppsArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListTeamAppsArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListTeamAppsArg x, JsonGenerator g)
             throws IOException
            {
                if (x.cursor != null) {
                    g.writeFieldName("cursor");
                    g.writeString(x.cursor);
                }
            }
        };

        public static final JsonReader<ListTeamAppsArg> _reader = new JsonReader<ListTeamAppsArg>() {

            public final ListTeamAppsArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListTeamAppsArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListTeamAppsArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String cursor = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                return new ListTeamAppsArg(cursor);
            }
        };

        public String toString() {
            return "ListTeamAppsArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListTeamAppsArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListTeamAppsArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information on linked applications of a team member.
     */
    public static class MemberLinkedApps {
        // struct MemberLinkedApps
        /**
         * The member unique Id
         */
        public final String teamMemberId;
        /**
         * List of third party applications linked by this team member
         */
        public final java.util.List<ApiApp> linkedApiApps;

        /**
         * Information on linked applications of a team member.
         *
         * @param teamMemberId  The member unique Id. {@code teamMemberId} must
         *     not be {@code null}.
         * @param linkedApiApps  List of third party applications linked by this
         *     team member. {@code linkedApiApps} must not contain a {@code
         *     null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MemberLinkedApps(String teamMemberId, java.util.List<ApiApp> linkedApiApps) {
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
            this.linkedApiApps = linkedApiApps;
            if (linkedApiApps == null) {
                throw new IllegalArgumentException("Required value for 'linkedApiApps' is null");
            }
            for (ApiApp x : linkedApiApps) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'linkedApiApps' is null");
                }
            }
        }

        static final JsonWriter<MemberLinkedApps> _writer = new JsonWriter<MemberLinkedApps>()
        {
            public final void write(MemberLinkedApps x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MemberLinkedApps._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MemberLinkedApps x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("team_member_id", x.teamMemberId);
                g.writeFieldName("linked_api_apps");
                g.writeStartArray();
                for (ApiApp item: x.linkedApiApps) {
                    if (item != null) {
                        ApiApp._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<MemberLinkedApps> _reader = new JsonReader<MemberLinkedApps>() {

            public final MemberLinkedApps read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MemberLinkedApps result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MemberLinkedApps readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String teamMemberId = null;
                java.util.List<ApiApp> linkedApiApps = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("linked_api_apps".equals(fieldName)) {
                        linkedApiApps = JsonArrayReader.mk(ApiApp._reader)
                            .readField(parser, "linked_api_apps", linkedApiApps);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                if (linkedApiApps == null) {
                    throw new JsonReadException("Required field \"linked_api_apps\" is missing.", parser.getTokenLocation());
                }
                return new MemberLinkedApps(teamMemberId, linkedApiApps);
            }
        };

        public String toString() {
            return "MemberLinkedApps." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MemberLinkedApps." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MemberLinkedApps fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information returned by {@link
     * DbxTeam#linkedAppsListTeamLinkedApps(String)}.
     */
    public static class ListTeamAppsResult {
        // struct ListTeamAppsResult
        /**
         * The linked applications of each member of the team
         */
        public final java.util.List<MemberLinkedApps> apps;
        /**
         * If true, then there are more apps available. Pass the cursor to
         * {@link DbxTeam#linkedAppsListTeamLinkedApps(String)} to retrieve the
         * rest.
         */
        public final boolean hasMore;
        /**
         * Pass the cursor into {@link
         * DbxTeam#linkedAppsListTeamLinkedApps(String)} to receive the next sub
         * list of team's applications.
         */
        public final String cursor;

        /**
         * Information returned by {@link
         * DbxTeam#linkedAppsListTeamLinkedApps(String)}.
         *
         * @param apps  The linked applications of each member of the team.
         *     {@code apps} must not contain a {@code null} item and not be
         *     {@code null}.
         * @param hasMore  If true, then there are more apps available. Pass the
         *     cursor to {@link DbxTeam#linkedAppsListTeamLinkedApps(String)} to
         *     retrieve the rest.
         * @param cursor  Pass the cursor into {@link
         *     DbxTeam#linkedAppsListTeamLinkedApps(String)} to receive the next
         *     sub list of team's applications.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public ListTeamAppsResult(java.util.List<MemberLinkedApps> apps, boolean hasMore, String cursor) {
            this.apps = apps;
            if (apps == null) {
                throw new IllegalArgumentException("Required value for 'apps' is null");
            }
            for (MemberLinkedApps x : apps) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'apps' is null");
                }
            }
            this.hasMore = hasMore;
            this.cursor = cursor;
        }

        static final JsonWriter<ListTeamAppsResult> _writer = new JsonWriter<ListTeamAppsResult>()
        {
            public final void write(ListTeamAppsResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                ListTeamAppsResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(ListTeamAppsResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("apps");
                g.writeStartArray();
                for (MemberLinkedApps item: x.apps) {
                    if (item != null) {
                        MemberLinkedApps._writer.write(item, g);
                    }
                }
                g.writeEndArray();
                g.writeBooleanField("has_more", x.hasMore);
                if (x.cursor != null) {
                    g.writeFieldName("cursor");
                    g.writeString(x.cursor);
                }
            }
        };

        public static final JsonReader<ListTeamAppsResult> _reader = new JsonReader<ListTeamAppsResult>() {

            public final ListTeamAppsResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                ListTeamAppsResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final ListTeamAppsResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<MemberLinkedApps> apps = null;
                Boolean hasMore = null;
                String cursor = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("apps".equals(fieldName)) {
                        apps = JsonArrayReader.mk(MemberLinkedApps._reader)
                            .readField(parser, "apps", apps);
                    }
                    else if ("has_more".equals(fieldName)) {
                        hasMore = JsonReader.BooleanReader
                            .readField(parser, "has_more", hasMore);
                    }
                    else if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (apps == null) {
                    throw new JsonReadException("Required field \"apps\" is missing.", parser.getTokenLocation());
                }
                if (hasMore == null) {
                    throw new JsonReadException("Required field \"has_more\" is missing.", parser.getTokenLocation());
                }
                return new ListTeamAppsResult(apps, hasMore, cursor);
            }
        };

        public String toString() {
            return "ListTeamAppsResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "ListTeamAppsResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static ListTeamAppsResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error returned by {@link DbxTeam#linkedAppsListTeamLinkedApps(String)}
     */
    public static final class ListTeamAppsError {
        // union ListTeamAppsError

        /**
         * The discriminating tag type for {@link ListTeamAppsError}.
         */
        public enum Tag {
            /**
             * Indicates that the cursor has been invalidated. Call {@link
             * DbxTeam#linkedAppsListTeamLinkedApps(String)} again with an empty
             * cursor to obtain a new cursor.
             */
            RESET,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code ListTeamAppsError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Indicates that the cursor has been invalidated. Call {@link
         * DbxTeam#linkedAppsListTeamLinkedApps(String)} again with an empty
         * cursor to obtain a new cursor.
         */
        private static final ListTeamAppsError RESET_INSTANCE = new ListTeamAppsError(Tag.RESET);

        /**
         * Returns an instance of {@code ListTeamAppsError} that has its tag set
         * to {@link Tag#RESET}.
         *
         * <p> Indicates that the cursor has been invalidated. Call {@link
         * DbxTeam#linkedAppsListTeamLinkedApps(String)} again with an empty
         * cursor to obtain a new cursor. </p>
         *
         * @return Instance of {@code ListTeamAppsError} with its tag set to
         *     {@link Tag#RESET}.
         */
        public static ListTeamAppsError reset() {
            return ListTeamAppsError.RESET_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#RESET},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#RESET},
         *     {@code false} otherwise.
         */
        public boolean isReset() {
            return this.tag == Tag.RESET;
        }

        /**
         * An unspecified error.
         */
        private static final ListTeamAppsError OTHER_INSTANCE = new ListTeamAppsError(Tag.OTHER);

        /**
         * Returns an instance of {@code ListTeamAppsError} that has its tag set
         * to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code ListTeamAppsError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static ListTeamAppsError other() {
            return ListTeamAppsError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private ListTeamAppsError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case RESET:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<ListTeamAppsError> _writer = new JsonWriter<ListTeamAppsError>()
        {
            public final void write(ListTeamAppsError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case RESET:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("reset");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<ListTeamAppsError> _reader = new JsonReader<ListTeamAppsError>()
        {
            public final ListTeamAppsError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return ListTeamAppsError.other(); }
                    switch (tag) {
                        case RESET: return ListTeamAppsError.reset();
                        case OTHER: return ListTeamAppsError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                ListTeamAppsError value = null;
                if (tag != null) {
                    switch (tag) {
                        case RESET: {
                            value = ListTeamAppsError.reset();
                            break;
                        }
                        case OTHER: {
                            value = ListTeamAppsError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return ListTeamAppsError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("reset", Tag.RESET);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "ListTeamAppsError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "ListTeamAppsError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static ListTeamAppsError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeLinkedApiAppArg {
        // struct RevokeLinkedApiAppArg
        /**
         * The application's unique id
         */
        public final String appId;
        /**
         * The unique id of the member owning the device
         */
        public final String teamMemberId;
        /**
         * Whether to keep the application dedicated folder (in case the
         * application uses  one)
         */
        public final boolean keepAppFolder;

        /**
         *
         * @param appId  The application's unique id. {@code appId} must not be
         *     {@code null}.
         * @param teamMemberId  The unique id of the member owning the device.
         *     {@code teamMemberId} must not be {@code null}.
         * @param keepAppFolder  Whether to keep the application dedicated
         *     folder (in case the application uses  one).
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public RevokeLinkedApiAppArg(String appId, String teamMemberId, Boolean keepAppFolder) {
            this.appId = appId;
            if (appId == null) {
                throw new IllegalArgumentException("Required value for 'appId' is null");
            }
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
            if (keepAppFolder != null) {
                this.keepAppFolder = keepAppFolder.booleanValue();
            }
            else {
                this.keepAppFolder = true;
            }
        }

        static final JsonWriter<RevokeLinkedApiAppArg> _writer = new JsonWriter<RevokeLinkedApiAppArg>()
        {
            public final void write(RevokeLinkedApiAppArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                RevokeLinkedApiAppArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeLinkedApiAppArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("app_id", x.appId);
                g.writeStringField("team_member_id", x.teamMemberId);
                g.writeBooleanField("keep_app_folder", x.keepAppFolder);
            }
        };

        public static final JsonReader<RevokeLinkedApiAppArg> _reader = new JsonReader<RevokeLinkedApiAppArg>() {

            public final RevokeLinkedApiAppArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeLinkedApiAppArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeLinkedApiAppArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String appId = null;
                String teamMemberId = null;
                Boolean keepAppFolder = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("app_id".equals(fieldName)) {
                        appId = JsonReader.StringReader
                            .readField(parser, "app_id", appId);
                    }
                    else if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("keep_app_folder".equals(fieldName)) {
                        keepAppFolder = JsonReader.BooleanReader
                            .readField(parser, "keep_app_folder", keepAppFolder);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (appId == null) {
                    throw new JsonReadException("Required field \"app_id\" is missing.", parser.getTokenLocation());
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                return new RevokeLinkedApiAppArg(appId, teamMemberId, keepAppFolder);
            }
        };

        public String toString() {
            return "RevokeLinkedApiAppArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeLinkedApiAppArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeLinkedApiAppArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error returned by {@link
     * DbxTeam#linkedAppsRevokeLinkedApp(String,String,boolean)}.
     */
    public static final class RevokeLinkedAppError {
        // union RevokeLinkedAppError

        /**
         * The discriminating tag type for {@link RevokeLinkedAppError}.
         */
        public enum Tag {
            /**
             * Application not found.
             */
            APP_NOT_FOUND,
            /**
             * Member not found.
             */
            MEMBER_NOT_FOUND,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code RevokeLinkedAppError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * Application not found.
         */
        private static final RevokeLinkedAppError APP_NOT_FOUND_INSTANCE = new RevokeLinkedAppError(Tag.APP_NOT_FOUND);

        /**
         * Returns an instance of {@code RevokeLinkedAppError} that has its tag
         * set to {@link Tag#APP_NOT_FOUND}.
         *
         * <p> Application not found. </p>
         *
         * @return Instance of {@code RevokeLinkedAppError} with its tag set to
         *     {@link Tag#APP_NOT_FOUND}.
         */
        public static RevokeLinkedAppError appNotFound() {
            return RevokeLinkedAppError.APP_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#APP_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#APP_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isAppNotFound() {
            return this.tag == Tag.APP_NOT_FOUND;
        }

        /**
         * Member not found.
         */
        private static final RevokeLinkedAppError MEMBER_NOT_FOUND_INSTANCE = new RevokeLinkedAppError(Tag.MEMBER_NOT_FOUND);

        /**
         * Returns an instance of {@code RevokeLinkedAppError} that has its tag
         * set to {@link Tag#MEMBER_NOT_FOUND}.
         *
         * <p> Member not found. </p>
         *
         * @return Instance of {@code RevokeLinkedAppError} with its tag set to
         *     {@link Tag#MEMBER_NOT_FOUND}.
         */
        public static RevokeLinkedAppError memberNotFound() {
            return RevokeLinkedAppError.MEMBER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isMemberNotFound() {
            return this.tag == Tag.MEMBER_NOT_FOUND;
        }

        /**
         * An unspecified error.
         */
        private static final RevokeLinkedAppError OTHER_INSTANCE = new RevokeLinkedAppError(Tag.OTHER);

        /**
         * Returns an instance of {@code RevokeLinkedAppError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code RevokeLinkedAppError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static RevokeLinkedAppError other() {
            return RevokeLinkedAppError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private RevokeLinkedAppError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case APP_NOT_FOUND:
                case MEMBER_NOT_FOUND:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<RevokeLinkedAppError> _writer = new JsonWriter<RevokeLinkedAppError>()
        {
            public final void write(RevokeLinkedAppError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case APP_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("app_not_found");
                        g.writeEndObject();
                        break;
                    case MEMBER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_not_found");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<RevokeLinkedAppError> _reader = new JsonReader<RevokeLinkedAppError>()
        {
            public final RevokeLinkedAppError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return RevokeLinkedAppError.other(); }
                    switch (tag) {
                        case APP_NOT_FOUND: return RevokeLinkedAppError.appNotFound();
                        case MEMBER_NOT_FOUND: return RevokeLinkedAppError.memberNotFound();
                        case OTHER: return RevokeLinkedAppError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                RevokeLinkedAppError value = null;
                if (tag != null) {
                    switch (tag) {
                        case APP_NOT_FOUND: {
                            value = RevokeLinkedAppError.appNotFound();
                            break;
                        }
                        case MEMBER_NOT_FOUND: {
                            value = RevokeLinkedAppError.memberNotFound();
                            break;
                        }
                        case OTHER: {
                            value = RevokeLinkedAppError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return RevokeLinkedAppError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("app_not_found", Tag.APP_NOT_FOUND);
            _values.put("member_not_found", Tag.MEMBER_NOT_FOUND);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "RevokeLinkedAppError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "RevokeLinkedAppError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static RevokeLinkedAppError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeLinkedApiAppBatchArg {
        // struct RevokeLinkedApiAppBatchArg
        public final java.util.List<RevokeLinkedApiAppArg> revokeLinkedApp;

        /**
         *
         * @param revokeLinkedApp  . {@code revokeLinkedApp} must not contain a
         *     {@code null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public RevokeLinkedApiAppBatchArg(java.util.List<RevokeLinkedApiAppArg> revokeLinkedApp) {
            this.revokeLinkedApp = revokeLinkedApp;
            if (revokeLinkedApp == null) {
                throw new IllegalArgumentException("Required value for 'revokeLinkedApp' is null");
            }
            for (RevokeLinkedApiAppArg x : revokeLinkedApp) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'revokeLinkedApp' is null");
                }
            }
        }

        static final JsonWriter<RevokeLinkedApiAppBatchArg> _writer = new JsonWriter<RevokeLinkedApiAppBatchArg>()
        {
            public final void write(RevokeLinkedApiAppBatchArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                RevokeLinkedApiAppBatchArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeLinkedApiAppBatchArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("revoke_linked_app");
                g.writeStartArray();
                for (RevokeLinkedApiAppArg item: x.revokeLinkedApp) {
                    if (item != null) {
                        RevokeLinkedApiAppArg._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<RevokeLinkedApiAppBatchArg> _reader = new JsonReader<RevokeLinkedApiAppBatchArg>() {

            public final RevokeLinkedApiAppBatchArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeLinkedApiAppBatchArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeLinkedApiAppBatchArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<RevokeLinkedApiAppArg> revokeLinkedApp = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("revoke_linked_app".equals(fieldName)) {
                        revokeLinkedApp = JsonArrayReader.mk(RevokeLinkedApiAppArg._reader)
                            .readField(parser, "revoke_linked_app", revokeLinkedApp);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (revokeLinkedApp == null) {
                    throw new JsonReadException("Required field \"revoke_linked_app\" is missing.", parser.getTokenLocation());
                }
                return new RevokeLinkedApiAppBatchArg(revokeLinkedApp);
            }
        };

        public String toString() {
            return "RevokeLinkedApiAppBatchArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeLinkedApiAppBatchArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeLinkedApiAppBatchArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeLinkedAppStatus {
        // struct RevokeLinkedAppStatus
        /**
         * Result of the revoking request
         */
        public final boolean success;
        /**
         * The error cause in case of a failure
         */
        public final RevokeLinkedAppError errorType;

        /**
         *
         * @param success  Result of the revoking request.
         * @param errorType  The error cause in case of a failure.
         */
        public RevokeLinkedAppStatus(boolean success, RevokeLinkedAppError errorType) {
            this.success = success;
            this.errorType = errorType;
        }

        static final JsonWriter<RevokeLinkedAppStatus> _writer = new JsonWriter<RevokeLinkedAppStatus>()
        {
            public final void write(RevokeLinkedAppStatus x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                RevokeLinkedAppStatus._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeLinkedAppStatus x, JsonGenerator g)
             throws IOException
            {
                g.writeBooleanField("success", x.success);
                if (x.errorType != null) {
                    g.writeFieldName("error_type");
                    RevokeLinkedAppError._writer.write(x.errorType, g);
                }
            }
        };

        public static final JsonReader<RevokeLinkedAppStatus> _reader = new JsonReader<RevokeLinkedAppStatus>() {

            public final RevokeLinkedAppStatus read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeLinkedAppStatus result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeLinkedAppStatus readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                Boolean success = null;
                RevokeLinkedAppError errorType = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("success".equals(fieldName)) {
                        success = JsonReader.BooleanReader
                            .readField(parser, "success", success);
                    }
                    else if ("error_type".equals(fieldName)) {
                        errorType = RevokeLinkedAppError._reader
                            .readField(parser, "error_type", errorType);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (success == null) {
                    throw new JsonReadException("Required field \"success\" is missing.", parser.getTokenLocation());
                }
                return new RevokeLinkedAppStatus(success, errorType);
            }
        };

        public String toString() {
            return "RevokeLinkedAppStatus." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeLinkedAppStatus." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeLinkedAppStatus fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class RevokeLinkedAppBatchResult {
        // struct RevokeLinkedAppBatchResult
        public final java.util.List<RevokeLinkedAppStatus> revokeLinkedAppStatus;

        /**
         *
         * @param revokeLinkedAppStatus  . {@code revokeLinkedAppStatus} must
         *     not contain a {@code null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public RevokeLinkedAppBatchResult(java.util.List<RevokeLinkedAppStatus> revokeLinkedAppStatus) {
            this.revokeLinkedAppStatus = revokeLinkedAppStatus;
            if (revokeLinkedAppStatus == null) {
                throw new IllegalArgumentException("Required value for 'revokeLinkedAppStatus' is null");
            }
            for (RevokeLinkedAppStatus x : revokeLinkedAppStatus) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'revokeLinkedAppStatus' is null");
                }
            }
        }

        static final JsonWriter<RevokeLinkedAppBatchResult> _writer = new JsonWriter<RevokeLinkedAppBatchResult>()
        {
            public final void write(RevokeLinkedAppBatchResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                RevokeLinkedAppBatchResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(RevokeLinkedAppBatchResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("revoke_linked_app_status");
                g.writeStartArray();
                for (RevokeLinkedAppStatus item: x.revokeLinkedAppStatus) {
                    if (item != null) {
                        RevokeLinkedAppStatus._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<RevokeLinkedAppBatchResult> _reader = new JsonReader<RevokeLinkedAppBatchResult>() {

            public final RevokeLinkedAppBatchResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                RevokeLinkedAppBatchResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final RevokeLinkedAppBatchResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<RevokeLinkedAppStatus> revokeLinkedAppStatus = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("revoke_linked_app_status".equals(fieldName)) {
                        revokeLinkedAppStatus = JsonArrayReader.mk(RevokeLinkedAppStatus._reader)
                            .readField(parser, "revoke_linked_app_status", revokeLinkedAppStatus);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (revokeLinkedAppStatus == null) {
                    throw new JsonReadException("Required field \"revoke_linked_app_status\" is missing.", parser.getTokenLocation());
                }
                return new RevokeLinkedAppBatchResult(revokeLinkedAppStatus);
            }
        };

        public String toString() {
            return "RevokeLinkedAppBatchResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "RevokeLinkedAppBatchResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static RevokeLinkedAppBatchResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Error returned by {@link
     * DbxTeam#linkedAppsRevokeLinkedAppBatch(java.util.List)}.
     */
    public static final class RevokeLinkedAppBatchError {
        // union RevokeLinkedAppBatchError

        /**
         * The discriminating tag type for {@link RevokeLinkedAppBatchError}.
         */
        public enum Tag {
            /**
             * An unspecified error.
             */
            UNSPECIFIED  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code RevokeLinkedAppBatchError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * An unspecified error.
         */
        private static final RevokeLinkedAppBatchError UNSPECIFIED_INSTANCE = new RevokeLinkedAppBatchError(Tag.UNSPECIFIED);

        /**
         * Returns an instance of {@code RevokeLinkedAppBatchError} that has its
         * tag set to {@link Tag#UNSPECIFIED}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code RevokeLinkedAppBatchError} with its tag
         *     set to {@link Tag#UNSPECIFIED}.
         */
        public static RevokeLinkedAppBatchError unspecified() {
            return RevokeLinkedAppBatchError.UNSPECIFIED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#UNSPECIFIED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#UNSPECIFIED}, {@code false} otherwise.
         */
        public boolean isUnspecified() {
            return this.tag == Tag.UNSPECIFIED;
        }

        private RevokeLinkedAppBatchError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case UNSPECIFIED:
                    break;
            }
        }

        static final JsonWriter<RevokeLinkedAppBatchError> _writer = new JsonWriter<RevokeLinkedAppBatchError>()
        {
            public final void write(RevokeLinkedAppBatchError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case UNSPECIFIED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("unspecified");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<RevokeLinkedAppBatchError> _reader = new JsonReader<RevokeLinkedAppBatchError>()
        {
            public final RevokeLinkedAppBatchError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return RevokeLinkedAppBatchError.unspecified(); }
                    switch (tag) {
                        case UNSPECIFIED: return RevokeLinkedAppBatchError.unspecified();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                RevokeLinkedAppBatchError value = null;
                if (tag != null) {
                    switch (tag) {
                        case UNSPECIFIED: {
                            value = RevokeLinkedAppBatchError.unspecified();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return RevokeLinkedAppBatchError.unspecified(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("unspecified", Tag.UNSPECIFIED);
        }

        public String toString() {
            return "RevokeLinkedAppBatchError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "RevokeLinkedAppBatchError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static RevokeLinkedAppBatchError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Describes which team-related admin permissions a user has.
     */
    public static final class AdminTier {
        // union AdminTier

        /**
         * The discriminating tag type for {@link AdminTier}.
         */
        public enum Tag {
            /**
             * User is an administrator of the team - has all permissions.
             */
            TEAM_ADMIN,
            /**
             * User can do most user provisioning, de-provisioning and
             * management.
             */
            USER_MANAGEMENT_ADMIN,
            /**
             * User can do a limited set of common support tasks for existing
             * users.
             */
            SUPPORT_ADMIN,
            /**
             * User is not an admin of the team.
             */
            MEMBER_ONLY
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code AdminTier}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * User is an administrator of the team - has all permissions.
         */
        private static final AdminTier TEAM_ADMIN_INSTANCE = new AdminTier(Tag.TEAM_ADMIN);

        /**
         * Returns an instance of {@code AdminTier} that has its tag set to
         * {@link Tag#TEAM_ADMIN}.
         *
         * <p> User is an administrator of the team - has all permissions. </p>
         *
         * @return Instance of {@code AdminTier} with its tag set to {@link
         *     Tag#TEAM_ADMIN}.
         */
        public static AdminTier teamAdmin() {
            return AdminTier.TEAM_ADMIN_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TEAM_ADMIN}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TEAM_ADMIN}, {@code false} otherwise.
         */
        public boolean isTeamAdmin() {
            return this.tag == Tag.TEAM_ADMIN;
        }

        /**
         * User can do most user provisioning, de-provisioning and management.
         */
        private static final AdminTier USER_MANAGEMENT_ADMIN_INSTANCE = new AdminTier(Tag.USER_MANAGEMENT_ADMIN);

        /**
         * Returns an instance of {@code AdminTier} that has its tag set to
         * {@link Tag#USER_MANAGEMENT_ADMIN}.
         *
         * <p> User can do most user provisioning, de-provisioning and
         * management. </p>
         *
         * @return Instance of {@code AdminTier} with its tag set to {@link
         *     Tag#USER_MANAGEMENT_ADMIN}.
         */
        public static AdminTier userManagementAdmin() {
            return AdminTier.USER_MANAGEMENT_ADMIN_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_MANAGEMENT_ADMIN}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_MANAGEMENT_ADMIN}, {@code false} otherwise.
         */
        public boolean isUserManagementAdmin() {
            return this.tag == Tag.USER_MANAGEMENT_ADMIN;
        }

        /**
         * User can do a limited set of common support tasks for existing users.
         */
        private static final AdminTier SUPPORT_ADMIN_INSTANCE = new AdminTier(Tag.SUPPORT_ADMIN);

        /**
         * Returns an instance of {@code AdminTier} that has its tag set to
         * {@link Tag#SUPPORT_ADMIN}.
         *
         * <p> User can do a limited set of common support tasks for existing
         * users. </p>
         *
         * @return Instance of {@code AdminTier} with its tag set to {@link
         *     Tag#SUPPORT_ADMIN}.
         */
        public static AdminTier supportAdmin() {
            return AdminTier.SUPPORT_ADMIN_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#SUPPORT_ADMIN}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#SUPPORT_ADMIN}, {@code false} otherwise.
         */
        public boolean isSupportAdmin() {
            return this.tag == Tag.SUPPORT_ADMIN;
        }

        /**
         * User is not an admin of the team.
         */
        private static final AdminTier MEMBER_ONLY_INSTANCE = new AdminTier(Tag.MEMBER_ONLY);

        /**
         * Returns an instance of {@code AdminTier} that has its tag set to
         * {@link Tag#MEMBER_ONLY}.
         *
         * <p> User is not an admin of the team. </p>
         *
         * @return Instance of {@code AdminTier} with its tag set to {@link
         *     Tag#MEMBER_ONLY}.
         */
        public static AdminTier memberOnly() {
            return AdminTier.MEMBER_ONLY_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_ONLY}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_ONLY}, {@code false} otherwise.
         */
        public boolean isMemberOnly() {
            return this.tag == Tag.MEMBER_ONLY;
        }

        private AdminTier(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case TEAM_ADMIN:
                case USER_MANAGEMENT_ADMIN:
                case SUPPORT_ADMIN:
                case MEMBER_ONLY:
                    break;
            }
        }

        static final JsonWriter<AdminTier> _writer = new JsonWriter<AdminTier>()
        {
            public final void write(AdminTier x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case TEAM_ADMIN:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("team_admin");
                        g.writeEndObject();
                        break;
                    case USER_MANAGEMENT_ADMIN:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_management_admin");
                        g.writeEndObject();
                        break;
                    case SUPPORT_ADMIN:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("support_admin");
                        g.writeEndObject();
                        break;
                    case MEMBER_ONLY:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_only");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<AdminTier> _reader = new JsonReader<AdminTier>()
        {
            public final AdminTier read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case TEAM_ADMIN: return AdminTier.teamAdmin();
                        case USER_MANAGEMENT_ADMIN: return AdminTier.userManagementAdmin();
                        case SUPPORT_ADMIN: return AdminTier.supportAdmin();
                        case MEMBER_ONLY: return AdminTier.memberOnly();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                AdminTier value = null;
                if (tag != null) {
                    switch (tag) {
                        case TEAM_ADMIN: {
                            value = AdminTier.teamAdmin();
                            break;
                        }
                        case USER_MANAGEMENT_ADMIN: {
                            value = AdminTier.userManagementAdmin();
                            break;
                        }
                        case SUPPORT_ADMIN: {
                            value = AdminTier.supportAdmin();
                            break;
                        }
                        case MEMBER_ONLY: {
                            value = AdminTier.memberOnly();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("team_admin", Tag.TEAM_ADMIN);
            _values.put("user_management_admin", Tag.USER_MANAGEMENT_ADMIN);
            _values.put("support_admin", Tag.SUPPORT_ADMIN);
            _values.put("member_only", Tag.MEMBER_ONLY);
        }

        public String toString() {
            return "AdminTier." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "AdminTier." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static AdminTier fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Profile of a user as a member of a team.
     */
    public static class TeamMemberProfile extends MemberProfile  {
        // struct TeamMemberProfile
        /**
         * List of group IDs of groups that the user belongs to.
         */
        public final java.util.List<String> groups;

        /**
         * Profile of a user as a member of a team.
         *
         * @param teamMemberId  ID of user as a member of a team. {@code
         *     teamMemberId} must not be {@code null}.
         * @param email  Email address of user. {@code email} must not be {@code
         *     null}.
         * @param emailVerified  Is true if the user's email is verified to be
         *     owned by the user.
         * @param status  The user's status as a member of a specific team.
         *     {@code status} must not be {@code null}.
         * @param name  Representations for a person's name. {@code name} must
         *     not be {@code null}.
         * @param groups  List of group IDs of groups that the user belongs to.
         *     {@code groups} must not contain a {@code null} item and not be
         *     {@code null}.
         * @param externalId  External ID that a team can attach to the user. An
         *     application using the API may find it easier to use their own IDs
         *     instead of Dropbox IDs like account_id or team_member_id.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public TeamMemberProfile(String teamMemberId, String email, boolean emailVerified, TeamMemberStatus status, DbxUsers.Name name, java.util.List<String> groups, String externalId) {
            super(teamMemberId, email, emailVerified, status, name, externalId);
            this.groups = groups;
            if (groups == null) {
                throw new IllegalArgumentException("Required value for 'groups' is null");
            }
            for (String x : groups) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'groups' is null");
                }
            }
        }

        static final JsonWriter<TeamMemberProfile> _writer = new JsonWriter<TeamMemberProfile>()
        {
            public final void write(TeamMemberProfile x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MemberProfile._writer.writeFields(x, g);
                TeamMemberProfile._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(TeamMemberProfile x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("groups");
                g.writeStartArray();
                for (String item: x.groups) {
                    if (item != null) {
                        g.writeString(item);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<TeamMemberProfile> _reader = new JsonReader<TeamMemberProfile>() {

            public final TeamMemberProfile read(JsonParser parser)
                throws IOException, JsonReadException
            {
                TeamMemberProfile result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final TeamMemberProfile readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String teamMemberId = null;
                String email = null;
                Boolean emailVerified = null;
                TeamMemberStatus status = null;
                DbxUsers.Name name = null;
                java.util.List<String> groups = null;
                String externalId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("email".equals(fieldName)) {
                        email = JsonReader.StringReader
                            .readField(parser, "email", email);
                    }
                    else if ("email_verified".equals(fieldName)) {
                        emailVerified = JsonReader.BooleanReader
                            .readField(parser, "email_verified", emailVerified);
                    }
                    else if ("status".equals(fieldName)) {
                        status = TeamMemberStatus._reader
                            .readField(parser, "status", status);
                    }
                    else if ("name".equals(fieldName)) {
                        name = DbxUsers.Name._reader
                            .readField(parser, "name", name);
                    }
                    else if ("groups".equals(fieldName)) {
                        groups = JsonArrayReader.mk(JsonReader.StringReader)
                            .readField(parser, "groups", groups);
                    }
                    else if ("external_id".equals(fieldName)) {
                        externalId = JsonReader.StringReader
                            .readField(parser, "external_id", externalId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                if (email == null) {
                    throw new JsonReadException("Required field \"email\" is missing.", parser.getTokenLocation());
                }
                if (emailVerified == null) {
                    throw new JsonReadException("Required field \"email_verified\" is missing.", parser.getTokenLocation());
                }
                if (status == null) {
                    throw new JsonReadException("Required field \"status\" is missing.", parser.getTokenLocation());
                }
                if (name == null) {
                    throw new JsonReadException("Required field \"name\" is missing.", parser.getTokenLocation());
                }
                if (groups == null) {
                    throw new JsonReadException("Required field \"groups\" is missing.", parser.getTokenLocation());
                }
                return new TeamMemberProfile(teamMemberId, email, emailVerified, status, name, groups, externalId);
            }
        };

        public String toString() {
            return "TeamMemberProfile." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "TeamMemberProfile." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static TeamMemberProfile fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MemberSelectorError {
        // union MemberSelectorError

        /**
         * The discriminating tag type for {@link MemberSelectorError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MemberSelectorError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MemberSelectorError USER_NOT_FOUND_INSTANCE = new MemberSelectorError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MemberSelectorError} that has its tag
         * set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MemberSelectorError} with its tag set to
         *     {@link Tag#USER_NOT_FOUND}.
         */
        public static MemberSelectorError userNotFound() {
            return MemberSelectorError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MemberSelectorError USER_NOT_IN_TEAM_INSTANCE = new MemberSelectorError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MemberSelectorError} that has its tag
         * set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MemberSelectorError} with its tag set to
         *     {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MemberSelectorError userNotInTeam() {
            return MemberSelectorError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        private MemberSelectorError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case USER_NOT_IN_TEAM:
                    break;
            }
        }

        static final JsonWriter<MemberSelectorError> _writer = new JsonWriter<MemberSelectorError>()
        {
            public final void write(MemberSelectorError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MemberSelectorError> _reader = new JsonReader<MemberSelectorError>()
        {
            public final MemberSelectorError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case USER_NOT_FOUND: return MemberSelectorError.userNotFound();
                        case USER_NOT_IN_TEAM: return MemberSelectorError.userNotInTeam();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MemberSelectorError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MemberSelectorError.userNotFound();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MemberSelectorError.userNotInTeam();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("user_not_in_team", Tag.USER_NOT_IN_TEAM);
        }

        public String toString() {
            return "MemberSelectorError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MemberSelectorError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MemberSelectorError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MembersListArg {
        // struct MembersListArg
        /**
         * Number of results to return per call.
         */
        public final long limit;

        /**
         *
         * @param limit  Number of results to return per call. {@code limit}
         *     must be greater than or equal to 1 and be less than or equal to
         *     1000.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersListArg(Long limit) {
            if (limit != null) {
                this.limit = limit.longValue();
            }
            else {
                this.limit = 1000L;
            }
            if (this.limit < 1L) {
                throw new IllegalArgumentException("Number 'this.limit' is smaller than 1L");
            }
            if (this.limit > 1000L) {
                throw new IllegalArgumentException("Number 'this.limit' is larger than 1000L");
            }
        }

        static final JsonWriter<MembersListArg> _writer = new JsonWriter<MembersListArg>()
        {
            public final void write(MembersListArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersListArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersListArg x, JsonGenerator g)
             throws IOException
            {
                g.writeNumberField("limit", x.limit);
            }
        };

        public static final JsonReader<MembersListArg> _reader = new JsonReader<MembersListArg>() {

            public final MembersListArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersListArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersListArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                Long limit = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("limit".equals(fieldName)) {
                        limit = JsonReader.UInt32Reader
                            .readField(parser, "limit", limit);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                return new MembersListArg(limit);
            }
        };

        public String toString() {
            return "MembersListArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersListArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersListArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Information about a team member.
     */
    public static class TeamMemberInfo {
        // struct TeamMemberInfo
        /**
         * Profile of a user as a member of a team.
         */
        public final TeamMemberProfile profile;
        /**
         * The user's role in the team.
         */
        public final AdminTier role;

        /**
         * Information about a team member.
         *
         * @param profile  Profile of a user as a member of a team. {@code
         *     profile} must not be {@code null}.
         * @param role  The user's role in the team. {@code role} must not be
         *     {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public TeamMemberInfo(TeamMemberProfile profile, AdminTier role) {
            this.profile = profile;
            if (profile == null) {
                throw new IllegalArgumentException("Required value for 'profile' is null");
            }
            this.role = role;
            if (role == null) {
                throw new IllegalArgumentException("Required value for 'role' is null");
            }
        }

        static final JsonWriter<TeamMemberInfo> _writer = new JsonWriter<TeamMemberInfo>()
        {
            public final void write(TeamMemberInfo x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                TeamMemberInfo._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(TeamMemberInfo x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("profile");
                TeamMemberProfile._writer.write(x.profile, g);
                g.writeFieldName("role");
                AdminTier._writer.write(x.role, g);
            }
        };

        public static final JsonReader<TeamMemberInfo> _reader = new JsonReader<TeamMemberInfo>() {

            public final TeamMemberInfo read(JsonParser parser)
                throws IOException, JsonReadException
            {
                TeamMemberInfo result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final TeamMemberInfo readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                TeamMemberProfile profile = null;
                AdminTier role = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("profile".equals(fieldName)) {
                        profile = TeamMemberProfile._reader
                            .readField(parser, "profile", profile);
                    }
                    else if ("role".equals(fieldName)) {
                        role = AdminTier._reader
                            .readField(parser, "role", role);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (profile == null) {
                    throw new JsonReadException("Required field \"profile\" is missing.", parser.getTokenLocation());
                }
                if (role == null) {
                    throw new JsonReadException("Required field \"role\" is missing.", parser.getTokenLocation());
                }
                return new TeamMemberInfo(profile, role);
            }
        };

        public String toString() {
            return "TeamMemberInfo." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "TeamMemberInfo." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static TeamMemberInfo fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MembersListResult {
        // struct MembersListResult
        /**
         * List of team members.
         */
        public final java.util.List<TeamMemberInfo> members;
        /**
         * Pass the cursor into {@link DbxTeam#membersListContinue(String)} to
         * obtain the additional members.
         */
        public final String cursor;
        /**
         * Is true if there are additional team members that have not been
         * returned yet. An additional call to {@link
         * DbxTeam#membersListContinue(String)} can retrieve them.
         */
        public final boolean hasMore;

        /**
         *
         * @param members  List of team members. {@code members} must not
         *     contain a {@code null} item and not be {@code null}.
         * @param cursor  Pass the cursor into {@link
         *     DbxTeam#membersListContinue(String)} to obtain the additional
         *     members. {@code cursor} must not be {@code null}.
         * @param hasMore  Is true if there are additional team members that
         *     have not been returned yet. An additional call to {@link
         *     DbxTeam#membersListContinue(String)} can retrieve them.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersListResult(java.util.List<TeamMemberInfo> members, String cursor, boolean hasMore) {
            this.members = members;
            if (members == null) {
                throw new IllegalArgumentException("Required value for 'members' is null");
            }
            for (TeamMemberInfo x : members) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'members' is null");
                }
            }
            this.cursor = cursor;
            if (cursor == null) {
                throw new IllegalArgumentException("Required value for 'cursor' is null");
            }
            this.hasMore = hasMore;
        }

        static final JsonWriter<MembersListResult> _writer = new JsonWriter<MembersListResult>()
        {
            public final void write(MembersListResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersListResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersListResult x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("members");
                g.writeStartArray();
                for (TeamMemberInfo item: x.members) {
                    if (item != null) {
                        TeamMemberInfo._writer.write(item, g);
                    }
                }
                g.writeEndArray();
                g.writeStringField("cursor", x.cursor);
                g.writeBooleanField("has_more", x.hasMore);
            }
        };

        public static final JsonReader<MembersListResult> _reader = new JsonReader<MembersListResult>() {

            public final MembersListResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersListResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersListResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<TeamMemberInfo> members = null;
                String cursor = null;
                Boolean hasMore = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("members".equals(fieldName)) {
                        members = JsonArrayReader.mk(TeamMemberInfo._reader)
                            .readField(parser, "members", members);
                    }
                    else if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else if ("has_more".equals(fieldName)) {
                        hasMore = JsonReader.BooleanReader
                            .readField(parser, "has_more", hasMore);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (members == null) {
                    throw new JsonReadException("Required field \"members\" is missing.", parser.getTokenLocation());
                }
                if (cursor == null) {
                    throw new JsonReadException("Required field \"cursor\" is missing.", parser.getTokenLocation());
                }
                if (hasMore == null) {
                    throw new JsonReadException("Required field \"has_more\" is missing.", parser.getTokenLocation());
                }
                return new MembersListResult(members, cursor, hasMore);
            }
        };

        public String toString() {
            return "MembersListResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersListResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersListResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersListError {
        // union MembersListError

        /**
         * The discriminating tag type for {@link MembersListError}.
         */
        public enum Tag {
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersListError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * An unspecified error.
         */
        private static final MembersListError OTHER_INSTANCE = new MembersListError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersListError} that has its tag set
         * to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersListError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static MembersListError other() {
            return MembersListError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MembersListError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MembersListError> _writer = new JsonWriter<MembersListError>()
        {
            public final void write(MembersListError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersListError> _reader = new JsonReader<MembersListError>()
        {
            public final MembersListError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MembersListError.other(); }
                    switch (tag) {
                        case OTHER: return MembersListError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersListError value = null;
                if (tag != null) {
                    switch (tag) {
                        case OTHER: {
                            value = MembersListError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MembersListError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MembersListError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersListError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersListError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MembersListContinueArg {
        // struct MembersListContinueArg
        /**
         * Indicates from what point to get the next set of members.
         */
        public final String cursor;

        /**
         *
         * @param cursor  Indicates from what point to get the next set of
         *     members. {@code cursor} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersListContinueArg(String cursor) {
            this.cursor = cursor;
            if (cursor == null) {
                throw new IllegalArgumentException("Required value for 'cursor' is null");
            }
        }

        static final JsonWriter<MembersListContinueArg> _writer = new JsonWriter<MembersListContinueArg>()
        {
            public final void write(MembersListContinueArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersListContinueArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersListContinueArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("cursor", x.cursor);
            }
        };

        public static final JsonReader<MembersListContinueArg> _reader = new JsonReader<MembersListContinueArg>() {

            public final MembersListContinueArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersListContinueArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersListContinueArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String cursor = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("cursor".equals(fieldName)) {
                        cursor = JsonReader.StringReader
                            .readField(parser, "cursor", cursor);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (cursor == null) {
                    throw new JsonReadException("Required field \"cursor\" is missing.", parser.getTokenLocation());
                }
                return new MembersListContinueArg(cursor);
            }
        };

        public String toString() {
            return "MembersListContinueArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersListContinueArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersListContinueArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersListContinueError {
        // union MembersListContinueError

        /**
         * The discriminating tag type for {@link MembersListContinueError}.
         */
        public enum Tag {
            /**
             * The cursor is invalid.
             */
            INVALID_CURSOR,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersListContinueError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * The cursor is invalid.
         */
        private static final MembersListContinueError INVALID_CURSOR_INSTANCE = new MembersListContinueError(Tag.INVALID_CURSOR);

        /**
         * Returns an instance of {@code MembersListContinueError} that has its
         * tag set to {@link Tag#INVALID_CURSOR}.
         *
         * <p> The cursor is invalid. </p>
         *
         * @return Instance of {@code MembersListContinueError} with its tag set
         *     to {@link Tag#INVALID_CURSOR}.
         */
        public static MembersListContinueError invalidCursor() {
            return MembersListContinueError.INVALID_CURSOR_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#INVALID_CURSOR}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#INVALID_CURSOR}, {@code false} otherwise.
         */
        public boolean isInvalidCursor() {
            return this.tag == Tag.INVALID_CURSOR;
        }

        /**
         * An unspecified error.
         */
        private static final MembersListContinueError OTHER_INSTANCE = new MembersListContinueError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersListContinueError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersListContinueError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static MembersListContinueError other() {
            return MembersListContinueError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MembersListContinueError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case INVALID_CURSOR:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MembersListContinueError> _writer = new JsonWriter<MembersListContinueError>()
        {
            public final void write(MembersListContinueError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case INVALID_CURSOR:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("invalid_cursor");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersListContinueError> _reader = new JsonReader<MembersListContinueError>()
        {
            public final MembersListContinueError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MembersListContinueError.other(); }
                    switch (tag) {
                        case INVALID_CURSOR: return MembersListContinueError.invalidCursor();
                        case OTHER: return MembersListContinueError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersListContinueError value = null;
                if (tag != null) {
                    switch (tag) {
                        case INVALID_CURSOR: {
                            value = MembersListContinueError.invalidCursor();
                            break;
                        }
                        case OTHER: {
                            value = MembersListContinueError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MembersListContinueError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("invalid_cursor", Tag.INVALID_CURSOR);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MembersListContinueError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersListContinueError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersListContinueError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MembersGetInfoArgs {
        // struct MembersGetInfoArgs
        /**
         * List of team members.
         */
        public final java.util.List<UserSelectorArg> members;

        /**
         *
         * @param members  List of team members. {@code members} must not
         *     contain a {@code null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersGetInfoArgs(java.util.List<UserSelectorArg> members) {
            this.members = members;
            if (members == null) {
                throw new IllegalArgumentException("Required value for 'members' is null");
            }
            for (UserSelectorArg x : members) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'members' is null");
                }
            }
        }

        static final JsonWriter<MembersGetInfoArgs> _writer = new JsonWriter<MembersGetInfoArgs>()
        {
            public final void write(MembersGetInfoArgs x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersGetInfoArgs._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersGetInfoArgs x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("members");
                g.writeStartArray();
                for (UserSelectorArg item: x.members) {
                    if (item != null) {
                        UserSelectorArg._writer.write(item, g);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<MembersGetInfoArgs> _reader = new JsonReader<MembersGetInfoArgs>() {

            public final MembersGetInfoArgs read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersGetInfoArgs result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersGetInfoArgs readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<UserSelectorArg> members = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("members".equals(fieldName)) {
                        members = JsonArrayReader.mk(UserSelectorArg._reader)
                            .readField(parser, "members", members);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (members == null) {
                    throw new JsonReadException("Required field \"members\" is missing.", parser.getTokenLocation());
                }
                return new MembersGetInfoArgs(members);
            }
        };

        public String toString() {
            return "MembersGetInfoArgs." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersGetInfoArgs." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersGetInfoArgs fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Describes a result obtained for a single user whose id was specified in
     * the parameter of {@link DbxTeam#membersGetInfo(java.util.List)}.
     */
    public static final class MembersGetInfoItem {
        // union MembersGetInfoItem

        /**
         * The discriminating tag type for {@link MembersGetInfoItem}.
         */
        public enum Tag {
            /**
             * An ID that was provided as a parameter to {@link
             * DbxTeam#membersGetInfo(java.util.List)}, and did not match a
             * corresponding user. This might be a team_member_id, an email, or
             * an external ID, depending on how the method was called.
             */
            ID_NOT_FOUND,  // String
            /**
             * Info about a team member.
             */
            MEMBER_INFO  // TeamMemberInfo
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersGetInfoItem}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final String idNotFoundValue;

        private MembersGetInfoItem(Tag tag, String value) {
            this.tag = tag;
            this.idNotFoundValue = value;
            this.memberInfoValue = null;
            validate();
        }

        /**
         * An ID that was provided as a parameter to {@link
         * DbxTeam#membersGetInfo(java.util.List)}, and did not match a
         * corresponding user. This might be a team_member_id, an email, or an
         * external ID, depending on how the method was called.
         *
         * <p> This instance must be tagged as {@link Tag#ID_NOT_FOUND}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isIdNotFound} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isIdNotFound} is {@code
         *     false}.
         */
        public String getIdNotFoundValue() {
            if (this.tag != Tag.ID_NOT_FOUND) {
                throw new IllegalStateException("getIdNotFoundValue() requires tag==ID_NOT_FOUND, actual tag==" + tag);
            }
            return idNotFoundValue;
        }

        /**
         * Returns an instance of {@code MembersGetInfoItem} that has its tag
         * set to {@link Tag#ID_NOT_FOUND}.
         *
         * <p> An ID that was provided as a parameter to {@link
         * DbxTeam#membersGetInfo(java.util.List)}, and did not match a
         * corresponding user. This might be a team_member_id, an email, or an
         * external ID, depending on how the method was called. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MembersGetInfoItem} with its tag set to
         *     {@link Tag#ID_NOT_FOUND}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static MembersGetInfoItem idNotFound(String value) {
            return new MembersGetInfoItem(Tag.ID_NOT_FOUND, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#ID_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#ID_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isIdNotFound() {
            return this.tag == Tag.ID_NOT_FOUND;
        }

        private final TeamMemberInfo memberInfoValue;

        private MembersGetInfoItem(Tag tag, TeamMemberInfo value) {
            this.tag = tag;
            this.idNotFoundValue = null;
            this.memberInfoValue = value;
            validate();
        }

        /**
         * Info about a team member.
         *
         * <p> This instance must be tagged as {@link Tag#MEMBER_INFO}. </p>
         *
         * @return The {@link TeamMemberInfo} value associated with this
         *     instance if {@link #isMemberInfo} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isMemberInfo} is {@code
         *     false}.
         */
        public TeamMemberInfo getMemberInfoValue() {
            if (this.tag != Tag.MEMBER_INFO) {
                throw new IllegalStateException("getMemberInfoValue() requires tag==MEMBER_INFO, actual tag==" + tag);
            }
            return memberInfoValue;
        }

        /**
         * Returns an instance of {@code MembersGetInfoItem} that has its tag
         * set to {@link Tag#MEMBER_INFO}.
         *
         * <p> Info about a team member. </p>
         *
         * @param value  {@link TeamMemberInfo} value to assign to this
         *     instance.
         *
         * @return Instance of {@code MembersGetInfoItem} with its tag set to
         *     {@link Tag#MEMBER_INFO}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static MembersGetInfoItem memberInfo(TeamMemberInfo value) {
            return new MembersGetInfoItem(Tag.MEMBER_INFO, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#MEMBER_INFO}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#MEMBER_INFO}, {@code false} otherwise.
         */
        public boolean isMemberInfo() {
            return this.tag == Tag.MEMBER_INFO;
        }


        private final void validate() {
            switch (this.tag) {
                case ID_NOT_FOUND:
                    if (this.idNotFoundValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case MEMBER_INFO:
                    if (this.memberInfoValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
            }
        }

        static final JsonWriter<MembersGetInfoItem> _writer = new JsonWriter<MembersGetInfoItem>()
        {
            public final void write(MembersGetInfoItem x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case ID_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("id_not_found");
                        g.writeStringField("id_not_found", x.idNotFoundValue);
                        g.writeEndObject();
                        break;
                    case MEMBER_INFO:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("member_info");
                        TeamMemberInfo._writer.writeFields(x.memberInfoValue, g);
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersGetInfoItem> _reader = new JsonReader<MembersGetInfoItem>()
        {
            public final MembersGetInfoItem read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersGetInfoItem value = null;
                if (tag != null) {
                    switch (tag) {
                        case ID_NOT_FOUND: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "id_not_found", v);
                            value = MembersGetInfoItem.idNotFound(v);
                            break;
                        }
                        case MEMBER_INFO: {
                            TeamMemberInfo v = null;
                            v = TeamMemberInfo._reader.readFields(parser);
                            value = MembersGetInfoItem.memberInfo(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("id_not_found", Tag.ID_NOT_FOUND);
            _values.put("member_info", Tag.MEMBER_INFO);
        }

        public String toString() {
            return "MembersGetInfoItem." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersGetInfoItem." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersGetInfoItem fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersGetInfoError {
        // union MembersGetInfoError

        /**
         * The discriminating tag type for {@link MembersGetInfoError}.
         */
        public enum Tag {
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersGetInfoError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * An unspecified error.
         */
        private static final MembersGetInfoError OTHER_INSTANCE = new MembersGetInfoError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersGetInfoError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersGetInfoError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static MembersGetInfoError other() {
            return MembersGetInfoError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MembersGetInfoError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MembersGetInfoError> _writer = new JsonWriter<MembersGetInfoError>()
        {
            public final void write(MembersGetInfoError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersGetInfoError> _reader = new JsonReader<MembersGetInfoError>()
        {
            public final MembersGetInfoError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MembersGetInfoError.other(); }
                    switch (tag) {
                        case OTHER: return MembersGetInfoError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersGetInfoError value = null;
                if (tag != null) {
                    switch (tag) {
                        case OTHER: {
                            value = MembersGetInfoError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MembersGetInfoError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MembersGetInfoError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersGetInfoError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersGetInfoError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MemberAddArg {
        // struct MemberAddArg
        public final String memberEmail;
        /**
         * Member's first name.
         */
        public final String memberGivenName;
        /**
         * Member's last name.
         */
        public final String memberSurname;
        /**
         * External ID for member.
         */
        public final String memberExternalId;
        /**
         * Whether to send a welcome email to the member. If send_welcome_email
         * is false, no email invitation will be sent to the user. This may be
         * useful for apps using single sign-on (SSO) flows for onboarding that
         * want to handle announcements themselves.
         */
        public final boolean sendWelcomeEmail;
        public final AdminTier role;

        /**
         *
         * @param memberEmail  . {@code memberEmail} must match pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     and not be {@code null}.
         * @param memberGivenName  Member's first name. {@code memberGivenName}
         *     must have length of at least 1, match pattern "{@code
         *     [^/:?*<>\"|]*}", and not be {@code null}.
         * @param memberSurname  Member's last name. {@code memberSurname} must
         *     have length of at least 1, match pattern "{@code [^/:?*<>\"|]*}",
         *     and not be {@code null}.
         * @param memberExternalId  External ID for member. {@code
         *     memberExternalId} must have length of at most 64.
         * @param sendWelcomeEmail  Whether to send a welcome email to the
         *     member. If send_welcome_email is false, no email invitation will
         *     be sent to the user. This may be useful for apps using single
         *     sign-on (SSO) flows for onboarding that want to handle
         *     announcements themselves.
         * @param role  .
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MemberAddArg(String memberEmail, String memberGivenName, String memberSurname, String memberExternalId, Boolean sendWelcomeEmail, AdminTier role) {
            this.memberEmail = memberEmail;
            if (memberEmail == null) {
                throw new IllegalArgumentException("Required value for 'memberEmail' is null");
            }
            if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", memberEmail)) {
                throw new IllegalArgumentException("String 'memberEmail' does not match pattern");
            }
            this.memberGivenName = memberGivenName;
            if (memberGivenName == null) {
                throw new IllegalArgumentException("Required value for 'memberGivenName' is null");
            }
            if (memberGivenName.length() < 1) {
                throw new IllegalArgumentException("String 'memberGivenName' is shorter than 1");
            }
            if (!java.util.regex.Pattern.matches("[^/:?*<>\"|]*", memberGivenName)) {
                throw new IllegalArgumentException("String 'memberGivenName' does not match pattern");
            }
            this.memberSurname = memberSurname;
            if (memberSurname == null) {
                throw new IllegalArgumentException("Required value for 'memberSurname' is null");
            }
            if (memberSurname.length() < 1) {
                throw new IllegalArgumentException("String 'memberSurname' is shorter than 1");
            }
            if (!java.util.regex.Pattern.matches("[^/:?*<>\"|]*", memberSurname)) {
                throw new IllegalArgumentException("String 'memberSurname' does not match pattern");
            }
            this.memberExternalId = memberExternalId;
            if (memberExternalId != null) {
                if (memberExternalId.length() > 64) {
                    throw new IllegalArgumentException("String 'memberExternalId' is longer than 64");
                }
            }
            if (sendWelcomeEmail != null) {
                this.sendWelcomeEmail = sendWelcomeEmail.booleanValue();
            }
            else {
                this.sendWelcomeEmail = true;
            }
            if (role != null) {
                this.role = role;
            }
            else {
                this.role = AdminTier.memberOnly();
            }
        }

        static final JsonWriter<MemberAddArg> _writer = new JsonWriter<MemberAddArg>()
        {
            public final void write(MemberAddArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MemberAddArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MemberAddArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("member_email", x.memberEmail);
                g.writeStringField("member_given_name", x.memberGivenName);
                g.writeStringField("member_surname", x.memberSurname);
                if (x.memberExternalId != null) {
                    g.writeFieldName("member_external_id");
                    g.writeString(x.memberExternalId);
                }
                g.writeBooleanField("send_welcome_email", x.sendWelcomeEmail);
                g.writeFieldName("role");
                AdminTier._writer.write(x.role, g);
            }
        };

        public static final JsonReader<MemberAddArg> _reader = new JsonReader<MemberAddArg>() {

            public final MemberAddArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MemberAddArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MemberAddArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String memberEmail = null;
                String memberGivenName = null;
                String memberSurname = null;
                String memberExternalId = null;
                Boolean sendWelcomeEmail = null;
                AdminTier role = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("member_email".equals(fieldName)) {
                        memberEmail = JsonReader.StringReader
                            .readField(parser, "member_email", memberEmail);
                    }
                    else if ("member_given_name".equals(fieldName)) {
                        memberGivenName = JsonReader.StringReader
                            .readField(parser, "member_given_name", memberGivenName);
                    }
                    else if ("member_surname".equals(fieldName)) {
                        memberSurname = JsonReader.StringReader
                            .readField(parser, "member_surname", memberSurname);
                    }
                    else if ("member_external_id".equals(fieldName)) {
                        memberExternalId = JsonReader.StringReader
                            .readField(parser, "member_external_id", memberExternalId);
                    }
                    else if ("send_welcome_email".equals(fieldName)) {
                        sendWelcomeEmail = JsonReader.BooleanReader
                            .readField(parser, "send_welcome_email", sendWelcomeEmail);
                    }
                    else if ("role".equals(fieldName)) {
                        role = AdminTier._reader
                            .readField(parser, "role", role);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (memberEmail == null) {
                    throw new JsonReadException("Required field \"member_email\" is missing.", parser.getTokenLocation());
                }
                if (memberGivenName == null) {
                    throw new JsonReadException("Required field \"member_given_name\" is missing.", parser.getTokenLocation());
                }
                if (memberSurname == null) {
                    throw new JsonReadException("Required field \"member_surname\" is missing.", parser.getTokenLocation());
                }
                return new MemberAddArg(memberEmail, memberGivenName, memberSurname, memberExternalId, sendWelcomeEmail, role);
            }
        };

        public String toString() {
            return "MemberAddArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MemberAddArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MemberAddArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MembersAddArg {
        // struct MembersAddArg
        /**
         * Details of new members to be added to the team.
         */
        public final java.util.List<MemberAddArg> newMembers;
        /**
         * Whether to force the add to happen asynchronously.
         */
        public final boolean forceAsync;

        /**
         *
         * @param newMembers  Details of new members to be added to the team.
         *     {@code newMembers} must not contain a {@code null} item and not
         *     be {@code null}.
         * @param forceAsync  Whether to force the add to happen asynchronously.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersAddArg(java.util.List<MemberAddArg> newMembers, Boolean forceAsync) {
            this.newMembers = newMembers;
            if (newMembers == null) {
                throw new IllegalArgumentException("Required value for 'newMembers' is null");
            }
            for (MemberAddArg x : newMembers) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'newMembers' is null");
                }
            }
            if (forceAsync != null) {
                this.forceAsync = forceAsync.booleanValue();
            }
            else {
                this.forceAsync = false;
            }
        }

        static final JsonWriter<MembersAddArg> _writer = new JsonWriter<MembersAddArg>()
        {
            public final void write(MembersAddArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersAddArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersAddArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("new_members");
                g.writeStartArray();
                for (MemberAddArg item: x.newMembers) {
                    if (item != null) {
                        MemberAddArg._writer.write(item, g);
                    }
                }
                g.writeEndArray();
                g.writeBooleanField("force_async", x.forceAsync);
            }
        };

        public static final JsonReader<MembersAddArg> _reader = new JsonReader<MembersAddArg>() {

            public final MembersAddArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersAddArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersAddArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<MemberAddArg> newMembers = null;
                Boolean forceAsync = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("new_members".equals(fieldName)) {
                        newMembers = JsonArrayReader.mk(MemberAddArg._reader)
                            .readField(parser, "new_members", newMembers);
                    }
                    else if ("force_async".equals(fieldName)) {
                        forceAsync = JsonReader.BooleanReader
                            .readField(parser, "force_async", forceAsync);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (newMembers == null) {
                    throw new JsonReadException("Required field \"new_members\" is missing.", parser.getTokenLocation());
                }
                return new MembersAddArg(newMembers, forceAsync);
            }
        };

        public String toString() {
            return "MembersAddArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersAddArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersAddArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Describes the result of attempting to add a single user to the team.
     * 'success' is the only value indicating that a user was indeed added to
     * the team - the other values explain the type of failure that occurred,
     * and include the email of the user for which the operation has failed.
     */
    public static final class MemberAddResult {
        // union MemberAddResult

        /**
         * The discriminating tag type for {@link MemberAddResult}.
         */
        public enum Tag {
            /**
             * Describes a user that was successfully added to the team.
             */
            SUCCESS,  // TeamMemberInfo
            /**
             * Team is already full. The organization has no available licenses.
             */
            TEAM_LICENSE_LIMIT,  // String
            /**
             * Team is already full. The free team member limit has been
             * reached.
             */
            FREE_TEAM_MEMBER_LIMIT_REACHED,  // String
            /**
             * User is already on this team. The provided email address is
             * associated with a user who is already a member of or invited to
             * the team.
             */
            USER_ALREADY_ON_TEAM,  // String
            /**
             * User is already on another team. The provided email address is
             * associated with a user that is already a member or invited to
             * another team.
             */
            USER_ON_ANOTHER_TEAM,  // String
            /**
             * User is already paired.
             */
            USER_ALREADY_PAIRED,  // String
            /**
             * User migration has failed.
             */
            USER_MIGRATION_FAILED,  // String
            /**
             * A user with the given external member ID already exists on the
             * team.
             */
            DUPLICATE_EXTERNAL_MEMBER_ID,  // String
            /**
             * User creation has failed.
             */
            USER_CREATION_FAILED  // String
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MemberAddResult}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final TeamMemberInfo successValue;

        private MemberAddResult(Tag tag, TeamMemberInfo value) {
            this.tag = tag;
            this.successValue = value;
            this.teamLicenseLimitValue = null;
            validate();
        }

        /**
         * Describes a user that was successfully added to the team.
         *
         * <p> This instance must be tagged as {@link Tag#SUCCESS}. </p>
         *
         * @return The {@link TeamMemberInfo} value associated with this
         *     instance if {@link #isSuccess} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isSuccess} is {@code
         *     false}.
         */
        public TeamMemberInfo getSuccessValue() {
            if (this.tag != Tag.SUCCESS) {
                throw new IllegalStateException("getSuccessValue() requires tag==SUCCESS, actual tag==" + tag);
            }
            return successValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#SUCCESS}.
         *
         * <p> Describes a user that was successfully added to the team. </p>
         *
         * @param value  {@link TeamMemberInfo} value to assign to this
         *     instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#SUCCESS}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static MemberAddResult success(TeamMemberInfo value) {
            return new MemberAddResult(Tag.SUCCESS, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#SUCCESS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#SUCCESS}, {@code false} otherwise.
         */
        public boolean isSuccess() {
            return this.tag == Tag.SUCCESS;
        }

        private final String teamLicenseLimitValue;

        private MemberAddResult(Tag tag, String value) {
            this.tag = tag;
            this.successValue = null;
            this.teamLicenseLimitValue = value;
            validate();
        }

        /**
         * Team is already full. The organization has no available licenses.
         *
         * <p> This instance must be tagged as {@link Tag#TEAM_LICENSE_LIMIT}.
         * </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isTeamLicenseLimit} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isTeamLicenseLimit} is
         *     {@code false}.
         */
        public String getTeamLicenseLimitValue() {
            if (this.tag != Tag.TEAM_LICENSE_LIMIT) {
                throw new IllegalStateException("getTeamLicenseLimitValue() requires tag==TEAM_LICENSE_LIMIT, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#TEAM_LICENSE_LIMIT}.
         *
         * <p> Team is already full. The organization has no available licenses.
         * </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#TEAM_LICENSE_LIMIT}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult teamLicenseLimit(String value) {
            return new MemberAddResult(Tag.TEAM_LICENSE_LIMIT, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TEAM_LICENSE_LIMIT}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TEAM_LICENSE_LIMIT}, {@code false} otherwise.
         */
        public boolean isTeamLicenseLimit() {
            return this.tag == Tag.TEAM_LICENSE_LIMIT;
        }

        // Reusing teamLicenseLimitValue for freeTeamMemberLimitReached

        /**
         * Team is already full. The free team member limit has been reached.
         *
         * <p> This instance must be tagged as {@link
         * Tag#FREE_TEAM_MEMBER_LIMIT_REACHED}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isFreeTeamMemberLimitReached} is {@code true}.
         *
         * @throws IllegalStateException  If {@link
         *     #isFreeTeamMemberLimitReached} is {@code false}.
         */
        public String getFreeTeamMemberLimitReachedValue() {
            if (this.tag != Tag.FREE_TEAM_MEMBER_LIMIT_REACHED) {
                throw new IllegalStateException("getFreeTeamMemberLimitReachedValue() requires tag==FREE_TEAM_MEMBER_LIMIT_REACHED, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#FREE_TEAM_MEMBER_LIMIT_REACHED}.
         *
         * <p> Team is already full. The free team member limit has been
         * reached. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#FREE_TEAM_MEMBER_LIMIT_REACHED}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult freeTeamMemberLimitReached(String value) {
            return new MemberAddResult(Tag.FREE_TEAM_MEMBER_LIMIT_REACHED, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#FREE_TEAM_MEMBER_LIMIT_REACHED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#FREE_TEAM_MEMBER_LIMIT_REACHED}, {@code false} otherwise.
         */
        public boolean isFreeTeamMemberLimitReached() {
            return this.tag == Tag.FREE_TEAM_MEMBER_LIMIT_REACHED;
        }

        // Reusing teamLicenseLimitValue for userAlreadyOnTeam

        /**
         * User is already on this team. The provided email address is
         * associated with a user who is already a member of or invited to the
         * team.
         *
         * <p> This instance must be tagged as {@link Tag#USER_ALREADY_ON_TEAM}.
         * </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isUserAlreadyOnTeam} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isUserAlreadyOnTeam} is
         *     {@code false}.
         */
        public String getUserAlreadyOnTeamValue() {
            if (this.tag != Tag.USER_ALREADY_ON_TEAM) {
                throw new IllegalStateException("getUserAlreadyOnTeamValue() requires tag==USER_ALREADY_ON_TEAM, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#USER_ALREADY_ON_TEAM}.
         *
         * <p> User is already on this team. The provided email address is
         * associated with a user who is already a member of or invited to the
         * team. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#USER_ALREADY_ON_TEAM}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult userAlreadyOnTeam(String value) {
            return new MemberAddResult(Tag.USER_ALREADY_ON_TEAM, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_ALREADY_ON_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_ALREADY_ON_TEAM}, {@code false} otherwise.
         */
        public boolean isUserAlreadyOnTeam() {
            return this.tag == Tag.USER_ALREADY_ON_TEAM;
        }

        // Reusing teamLicenseLimitValue for userOnAnotherTeam

        /**
         * User is already on another team. The provided email address is
         * associated with a user that is already a member or invited to another
         * team.
         *
         * <p> This instance must be tagged as {@link Tag#USER_ON_ANOTHER_TEAM}.
         * </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isUserOnAnotherTeam} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isUserOnAnotherTeam} is
         *     {@code false}.
         */
        public String getUserOnAnotherTeamValue() {
            if (this.tag != Tag.USER_ON_ANOTHER_TEAM) {
                throw new IllegalStateException("getUserOnAnotherTeamValue() requires tag==USER_ON_ANOTHER_TEAM, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#USER_ON_ANOTHER_TEAM}.
         *
         * <p> User is already on another team. The provided email address is
         * associated with a user that is already a member or invited to another
         * team. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#USER_ON_ANOTHER_TEAM}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult userOnAnotherTeam(String value) {
            return new MemberAddResult(Tag.USER_ON_ANOTHER_TEAM, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_ON_ANOTHER_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_ON_ANOTHER_TEAM}, {@code false} otherwise.
         */
        public boolean isUserOnAnotherTeam() {
            return this.tag == Tag.USER_ON_ANOTHER_TEAM;
        }

        // Reusing teamLicenseLimitValue for userAlreadyPaired

        /**
         * User is already paired.
         *
         * <p> This instance must be tagged as {@link Tag#USER_ALREADY_PAIRED}.
         * </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isUserAlreadyPaired} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isUserAlreadyPaired} is
         *     {@code false}.
         */
        public String getUserAlreadyPairedValue() {
            if (this.tag != Tag.USER_ALREADY_PAIRED) {
                throw new IllegalStateException("getUserAlreadyPairedValue() requires tag==USER_ALREADY_PAIRED, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#USER_ALREADY_PAIRED}.
         *
         * <p> User is already paired. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#USER_ALREADY_PAIRED}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult userAlreadyPaired(String value) {
            return new MemberAddResult(Tag.USER_ALREADY_PAIRED, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_ALREADY_PAIRED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_ALREADY_PAIRED}, {@code false} otherwise.
         */
        public boolean isUserAlreadyPaired() {
            return this.tag == Tag.USER_ALREADY_PAIRED;
        }

        // Reusing teamLicenseLimitValue for userMigrationFailed

        /**
         * User migration has failed.
         *
         * <p> This instance must be tagged as {@link
         * Tag#USER_MIGRATION_FAILED}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isUserMigrationFailed} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isUserMigrationFailed} is
         *     {@code false}.
         */
        public String getUserMigrationFailedValue() {
            if (this.tag != Tag.USER_MIGRATION_FAILED) {
                throw new IllegalStateException("getUserMigrationFailedValue() requires tag==USER_MIGRATION_FAILED, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#USER_MIGRATION_FAILED}.
         *
         * <p> User migration has failed. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#USER_MIGRATION_FAILED}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult userMigrationFailed(String value) {
            return new MemberAddResult(Tag.USER_MIGRATION_FAILED, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_MIGRATION_FAILED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_MIGRATION_FAILED}, {@code false} otherwise.
         */
        public boolean isUserMigrationFailed() {
            return this.tag == Tag.USER_MIGRATION_FAILED;
        }

        // Reusing teamLicenseLimitValue for duplicateExternalMemberId

        /**
         * A user with the given external member ID already exists on the team.
         *
         * <p> This instance must be tagged as {@link
         * Tag#DUPLICATE_EXTERNAL_MEMBER_ID}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isDuplicateExternalMemberId} is {@code true}.
         *
         * @throws IllegalStateException  If {@link
         *     #isDuplicateExternalMemberId} is {@code false}.
         */
        public String getDuplicateExternalMemberIdValue() {
            if (this.tag != Tag.DUPLICATE_EXTERNAL_MEMBER_ID) {
                throw new IllegalStateException("getDuplicateExternalMemberIdValue() requires tag==DUPLICATE_EXTERNAL_MEMBER_ID, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#DUPLICATE_EXTERNAL_MEMBER_ID}.
         *
         * <p> A user with the given external member ID already exists on the
         * team. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#DUPLICATE_EXTERNAL_MEMBER_ID}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult duplicateExternalMemberId(String value) {
            return new MemberAddResult(Tag.DUPLICATE_EXTERNAL_MEMBER_ID, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#DUPLICATE_EXTERNAL_MEMBER_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#DUPLICATE_EXTERNAL_MEMBER_ID}, {@code false} otherwise.
         */
        public boolean isDuplicateExternalMemberId() {
            return this.tag == Tag.DUPLICATE_EXTERNAL_MEMBER_ID;
        }

        // Reusing teamLicenseLimitValue for userCreationFailed

        /**
         * User creation has failed.
         *
         * <p> This instance must be tagged as {@link Tag#USER_CREATION_FAILED}.
         * </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isUserCreationFailed} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isUserCreationFailed} is
         *     {@code false}.
         */
        public String getUserCreationFailedValue() {
            if (this.tag != Tag.USER_CREATION_FAILED) {
                throw new IllegalStateException("getUserCreationFailedValue() requires tag==USER_CREATION_FAILED, actual tag==" + tag);
            }
            return teamLicenseLimitValue;
        }

        /**
         * Returns an instance of {@code MemberAddResult} that has its tag set
         * to {@link Tag#USER_CREATION_FAILED}.
         *
         * <p> User creation has failed. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MemberAddResult} with its tag set to
         *     {@link Tag#USER_CREATION_FAILED}.
         *
         * @throws IllegalArgumentException  if {@code value} does not match
         *     pattern "{@code
         *     ^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$}"
         *     or is {@code null}.
         */
        public static MemberAddResult userCreationFailed(String value) {
            return new MemberAddResult(Tag.USER_CREATION_FAILED, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_CREATION_FAILED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_CREATION_FAILED}, {@code false} otherwise.
         */
        public boolean isUserCreationFailed() {
            return this.tag == Tag.USER_CREATION_FAILED;
        }


        private final void validate() {
            switch (this.tag) {
                case SUCCESS:
                    if (this.successValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
                case TEAM_LICENSE_LIMIT:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
                case FREE_TEAM_MEMBER_LIMIT_REACHED:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
                case USER_ALREADY_ON_TEAM:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
                case USER_ON_ANOTHER_TEAM:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
                case USER_ALREADY_PAIRED:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
                case USER_MIGRATION_FAILED:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
                case DUPLICATE_EXTERNAL_MEMBER_ID:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
                case USER_CREATION_FAILED:
                    if (this.teamLicenseLimitValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (!java.util.regex.Pattern.matches("^['&A-Za-z0-9._%+-]+@[A-Za-z0-9-][A-Za-z0-9.-]*.[A-Za-z]{2,15}$", this.teamLicenseLimitValue)) {
                        throw new IllegalArgumentException("String does not match pattern");
                    }
                    break;
            }
        }

        static final JsonWriter<MemberAddResult> _writer = new JsonWriter<MemberAddResult>()
        {
            public final void write(MemberAddResult x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case SUCCESS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("success");
                        TeamMemberInfo._writer.writeFields(x.successValue, g);
                        g.writeEndObject();
                        break;
                    case TEAM_LICENSE_LIMIT:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("team_license_limit");
                        g.writeStringField("team_license_limit", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                    case FREE_TEAM_MEMBER_LIMIT_REACHED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("free_team_member_limit_reached");
                        g.writeStringField("free_team_member_limit_reached", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                    case USER_ALREADY_ON_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_already_on_team");
                        g.writeStringField("user_already_on_team", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                    case USER_ON_ANOTHER_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_on_another_team");
                        g.writeStringField("user_on_another_team", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                    case USER_ALREADY_PAIRED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_already_paired");
                        g.writeStringField("user_already_paired", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                    case USER_MIGRATION_FAILED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_migration_failed");
                        g.writeStringField("user_migration_failed", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                    case DUPLICATE_EXTERNAL_MEMBER_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("duplicate_external_member_id");
                        g.writeStringField("duplicate_external_member_id", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                    case USER_CREATION_FAILED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_creation_failed");
                        g.writeStringField("user_creation_failed", x.teamLicenseLimitValue);
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MemberAddResult> _reader = new JsonReader<MemberAddResult>()
        {
            public final MemberAddResult read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MemberAddResult value = null;
                if (tag != null) {
                    switch (tag) {
                        case SUCCESS: {
                            TeamMemberInfo v = null;
                            v = TeamMemberInfo._reader.readFields(parser);
                            value = MemberAddResult.success(v);
                            break;
                        }
                        case TEAM_LICENSE_LIMIT: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "team_license_limit", v);
                            value = MemberAddResult.teamLicenseLimit(v);
                            break;
                        }
                        case FREE_TEAM_MEMBER_LIMIT_REACHED: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "free_team_member_limit_reached", v);
                            value = MemberAddResult.freeTeamMemberLimitReached(v);
                            break;
                        }
                        case USER_ALREADY_ON_TEAM: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "user_already_on_team", v);
                            value = MemberAddResult.userAlreadyOnTeam(v);
                            break;
                        }
                        case USER_ON_ANOTHER_TEAM: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "user_on_another_team", v);
                            value = MemberAddResult.userOnAnotherTeam(v);
                            break;
                        }
                        case USER_ALREADY_PAIRED: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "user_already_paired", v);
                            value = MemberAddResult.userAlreadyPaired(v);
                            break;
                        }
                        case USER_MIGRATION_FAILED: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "user_migration_failed", v);
                            value = MemberAddResult.userMigrationFailed(v);
                            break;
                        }
                        case DUPLICATE_EXTERNAL_MEMBER_ID: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "duplicate_external_member_id", v);
                            value = MemberAddResult.duplicateExternalMemberId(v);
                            break;
                        }
                        case USER_CREATION_FAILED: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "user_creation_failed", v);
                            value = MemberAddResult.userCreationFailed(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("success", Tag.SUCCESS);
            _values.put("team_license_limit", Tag.TEAM_LICENSE_LIMIT);
            _values.put("free_team_member_limit_reached", Tag.FREE_TEAM_MEMBER_LIMIT_REACHED);
            _values.put("user_already_on_team", Tag.USER_ALREADY_ON_TEAM);
            _values.put("user_on_another_team", Tag.USER_ON_ANOTHER_TEAM);
            _values.put("user_already_paired", Tag.USER_ALREADY_PAIRED);
            _values.put("user_migration_failed", Tag.USER_MIGRATION_FAILED);
            _values.put("duplicate_external_member_id", Tag.DUPLICATE_EXTERNAL_MEMBER_ID);
            _values.put("user_creation_failed", Tag.USER_CREATION_FAILED);
        }

        public String toString() {
            return "MemberAddResult." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MemberAddResult." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MemberAddResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersAddLaunch {
        // union MembersAddLaunch

        /**
         * The discriminating tag type for {@link MembersAddLaunch}.
         */
        public enum Tag {
            /**
             * This response indicates that the processing is asynchronous. The
             * string is an id that can be used to obtain the status of the
             * asynchronous job.
             */
            ASYNC_JOB_ID,  // String
            COMPLETE  // List
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersAddLaunch}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        private final String asyncJobIdValue;

        private MembersAddLaunch(Tag tag, String value) {
            this.tag = tag;
            this.asyncJobIdValue = value;
            this.completeValue = null;
            validate();
        }

        /**
         * This response indicates that the processing is asynchronous. The
         * string is an id that can be used to obtain the status of the
         * asynchronous job.
         *
         * <p> This instance must be tagged as {@link Tag#ASYNC_JOB_ID}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isAsyncJobId} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isAsyncJobId} is {@code
         *     false}.
         */
        public String getAsyncJobIdValue() {
            if (this.tag != Tag.ASYNC_JOB_ID) {
                throw new IllegalStateException("getAsyncJobIdValue() requires tag==ASYNC_JOB_ID, actual tag==" + tag);
            }
            return asyncJobIdValue;
        }

        /**
         * Returns an instance of {@code MembersAddLaunch} that has its tag set
         * to {@link Tag#ASYNC_JOB_ID}.
         *
         * <p> This response indicates that the processing is asynchronous. The
         * string is an id that can be used to obtain the status of the
         * asynchronous job. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MembersAddLaunch} with its tag set to
         *     {@link Tag#ASYNC_JOB_ID}.
         *
         * @throws IllegalArgumentException  if {@code value} is shorter than 1
         *     or is {@code null}.
         */
        public static MembersAddLaunch asyncJobId(String value) {
            return new MembersAddLaunch(Tag.ASYNC_JOB_ID, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#ASYNC_JOB_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#ASYNC_JOB_ID}, {@code false} otherwise.
         */
        public boolean isAsyncJobId() {
            return this.tag == Tag.ASYNC_JOB_ID;
        }

        private final java.util.List<MemberAddResult> completeValue;

        private MembersAddLaunch(Tag tag, java.util.List<MemberAddResult> value) {
            this.tag = tag;
            this.asyncJobIdValue = null;
            this.completeValue = value;
            validate();
        }

        /**
         * None
         *
         * <p> This instance must be tagged as {@link Tag#COMPLETE}. </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isComplete} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isComplete} is {@code
         *     false}.
         */
        public java.util.List<MemberAddResult> getCompleteValue() {
            if (this.tag != Tag.COMPLETE) {
                throw new IllegalStateException("getCompleteValue() requires tag==COMPLETE, actual tag==" + tag);
            }
            return completeValue;
        }

        /**
         * Returns an instance of {@code MembersAddLaunch} that has its tag set
         * to {@link Tag#COMPLETE}.
         *
         * <p> None </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code MembersAddLaunch} with its tag set to
         *     {@link Tag#COMPLETE}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static MembersAddLaunch complete(java.util.List<MemberAddResult> value) {
            return new MembersAddLaunch(Tag.COMPLETE, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#COMPLETE}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#COMPLETE}, {@code false} otherwise.
         */
        public boolean isComplete() {
            return this.tag == Tag.COMPLETE;
        }


        private final void validate() {
            switch (this.tag) {
                case ASYNC_JOB_ID:
                    if (this.asyncJobIdValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    if (this.asyncJobIdValue.length() < 1) {
                        throw new IllegalArgumentException("String is shorter than 1");
                    }
                    break;
                case COMPLETE:
                    if (this.completeValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (MemberAddResult x : this.completeValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
            }
        }

        static final JsonWriter<MembersAddLaunch> _writer = new JsonWriter<MembersAddLaunch>()
        {
            public final void write(MembersAddLaunch x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case ASYNC_JOB_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("async_job_id");
                        g.writeStringField("async_job_id", x.asyncJobIdValue);
                        g.writeEndObject();
                        break;
                    case COMPLETE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("complete");
                        g.writeFieldName("complete");
                        g.writeStartArray();
                        for (MemberAddResult item: x.completeValue) {
                            if (item != null) {
                                MemberAddResult._writer.write(item, g);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersAddLaunch> _reader = new JsonReader<MembersAddLaunch>()
        {
            public final MembersAddLaunch read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersAddLaunch value = null;
                if (tag != null) {
                    switch (tag) {
                        case ASYNC_JOB_ID: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "async_job_id", v);
                            value = MembersAddLaunch.asyncJobId(v);
                            break;
                        }
                        case COMPLETE: {
                            java.util.List<MemberAddResult> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(MemberAddResult._reader)
                                .readField(parser, "complete", v);
                            value = MembersAddLaunch.complete(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("complete", Tag.COMPLETE);
        }

        public String toString() {
            return "MembersAddLaunch." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersAddLaunch." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersAddLaunch fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersAddJobStatus {
        // union MembersAddJobStatus

        /**
         * The discriminating tag type for {@link MembersAddJobStatus}.
         */
        public enum Tag {
            /**
             * The asynchronous job is still in progress.
             */
            IN_PROGRESS,
            /**
             * The asynchronous job has finished. For each member that was
             * specified in the parameter {@link MembersAddArg} that was
             * provided to {@link DbxTeam#membersAdd(java.util.List,boolean)}, a
             * corresponding item is returned in this list.
             */
            COMPLETE,  // List
            /**
             * The asynchronous job returned an error. The string contains an
             * error message.
             */
            FAILED  // String
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersAddJobStatus}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * The asynchronous job is still in progress.
         */
        private static final MembersAddJobStatus IN_PROGRESS_INSTANCE = new MembersAddJobStatus(Tag.IN_PROGRESS);

        /**
         * Returns an instance of {@code MembersAddJobStatus} that has its tag
         * set to {@link Tag#IN_PROGRESS}.
         *
         * <p> The asynchronous job is still in progress. </p>
         *
         * @return Instance of {@code MembersAddJobStatus} with its tag set to
         *     {@link Tag#IN_PROGRESS}.
         */
        public static MembersAddJobStatus inProgress() {
            return MembersAddJobStatus.IN_PROGRESS_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#IN_PROGRESS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#IN_PROGRESS}, {@code false} otherwise.
         */
        public boolean isInProgress() {
            return this.tag == Tag.IN_PROGRESS;
        }

        private final java.util.List<MemberAddResult> completeValue;

        private MembersAddJobStatus(Tag tag, java.util.List<MemberAddResult> value) {
            this.tag = tag;
            this.completeValue = value;
            this.failedValue = null;
            validate();
        }

        /**
         * The asynchronous job has finished. For each member that was specified
         * in the parameter {@link MembersAddArg} that was provided to {@link
         * DbxTeam#membersAdd(java.util.List,boolean)}, a corresponding item is
         * returned in this list.
         *
         * <p> This instance must be tagged as {@link Tag#COMPLETE}. </p>
         *
         * @return The {@link java.util.List} value associated with this
         *     instance if {@link #isComplete} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isComplete} is {@code
         *     false}.
         */
        public java.util.List<MemberAddResult> getCompleteValue() {
            if (this.tag != Tag.COMPLETE) {
                throw new IllegalStateException("getCompleteValue() requires tag==COMPLETE, actual tag==" + tag);
            }
            return completeValue;
        }

        /**
         * Returns an instance of {@code MembersAddJobStatus} that has its tag
         * set to {@link Tag#COMPLETE}.
         *
         * <p> The asynchronous job has finished. For each member that was
         * specified in the parameter {@link MembersAddArg} that was provided to
         * {@link DbxTeam#membersAdd(java.util.List,boolean)}, a corresponding
         * item is returned in this list. </p>
         *
         * @param value  {@link java.util.List} value to assign to this
         *     instance.
         *
         * @return Instance of {@code MembersAddJobStatus} with its tag set to
         *     {@link Tag#COMPLETE}.
         *
         * @throws IllegalArgumentException  if {@code value} contains a {@code
         *     null} item or is {@code null}.
         */
        public static MembersAddJobStatus complete(java.util.List<MemberAddResult> value) {
            return new MembersAddJobStatus(Tag.COMPLETE, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#COMPLETE}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#COMPLETE}, {@code false} otherwise.
         */
        public boolean isComplete() {
            return this.tag == Tag.COMPLETE;
        }

        private final String failedValue;

        private MembersAddJobStatus(Tag tag, String value) {
            this.tag = tag;
            this.completeValue = null;
            this.failedValue = value;
            validate();
        }

        /**
         * The asynchronous job returned an error. The string contains an error
         * message.
         *
         * <p> This instance must be tagged as {@link Tag#FAILED}. </p>
         *
         * @return The {@link String} value associated with this instance if
         *     {@link #isFailed} is {@code true}.
         *
         * @throws IllegalStateException  If {@link #isFailed} is {@code false}.
         */
        public String getFailedValue() {
            if (this.tag != Tag.FAILED) {
                throw new IllegalStateException("getFailedValue() requires tag==FAILED, actual tag==" + tag);
            }
            return failedValue;
        }

        /**
         * Returns an instance of {@code MembersAddJobStatus} that has its tag
         * set to {@link Tag#FAILED}.
         *
         * <p> The asynchronous job returned an error. The string contains an
         * error message. </p>
         *
         * @param value  {@link String} value to assign to this instance.
         *
         * @return Instance of {@code MembersAddJobStatus} with its tag set to
         *     {@link Tag#FAILED}.
         *
         * @throws IllegalArgumentException  if {@code value} is {@code null}.
         */
        public static MembersAddJobStatus failed(String value) {
            return new MembersAddJobStatus(Tag.FAILED, value);
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#FAILED},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#FAILED}, {@code false} otherwise.
         */
        public boolean isFailed() {
            return this.tag == Tag.FAILED;
        }

        private MembersAddJobStatus(Tag t) {
            tag = t;
            completeValue = null;
            failedValue = null;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case IN_PROGRESS:
                    break;
                case COMPLETE:
                    if (this.completeValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    for (MemberAddResult x : this.completeValue) {
                        if (x == null) {
                            throw new IllegalArgumentException("An item in list is null");
                        }
                    }
                    break;
                case FAILED:
                    if (this.failedValue == null) {
                        throw new IllegalArgumentException("Value is null");
                    }
                    break;
            }
        }

        static final JsonWriter<MembersAddJobStatus> _writer = new JsonWriter<MembersAddJobStatus>()
        {
            public final void write(MembersAddJobStatus x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case IN_PROGRESS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("in_progress");
                        g.writeEndObject();
                        break;
                    case COMPLETE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("complete");
                        g.writeFieldName("complete");
                        g.writeStartArray();
                        for (MemberAddResult item: x.completeValue) {
                            if (item != null) {
                                MemberAddResult._writer.write(item, g);
                            }
                        }
                        g.writeEndArray();
                        g.writeEndObject();
                        break;
                    case FAILED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("failed");
                        g.writeStringField("failed", x.failedValue);
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersAddJobStatus> _reader = new JsonReader<MembersAddJobStatus>()
        {
            public final MembersAddJobStatus read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case IN_PROGRESS: return MembersAddJobStatus.inProgress();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersAddJobStatus value = null;
                if (tag != null) {
                    switch (tag) {
                        case IN_PROGRESS: {
                            value = MembersAddJobStatus.inProgress();
                            break;
                        }
                        case COMPLETE: {
                            java.util.List<MemberAddResult> v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonArrayReader.mk(MemberAddResult._reader)
                                .readField(parser, "complete", v);
                            value = MembersAddJobStatus.complete(v);
                            break;
                        }
                        case FAILED: {
                            String v = null;
                            assert parser.getCurrentToken() == JsonToken.FIELD_NAME;
                            text = parser.getText();
                            assert tags[0].equals(text);
                            parser.nextToken();
                            v = JsonReader.StringReader
                                .readField(parser, "failed", v);
                            value = MembersAddJobStatus.failed(v);
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("complete", Tag.COMPLETE);
            _values.put("failed", Tag.FAILED);
        }

        public String toString() {
            return "MembersAddJobStatus." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersAddJobStatus." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersAddJobStatus fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Exactly one of team_member_id, email, or external_id must be provided to
     * identify the user account. At least one of new_email, new_external_id,
     * new_given_name, and/or new_surname must be provided.
     */
    public static class MembersSetProfileArg {
        // struct MembersSetProfileArg
        /**
         * Identity of user whose profile will be set.
         */
        public final UserSelectorArg user;
        /**
         * New email for member.
         */
        public final String newEmail;
        /**
         * New external ID for member.
         */
        public final String newExternalId;
        /**
         * New given name for member.
         */
        public final String newGivenName;
        /**
         * New surname for member.
         */
        public final String newSurname;

        /**
         * Exactly one of team_member_id, email, or external_id must be provided
         * to identify the user account. At least one of new_email,
         * new_external_id, new_given_name, and/or new_surname must be provided.
         *
         * @param user  Identity of user whose profile will be set. {@code user}
         *     must not be {@code null}.
         * @param newEmail  New email for member.
         * @param newExternalId  New external ID for member.
         * @param newGivenName  New given name for member.
         * @param newSurname  New surname for member.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersSetProfileArg(UserSelectorArg user, String newEmail, String newExternalId, String newGivenName, String newSurname) {
            this.user = user;
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
            this.newEmail = newEmail;
            this.newExternalId = newExternalId;
            this.newGivenName = newGivenName;
            this.newSurname = newSurname;
        }

        static final JsonWriter<MembersSetProfileArg> _writer = new JsonWriter<MembersSetProfileArg>()
        {
            public final void write(MembersSetProfileArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersSetProfileArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersSetProfileArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("user");
                UserSelectorArg._writer.write(x.user, g);
                if (x.newEmail != null) {
                    g.writeFieldName("new_email");
                    g.writeString(x.newEmail);
                }
                if (x.newExternalId != null) {
                    g.writeFieldName("new_external_id");
                    g.writeString(x.newExternalId);
                }
                if (x.newGivenName != null) {
                    g.writeFieldName("new_given_name");
                    g.writeString(x.newGivenName);
                }
                if (x.newSurname != null) {
                    g.writeFieldName("new_surname");
                    g.writeString(x.newSurname);
                }
            }
        };

        public static final JsonReader<MembersSetProfileArg> _reader = new JsonReader<MembersSetProfileArg>() {

            public final MembersSetProfileArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersSetProfileArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersSetProfileArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                UserSelectorArg user = null;
                String newEmail = null;
                String newExternalId = null;
                String newGivenName = null;
                String newSurname = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else if ("new_email".equals(fieldName)) {
                        newEmail = JsonReader.StringReader
                            .readField(parser, "new_email", newEmail);
                    }
                    else if ("new_external_id".equals(fieldName)) {
                        newExternalId = JsonReader.StringReader
                            .readField(parser, "new_external_id", newExternalId);
                    }
                    else if ("new_given_name".equals(fieldName)) {
                        newGivenName = JsonReader.StringReader
                            .readField(parser, "new_given_name", newGivenName);
                    }
                    else if ("new_surname".equals(fieldName)) {
                        newSurname = JsonReader.StringReader
                            .readField(parser, "new_surname", newSurname);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                return new MembersSetProfileArg(user, newEmail, newExternalId, newGivenName, newSurname);
            }
        };

        public String toString() {
            return "MembersSetProfileArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersSetProfileArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersSetProfileArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersSetProfileError {
        // union MembersSetProfileError

        /**
         * The discriminating tag type for {@link MembersSetProfileError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM,
            /**
             * It is unsafe to use both external_id and new_external_id
             */
            EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE,
            /**
             * None of new_email, new_given_name, new_surname, or
             * new_external_id are specified
             */
            NO_NEW_DATA_SPECIFIED,
            /**
             * Email is already reserved for another user.
             */
            EMAIL_RESERVED_FOR_OTHER_USER,
            /**
             * The external ID is already in use by another team member.
             */
            EXTERNAL_ID_USED_BY_OTHER_USER,
            /**
             * Setting profile disallowed
             */
            SET_PROFILE_DISALLOWED,
            /**
             * New  new_email, new_given_name or new_surname value cannot be
             * empty.
             */
            PARAM_CANNOT_BE_EMPTY,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersSetProfileError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MembersSetProfileError USER_NOT_FOUND_INSTANCE = new MembersSetProfileError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#USER_NOT_FOUND}.
         */
        public static MembersSetProfileError userNotFound() {
            return MembersSetProfileError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MembersSetProfileError USER_NOT_IN_TEAM_INSTANCE = new MembersSetProfileError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MembersSetProfileError userNotInTeam() {
            return MembersSetProfileError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        /**
         * It is unsafe to use both external_id and new_external_id
         */
        private static final MembersSetProfileError EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE_INSTANCE = new MembersSetProfileError(Tag.EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE}.
         *
         * <p> It is unsafe to use both external_id and new_external_id </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE}.
         */
        public static MembersSetProfileError externalIdAndNewExternalIdUnsafe() {
            return MembersSetProfileError.EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE}, {@code false}
         *     otherwise.
         */
        public boolean isExternalIdAndNewExternalIdUnsafe() {
            return this.tag == Tag.EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE;
        }

        /**
         * None of new_email, new_given_name, new_surname, or new_external_id
         * are specified
         */
        private static final MembersSetProfileError NO_NEW_DATA_SPECIFIED_INSTANCE = new MembersSetProfileError(Tag.NO_NEW_DATA_SPECIFIED);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#NO_NEW_DATA_SPECIFIED}.
         *
         * <p> None of new_email, new_given_name, new_surname, or
         * new_external_id are specified </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#NO_NEW_DATA_SPECIFIED}.
         */
        public static MembersSetProfileError noNewDataSpecified() {
            return MembersSetProfileError.NO_NEW_DATA_SPECIFIED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#NO_NEW_DATA_SPECIFIED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#NO_NEW_DATA_SPECIFIED}, {@code false} otherwise.
         */
        public boolean isNoNewDataSpecified() {
            return this.tag == Tag.NO_NEW_DATA_SPECIFIED;
        }

        /**
         * Email is already reserved for another user.
         */
        private static final MembersSetProfileError EMAIL_RESERVED_FOR_OTHER_USER_INSTANCE = new MembersSetProfileError(Tag.EMAIL_RESERVED_FOR_OTHER_USER);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#EMAIL_RESERVED_FOR_OTHER_USER}.
         *
         * <p> Email is already reserved for another user. </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#EMAIL_RESERVED_FOR_OTHER_USER}.
         */
        public static MembersSetProfileError emailReservedForOtherUser() {
            return MembersSetProfileError.EMAIL_RESERVED_FOR_OTHER_USER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#EMAIL_RESERVED_FOR_OTHER_USER}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EMAIL_RESERVED_FOR_OTHER_USER}, {@code false} otherwise.
         */
        public boolean isEmailReservedForOtherUser() {
            return this.tag == Tag.EMAIL_RESERVED_FOR_OTHER_USER;
        }

        /**
         * The external ID is already in use by another team member.
         */
        private static final MembersSetProfileError EXTERNAL_ID_USED_BY_OTHER_USER_INSTANCE = new MembersSetProfileError(Tag.EXTERNAL_ID_USED_BY_OTHER_USER);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#EXTERNAL_ID_USED_BY_OTHER_USER}.
         *
         * <p> The external ID is already in use by another team member. </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#EXTERNAL_ID_USED_BY_OTHER_USER}.
         */
        public static MembersSetProfileError externalIdUsedByOtherUser() {
            return MembersSetProfileError.EXTERNAL_ID_USED_BY_OTHER_USER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#EXTERNAL_ID_USED_BY_OTHER_USER}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#EXTERNAL_ID_USED_BY_OTHER_USER}, {@code false} otherwise.
         */
        public boolean isExternalIdUsedByOtherUser() {
            return this.tag == Tag.EXTERNAL_ID_USED_BY_OTHER_USER;
        }

        /**
         * Setting profile disallowed
         */
        private static final MembersSetProfileError SET_PROFILE_DISALLOWED_INSTANCE = new MembersSetProfileError(Tag.SET_PROFILE_DISALLOWED);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#SET_PROFILE_DISALLOWED}.
         *
         * <p> Setting profile disallowed </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#SET_PROFILE_DISALLOWED}.
         */
        public static MembersSetProfileError setProfileDisallowed() {
            return MembersSetProfileError.SET_PROFILE_DISALLOWED_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#SET_PROFILE_DISALLOWED}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#SET_PROFILE_DISALLOWED}, {@code false} otherwise.
         */
        public boolean isSetProfileDisallowed() {
            return this.tag == Tag.SET_PROFILE_DISALLOWED;
        }

        /**
         * New  new_email, new_given_name or new_surname value cannot be empty.
         */
        private static final MembersSetProfileError PARAM_CANNOT_BE_EMPTY_INSTANCE = new MembersSetProfileError(Tag.PARAM_CANNOT_BE_EMPTY);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#PARAM_CANNOT_BE_EMPTY}.
         *
         * <p> New  new_email, new_given_name or new_surname value cannot be
         * empty. </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#PARAM_CANNOT_BE_EMPTY}.
         */
        public static MembersSetProfileError paramCannotBeEmpty() {
            return MembersSetProfileError.PARAM_CANNOT_BE_EMPTY_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#PARAM_CANNOT_BE_EMPTY}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#PARAM_CANNOT_BE_EMPTY}, {@code false} otherwise.
         */
        public boolean isParamCannotBeEmpty() {
            return this.tag == Tag.PARAM_CANNOT_BE_EMPTY;
        }

        /**
         * An unspecified error.
         */
        private static final MembersSetProfileError OTHER_INSTANCE = new MembersSetProfileError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersSetProfileError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersSetProfileError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static MembersSetProfileError other() {
            return MembersSetProfileError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MembersSetProfileError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case USER_NOT_IN_TEAM:
                case EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE:
                case NO_NEW_DATA_SPECIFIED:
                case EMAIL_RESERVED_FOR_OTHER_USER:
                case EXTERNAL_ID_USED_BY_OTHER_USER:
                case SET_PROFILE_DISALLOWED:
                case PARAM_CANNOT_BE_EMPTY:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MembersSetProfileError> _writer = new JsonWriter<MembersSetProfileError>()
        {
            public final void write(MembersSetProfileError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                    case EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("external_id_and_new_external_id_unsafe");
                        g.writeEndObject();
                        break;
                    case NO_NEW_DATA_SPECIFIED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("no_new_data_specified");
                        g.writeEndObject();
                        break;
                    case EMAIL_RESERVED_FOR_OTHER_USER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("email_reserved_for_other_user");
                        g.writeEndObject();
                        break;
                    case EXTERNAL_ID_USED_BY_OTHER_USER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("external_id_used_by_other_user");
                        g.writeEndObject();
                        break;
                    case SET_PROFILE_DISALLOWED:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("set_profile_disallowed");
                        g.writeEndObject();
                        break;
                    case PARAM_CANNOT_BE_EMPTY:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("param_cannot_be_empty");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersSetProfileError> _reader = new JsonReader<MembersSetProfileError>()
        {
            public final MembersSetProfileError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MembersSetProfileError.other(); }
                    switch (tag) {
                        case USER_NOT_FOUND: return MembersSetProfileError.userNotFound();
                        case USER_NOT_IN_TEAM: return MembersSetProfileError.userNotInTeam();
                        case EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE: return MembersSetProfileError.externalIdAndNewExternalIdUnsafe();
                        case NO_NEW_DATA_SPECIFIED: return MembersSetProfileError.noNewDataSpecified();
                        case EMAIL_RESERVED_FOR_OTHER_USER: return MembersSetProfileError.emailReservedForOtherUser();
                        case EXTERNAL_ID_USED_BY_OTHER_USER: return MembersSetProfileError.externalIdUsedByOtherUser();
                        case SET_PROFILE_DISALLOWED: return MembersSetProfileError.setProfileDisallowed();
                        case PARAM_CANNOT_BE_EMPTY: return MembersSetProfileError.paramCannotBeEmpty();
                        case OTHER: return MembersSetProfileError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersSetProfileError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MembersSetProfileError.userNotFound();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MembersSetProfileError.userNotInTeam();
                            break;
                        }
                        case EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE: {
                            value = MembersSetProfileError.externalIdAndNewExternalIdUnsafe();
                            break;
                        }
                        case NO_NEW_DATA_SPECIFIED: {
                            value = MembersSetProfileError.noNewDataSpecified();
                            break;
                        }
                        case EMAIL_RESERVED_FOR_OTHER_USER: {
                            value = MembersSetProfileError.emailReservedForOtherUser();
                            break;
                        }
                        case EXTERNAL_ID_USED_BY_OTHER_USER: {
                            value = MembersSetProfileError.externalIdUsedByOtherUser();
                            break;
                        }
                        case SET_PROFILE_DISALLOWED: {
                            value = MembersSetProfileError.setProfileDisallowed();
                            break;
                        }
                        case PARAM_CANNOT_BE_EMPTY: {
                            value = MembersSetProfileError.paramCannotBeEmpty();
                            break;
                        }
                        case OTHER: {
                            value = MembersSetProfileError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MembersSetProfileError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("external_id_and_new_external_id_unsafe", Tag.EXTERNAL_ID_AND_NEW_EXTERNAL_ID_UNSAFE);
            _values.put("no_new_data_specified", Tag.NO_NEW_DATA_SPECIFIED);
            _values.put("email_reserved_for_other_user", Tag.EMAIL_RESERVED_FOR_OTHER_USER);
            _values.put("external_id_used_by_other_user", Tag.EXTERNAL_ID_USED_BY_OTHER_USER);
            _values.put("set_profile_disallowed", Tag.SET_PROFILE_DISALLOWED);
            _values.put("param_cannot_be_empty", Tag.PARAM_CANNOT_BE_EMPTY);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MembersSetProfileError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersSetProfileError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersSetProfileError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Exactly one of team_member_id, email, or external_id must be provided to
     * identify the user account.
     */
    public static class MembersSetPermissionsArg {
        // struct MembersSetPermissionsArg
        /**
         * Identity of user whose role will be set.
         */
        public final UserSelectorArg user;
        /**
         * The new role of the member.
         */
        public final AdminTier newRole;

        /**
         * Exactly one of team_member_id, email, or external_id must be provided
         * to identify the user account.
         *
         * @param user  Identity of user whose role will be set. {@code user}
         *     must not be {@code null}.
         * @param newRole  The new role of the member. {@code newRole} must not
         *     be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersSetPermissionsArg(UserSelectorArg user, AdminTier newRole) {
            this.user = user;
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
            this.newRole = newRole;
            if (newRole == null) {
                throw new IllegalArgumentException("Required value for 'newRole' is null");
            }
        }

        static final JsonWriter<MembersSetPermissionsArg> _writer = new JsonWriter<MembersSetPermissionsArg>()
        {
            public final void write(MembersSetPermissionsArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersSetPermissionsArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersSetPermissionsArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("user");
                UserSelectorArg._writer.write(x.user, g);
                g.writeFieldName("new_role");
                AdminTier._writer.write(x.newRole, g);
            }
        };

        public static final JsonReader<MembersSetPermissionsArg> _reader = new JsonReader<MembersSetPermissionsArg>() {

            public final MembersSetPermissionsArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersSetPermissionsArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersSetPermissionsArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                UserSelectorArg user = null;
                AdminTier newRole = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else if ("new_role".equals(fieldName)) {
                        newRole = AdminTier._reader
                            .readField(parser, "new_role", newRole);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                if (newRole == null) {
                    throw new JsonReadException("Required field \"new_role\" is missing.", parser.getTokenLocation());
                }
                return new MembersSetPermissionsArg(user, newRole);
            }
        };

        public String toString() {
            return "MembersSetPermissionsArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersSetPermissionsArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersSetPermissionsArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MembersSetPermissionsResult {
        // struct MembersSetPermissionsResult
        /**
         * The member ID of the user to which the change was applied.
         */
        public final String teamMemberId;
        /**
         * The role after the change.
         */
        public final AdminTier role;

        /**
         *
         * @param teamMemberId  The member ID of the user to which the change
         *     was applied. {@code teamMemberId} must not be {@code null}.
         * @param role  The role after the change. {@code role} must not be
         *     {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersSetPermissionsResult(String teamMemberId, AdminTier role) {
            this.teamMemberId = teamMemberId;
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
            this.role = role;
            if (role == null) {
                throw new IllegalArgumentException("Required value for 'role' is null");
            }
        }

        static final JsonWriter<MembersSetPermissionsResult> _writer = new JsonWriter<MembersSetPermissionsResult>()
        {
            public final void write(MembersSetPermissionsResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersSetPermissionsResult._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersSetPermissionsResult x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("team_member_id", x.teamMemberId);
                g.writeFieldName("role");
                AdminTier._writer.write(x.role, g);
            }
        };

        public static final JsonReader<MembersSetPermissionsResult> _reader = new JsonReader<MembersSetPermissionsResult>() {

            public final MembersSetPermissionsResult read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersSetPermissionsResult result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersSetPermissionsResult readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String teamMemberId = null;
                AdminTier role = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("team_member_id".equals(fieldName)) {
                        teamMemberId = JsonReader.StringReader
                            .readField(parser, "team_member_id", teamMemberId);
                    }
                    else if ("role".equals(fieldName)) {
                        role = AdminTier._reader
                            .readField(parser, "role", role);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (teamMemberId == null) {
                    throw new JsonReadException("Required field \"team_member_id\" is missing.", parser.getTokenLocation());
                }
                if (role == null) {
                    throw new JsonReadException("Required field \"role\" is missing.", parser.getTokenLocation());
                }
                return new MembersSetPermissionsResult(teamMemberId, role);
            }
        };

        public String toString() {
            return "MembersSetPermissionsResult." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersSetPermissionsResult." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersSetPermissionsResult fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersSetPermissionsError {
        // union MembersSetPermissionsError

        /**
         * The discriminating tag type for {@link MembersSetPermissionsError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * Cannot remove the admin setting of the last admin.
             */
            LAST_ADMIN,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM,
            /**
             * Cannot remove/grant permissions.
             */
            CANNOT_SET_PERMISSIONS,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersSetPermissionsError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MembersSetPermissionsError USER_NOT_FOUND_INSTANCE = new MembersSetPermissionsError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersSetPermissionsError} that has
         * its tag set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersSetPermissionsError} with its tag
         *     set to {@link Tag#USER_NOT_FOUND}.
         */
        public static MembersSetPermissionsError userNotFound() {
            return MembersSetPermissionsError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * Cannot remove the admin setting of the last admin.
         */
        private static final MembersSetPermissionsError LAST_ADMIN_INSTANCE = new MembersSetPermissionsError(Tag.LAST_ADMIN);

        /**
         * Returns an instance of {@code MembersSetPermissionsError} that has
         * its tag set to {@link Tag#LAST_ADMIN}.
         *
         * <p> Cannot remove the admin setting of the last admin. </p>
         *
         * @return Instance of {@code MembersSetPermissionsError} with its tag
         *     set to {@link Tag#LAST_ADMIN}.
         */
        public static MembersSetPermissionsError lastAdmin() {
            return MembersSetPermissionsError.LAST_ADMIN_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#LAST_ADMIN}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#LAST_ADMIN}, {@code false} otherwise.
         */
        public boolean isLastAdmin() {
            return this.tag == Tag.LAST_ADMIN;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MembersSetPermissionsError USER_NOT_IN_TEAM_INSTANCE = new MembersSetPermissionsError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersSetPermissionsError} that has
         * its tag set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MembersSetPermissionsError} with its tag
         *     set to {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MembersSetPermissionsError userNotInTeam() {
            return MembersSetPermissionsError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        /**
         * Cannot remove/grant permissions.
         */
        private static final MembersSetPermissionsError CANNOT_SET_PERMISSIONS_INSTANCE = new MembersSetPermissionsError(Tag.CANNOT_SET_PERMISSIONS);

        /**
         * Returns an instance of {@code MembersSetPermissionsError} that has
         * its tag set to {@link Tag#CANNOT_SET_PERMISSIONS}.
         *
         * <p> Cannot remove/grant permissions. </p>
         *
         * @return Instance of {@code MembersSetPermissionsError} with its tag
         *     set to {@link Tag#CANNOT_SET_PERMISSIONS}.
         */
        public static MembersSetPermissionsError cannotSetPermissions() {
            return MembersSetPermissionsError.CANNOT_SET_PERMISSIONS_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#CANNOT_SET_PERMISSIONS}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#CANNOT_SET_PERMISSIONS}, {@code false} otherwise.
         */
        public boolean isCannotSetPermissions() {
            return this.tag == Tag.CANNOT_SET_PERMISSIONS;
        }

        /**
         * An unspecified error.
         */
        private static final MembersSetPermissionsError OTHER_INSTANCE = new MembersSetPermissionsError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersSetPermissionsError} that has
         * its tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersSetPermissionsError} with its tag
         *     set to {@link Tag#OTHER}.
         */
        public static MembersSetPermissionsError other() {
            return MembersSetPermissionsError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MembersSetPermissionsError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case LAST_ADMIN:
                case USER_NOT_IN_TEAM:
                case CANNOT_SET_PERMISSIONS:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MembersSetPermissionsError> _writer = new JsonWriter<MembersSetPermissionsError>()
        {
            public final void write(MembersSetPermissionsError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case LAST_ADMIN:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("last_admin");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                    case CANNOT_SET_PERMISSIONS:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("cannot_set_permissions");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersSetPermissionsError> _reader = new JsonReader<MembersSetPermissionsError>()
        {
            public final MembersSetPermissionsError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MembersSetPermissionsError.other(); }
                    switch (tag) {
                        case USER_NOT_FOUND: return MembersSetPermissionsError.userNotFound();
                        case LAST_ADMIN: return MembersSetPermissionsError.lastAdmin();
                        case USER_NOT_IN_TEAM: return MembersSetPermissionsError.userNotInTeam();
                        case CANNOT_SET_PERMISSIONS: return MembersSetPermissionsError.cannotSetPermissions();
                        case OTHER: return MembersSetPermissionsError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersSetPermissionsError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MembersSetPermissionsError.userNotFound();
                            break;
                        }
                        case LAST_ADMIN: {
                            value = MembersSetPermissionsError.lastAdmin();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MembersSetPermissionsError.userNotInTeam();
                            break;
                        }
                        case CANNOT_SET_PERMISSIONS: {
                            value = MembersSetPermissionsError.cannotSetPermissions();
                            break;
                        }
                        case OTHER: {
                            value = MembersSetPermissionsError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MembersSetPermissionsError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("last_admin", Tag.LAST_ADMIN);
            _values.put("user_not_in_team", Tag.USER_NOT_IN_TEAM);
            _values.put("cannot_set_permissions", Tag.CANNOT_SET_PERMISSIONS);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MembersSetPermissionsError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersSetPermissionsError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersSetPermissionsError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersSendWelcomeError {
        // union MembersSendWelcomeError

        /**
         * The discriminating tag type for {@link MembersSendWelcomeError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersSendWelcomeError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MembersSendWelcomeError USER_NOT_FOUND_INSTANCE = new MembersSendWelcomeError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersSendWelcomeError} that has its
         * tag set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersSendWelcomeError} with its tag set
         *     to {@link Tag#USER_NOT_FOUND}.
         */
        public static MembersSendWelcomeError userNotFound() {
            return MembersSendWelcomeError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MembersSendWelcomeError USER_NOT_IN_TEAM_INSTANCE = new MembersSendWelcomeError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersSendWelcomeError} that has its
         * tag set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MembersSendWelcomeError} with its tag set
         *     to {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MembersSendWelcomeError userNotInTeam() {
            return MembersSendWelcomeError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        /**
         * An unspecified error.
         */
        private static final MembersSendWelcomeError OTHER_INSTANCE = new MembersSendWelcomeError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersSendWelcomeError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersSendWelcomeError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static MembersSendWelcomeError other() {
            return MembersSendWelcomeError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MembersSendWelcomeError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case USER_NOT_IN_TEAM:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MembersSendWelcomeError> _writer = new JsonWriter<MembersSendWelcomeError>()
        {
            public final void write(MembersSendWelcomeError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersSendWelcomeError> _reader = new JsonReader<MembersSendWelcomeError>()
        {
            public final MembersSendWelcomeError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MembersSendWelcomeError.other(); }
                    switch (tag) {
                        case USER_NOT_FOUND: return MembersSendWelcomeError.userNotFound();
                        case USER_NOT_IN_TEAM: return MembersSendWelcomeError.userNotInTeam();
                        case OTHER: return MembersSendWelcomeError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersSendWelcomeError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MembersSendWelcomeError.userNotFound();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MembersSendWelcomeError.userNotInTeam();
                            break;
                        }
                        case OTHER: {
                            value = MembersSendWelcomeError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MembersSendWelcomeError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MembersSendWelcomeError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersSendWelcomeError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersSendWelcomeError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Exactly one of team_member_id, email, or external_id must be provided to
     * identify the user account.
     */
    public static class MembersDeactivateArg {
        // struct MembersDeactivateArg
        /**
         * Identity of user to remove/suspend.
         */
        public final UserSelectorArg user;
        /**
         * If provided, controls if the user's data will be deleted on their
         * linked devices.
         */
        public final boolean wipeData;

        /**
         * Exactly one of team_member_id, email, or external_id must be provided
         * to identify the user account.
         *
         * @param user  Identity of user to remove/suspend. {@code user} must
         *     not be {@code null}.
         * @param wipeData  If provided, controls if the user's data will be
         *     deleted on their linked devices.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersDeactivateArg(UserSelectorArg user, Boolean wipeData) {
            this.user = user;
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
            if (wipeData != null) {
                this.wipeData = wipeData.booleanValue();
            }
            else {
                this.wipeData = true;
            }
        }

        static final JsonWriter<MembersDeactivateArg> _writer = new JsonWriter<MembersDeactivateArg>()
        {
            public final void write(MembersDeactivateArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersDeactivateArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersDeactivateArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("user");
                UserSelectorArg._writer.write(x.user, g);
                g.writeBooleanField("wipe_data", x.wipeData);
            }
        };

        public static final JsonReader<MembersDeactivateArg> _reader = new JsonReader<MembersDeactivateArg>() {

            public final MembersDeactivateArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersDeactivateArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersDeactivateArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                UserSelectorArg user = null;
                Boolean wipeData = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else if ("wipe_data".equals(fieldName)) {
                        wipeData = JsonReader.BooleanReader
                            .readField(parser, "wipe_data", wipeData);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                return new MembersDeactivateArg(user, wipeData);
            }
        };

        public String toString() {
            return "MembersDeactivateArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersDeactivateArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersDeactivateArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static class MembersRemoveArg extends MembersDeactivateArg  {
        // struct MembersRemoveArg
        /**
         * If provided, files from the deleted member account will be
         * transferred to this user.
         */
        public final UserSelectorArg transferDestId;
        /**
         * If provided, errors during the transfer process will be sent via
         * email to this user. If the transfer_dest_id argument was provided,
         * then this argument must be provided as well.
         */
        public final UserSelectorArg transferAdminId;

        /**
         *
         * @param user  Identity of user to remove/suspend. {@code user} must
         *     not be {@code null}.
         * @param wipeData  If provided, controls if the user's data will be
         *     deleted on their linked devices.
         * @param transferDestId  If provided, files from the deleted member
         *     account will be transferred to this user.
         * @param transferAdminId  If provided, errors during the transfer
         *     process will be sent via email to this user. If the
         *     transfer_dest_id argument was provided, then this argument must
         *     be provided as well.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersRemoveArg(UserSelectorArg user, Boolean wipeData, UserSelectorArg transferDestId, UserSelectorArg transferAdminId) {
            super(user, wipeData);
            this.transferDestId = transferDestId;
            this.transferAdminId = transferAdminId;
        }

        static final JsonWriter<MembersRemoveArg> _writer = new JsonWriter<MembersRemoveArg>()
        {
            public final void write(MembersRemoveArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersDeactivateArg._writer.writeFields(x, g);
                MembersRemoveArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersRemoveArg x, JsonGenerator g)
             throws IOException
            {
                if (x.transferDestId != null) {
                    g.writeFieldName("transfer_dest_id");
                    UserSelectorArg._writer.write(x.transferDestId, g);
                }
                if (x.transferAdminId != null) {
                    g.writeFieldName("transfer_admin_id");
                    UserSelectorArg._writer.write(x.transferAdminId, g);
                }
            }
        };

        public static final JsonReader<MembersRemoveArg> _reader = new JsonReader<MembersRemoveArg>() {

            public final MembersRemoveArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersRemoveArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersRemoveArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                UserSelectorArg user = null;
                Boolean wipeData = null;
                UserSelectorArg transferDestId = null;
                UserSelectorArg transferAdminId = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else if ("wipe_data".equals(fieldName)) {
                        wipeData = JsonReader.BooleanReader
                            .readField(parser, "wipe_data", wipeData);
                    }
                    else if ("transfer_dest_id".equals(fieldName)) {
                        transferDestId = UserSelectorArg._reader
                            .readField(parser, "transfer_dest_id", transferDestId);
                    }
                    else if ("transfer_admin_id".equals(fieldName)) {
                        transferAdminId = UserSelectorArg._reader
                            .readField(parser, "transfer_admin_id", transferAdminId);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                return new MembersRemoveArg(user, wipeData, transferDestId, transferAdminId);
            }
        };

        public String toString() {
            return "MembersRemoveArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersRemoveArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersRemoveArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersDeactivateError {
        // union MembersDeactivateError

        /**
         * The discriminating tag type for {@link MembersDeactivateError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM,
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersDeactivateError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MembersDeactivateError USER_NOT_FOUND_INSTANCE = new MembersDeactivateError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersDeactivateError} that has its
         * tag set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersDeactivateError} with its tag set
         *     to {@link Tag#USER_NOT_FOUND}.
         */
        public static MembersDeactivateError userNotFound() {
            return MembersDeactivateError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MembersDeactivateError USER_NOT_IN_TEAM_INSTANCE = new MembersDeactivateError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersDeactivateError} that has its
         * tag set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MembersDeactivateError} with its tag set
         *     to {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MembersDeactivateError userNotInTeam() {
            return MembersDeactivateError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        /**
         * An unspecified error.
         */
        private static final MembersDeactivateError OTHER_INSTANCE = new MembersDeactivateError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersDeactivateError} that has its
         * tag set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersDeactivateError} with its tag set
         *     to {@link Tag#OTHER}.
         */
        public static MembersDeactivateError other() {
            return MembersDeactivateError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private MembersDeactivateError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case USER_NOT_IN_TEAM:
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<MembersDeactivateError> _writer = new JsonWriter<MembersDeactivateError>()
        {
            public final void write(MembersDeactivateError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersDeactivateError> _reader = new JsonReader<MembersDeactivateError>()
        {
            public final MembersDeactivateError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return MembersDeactivateError.other(); }
                    switch (tag) {
                        case USER_NOT_FOUND: return MembersDeactivateError.userNotFound();
                        case USER_NOT_IN_TEAM: return MembersDeactivateError.userNotInTeam();
                        case OTHER: return MembersDeactivateError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersDeactivateError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MembersDeactivateError.userNotFound();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MembersDeactivateError.userNotInTeam();
                            break;
                        }
                        case OTHER: {
                            value = MembersDeactivateError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return MembersDeactivateError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("user_not_in_team", Tag.USER_NOT_IN_TEAM);
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "MembersDeactivateError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersDeactivateError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersDeactivateError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersRemoveError {
        // union MembersRemoveError

        /**
         * The discriminating tag type for {@link MembersRemoveError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM,
            /**
             * An unspecified error.
             */
            OTHER,
            /**
             * The user is the last admin of the team, so it cannot be removed
             * from it.
             */
            REMOVE_LAST_ADMIN,
            /**
             * Expected removed user and transfer_dest user to be different
             */
            REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER,
            /**
             * Expected removed user and transfer_admin user to be different.
             */
            REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER,
            /**
             * No matching user found for the argument transfer_dest_id.
             */
            TRANSFER_DEST_USER_NOT_FOUND,
            /**
             * The provided transfer_dest_id does not exist on this team.
             */
            TRANSFER_DEST_USER_NOT_IN_TEAM,
            /**
             * No matching user found for the argument transfer_admin_id.
             */
            TRANSFER_ADMIN_USER_NOT_FOUND,
            /**
             * The provided transfer_admin_id does not exist on this team.
             */
            TRANSFER_ADMIN_USER_NOT_IN_TEAM,
            /**
             * The transfer_admin_id argument must be provided when file
             * transfer is requested.
             */
            UNSPECIFIED_TRANSFER_ADMIN_ID,
            /**
             * Specified transfer_admin user is not a team admin.
             */
            TRANSFER_ADMIN_IS_NOT_ADMIN
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersRemoveError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MembersRemoveError USER_NOT_FOUND_INSTANCE = new MembersRemoveError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#USER_NOT_FOUND}.
         */
        public static MembersRemoveError userNotFound() {
            return MembersRemoveError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MembersRemoveError USER_NOT_IN_TEAM_INSTANCE = new MembersRemoveError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MembersRemoveError userNotInTeam() {
            return MembersRemoveError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        /**
         * An unspecified error.
         */
        private static final MembersRemoveError OTHER_INSTANCE = new MembersRemoveError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static MembersRemoveError other() {
            return MembersRemoveError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * The user is the last admin of the team, so it cannot be removed from
         * it.
         */
        private static final MembersRemoveError REMOVE_LAST_ADMIN_INSTANCE = new MembersRemoveError(Tag.REMOVE_LAST_ADMIN);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#REMOVE_LAST_ADMIN}.
         *
         * <p> The user is the last admin of the team, so it cannot be removed
         * from it. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#REMOVE_LAST_ADMIN}.
         */
        public static MembersRemoveError removeLastAdmin() {
            return MembersRemoveError.REMOVE_LAST_ADMIN_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#REMOVE_LAST_ADMIN}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#REMOVE_LAST_ADMIN}, {@code false} otherwise.
         */
        public boolean isRemoveLastAdmin() {
            return this.tag == Tag.REMOVE_LAST_ADMIN;
        }

        /**
         * Expected removed user and transfer_dest user to be different
         */
        private static final MembersRemoveError REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER_INSTANCE = new MembersRemoveError(Tag.REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER}.
         *
         * <p> Expected removed user and transfer_dest user to be different </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER}.
         */
        public static MembersRemoveError removedAndTransferDestShouldDiffer() {
            return MembersRemoveError.REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER}, {@code false}
         * otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER}, {@code false}
         *     otherwise.
         */
        public boolean isRemovedAndTransferDestShouldDiffer() {
            return this.tag == Tag.REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER;
        }

        /**
         * Expected removed user and transfer_admin user to be different.
         */
        private static final MembersRemoveError REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER_INSTANCE = new MembersRemoveError(Tag.REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER}.
         *
         * <p> Expected removed user and transfer_admin user to be different.
         * </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER}.
         */
        public static MembersRemoveError removedAndTransferAdminShouldDiffer() {
            return MembersRemoveError.REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER}, {@code false}
         * otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER}, {@code false}
         *     otherwise.
         */
        public boolean isRemovedAndTransferAdminShouldDiffer() {
            return this.tag == Tag.REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER;
        }

        /**
         * No matching user found for the argument transfer_dest_id.
         */
        private static final MembersRemoveError TRANSFER_DEST_USER_NOT_FOUND_INSTANCE = new MembersRemoveError(Tag.TRANSFER_DEST_USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#TRANSFER_DEST_USER_NOT_FOUND}.
         *
         * <p> No matching user found for the argument transfer_dest_id. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#TRANSFER_DEST_USER_NOT_FOUND}.
         */
        public static MembersRemoveError transferDestUserNotFound() {
            return MembersRemoveError.TRANSFER_DEST_USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TRANSFER_DEST_USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TRANSFER_DEST_USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isTransferDestUserNotFound() {
            return this.tag == Tag.TRANSFER_DEST_USER_NOT_FOUND;
        }

        /**
         * The provided transfer_dest_id does not exist on this team.
         */
        private static final MembersRemoveError TRANSFER_DEST_USER_NOT_IN_TEAM_INSTANCE = new MembersRemoveError(Tag.TRANSFER_DEST_USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#TRANSFER_DEST_USER_NOT_IN_TEAM}.
         *
         * <p> The provided transfer_dest_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#TRANSFER_DEST_USER_NOT_IN_TEAM}.
         */
        public static MembersRemoveError transferDestUserNotInTeam() {
            return MembersRemoveError.TRANSFER_DEST_USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TRANSFER_DEST_USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TRANSFER_DEST_USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isTransferDestUserNotInTeam() {
            return this.tag == Tag.TRANSFER_DEST_USER_NOT_IN_TEAM;
        }

        /**
         * No matching user found for the argument transfer_admin_id.
         */
        private static final MembersRemoveError TRANSFER_ADMIN_USER_NOT_FOUND_INSTANCE = new MembersRemoveError(Tag.TRANSFER_ADMIN_USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#TRANSFER_ADMIN_USER_NOT_FOUND}.
         *
         * <p> No matching user found for the argument transfer_admin_id. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#TRANSFER_ADMIN_USER_NOT_FOUND}.
         */
        public static MembersRemoveError transferAdminUserNotFound() {
            return MembersRemoveError.TRANSFER_ADMIN_USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TRANSFER_ADMIN_USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TRANSFER_ADMIN_USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isTransferAdminUserNotFound() {
            return this.tag == Tag.TRANSFER_ADMIN_USER_NOT_FOUND;
        }

        /**
         * The provided transfer_admin_id does not exist on this team.
         */
        private static final MembersRemoveError TRANSFER_ADMIN_USER_NOT_IN_TEAM_INSTANCE = new MembersRemoveError(Tag.TRANSFER_ADMIN_USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#TRANSFER_ADMIN_USER_NOT_IN_TEAM}.
         *
         * <p> The provided transfer_admin_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#TRANSFER_ADMIN_USER_NOT_IN_TEAM}.
         */
        public static MembersRemoveError transferAdminUserNotInTeam() {
            return MembersRemoveError.TRANSFER_ADMIN_USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TRANSFER_ADMIN_USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TRANSFER_ADMIN_USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isTransferAdminUserNotInTeam() {
            return this.tag == Tag.TRANSFER_ADMIN_USER_NOT_IN_TEAM;
        }

        /**
         * The transfer_admin_id argument must be provided when file transfer is
         * requested.
         */
        private static final MembersRemoveError UNSPECIFIED_TRANSFER_ADMIN_ID_INSTANCE = new MembersRemoveError(Tag.UNSPECIFIED_TRANSFER_ADMIN_ID);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#UNSPECIFIED_TRANSFER_ADMIN_ID}.
         *
         * <p> The transfer_admin_id argument must be provided when file
         * transfer is requested. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#UNSPECIFIED_TRANSFER_ADMIN_ID}.
         */
        public static MembersRemoveError unspecifiedTransferAdminId() {
            return MembersRemoveError.UNSPECIFIED_TRANSFER_ADMIN_ID_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#UNSPECIFIED_TRANSFER_ADMIN_ID}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#UNSPECIFIED_TRANSFER_ADMIN_ID}, {@code false} otherwise.
         */
        public boolean isUnspecifiedTransferAdminId() {
            return this.tag == Tag.UNSPECIFIED_TRANSFER_ADMIN_ID;
        }

        /**
         * Specified transfer_admin user is not a team admin.
         */
        private static final MembersRemoveError TRANSFER_ADMIN_IS_NOT_ADMIN_INSTANCE = new MembersRemoveError(Tag.TRANSFER_ADMIN_IS_NOT_ADMIN);

        /**
         * Returns an instance of {@code MembersRemoveError} that has its tag
         * set to {@link Tag#TRANSFER_ADMIN_IS_NOT_ADMIN}.
         *
         * <p> Specified transfer_admin user is not a team admin. </p>
         *
         * @return Instance of {@code MembersRemoveError} with its tag set to
         *     {@link Tag#TRANSFER_ADMIN_IS_NOT_ADMIN}.
         */
        public static MembersRemoveError transferAdminIsNotAdmin() {
            return MembersRemoveError.TRANSFER_ADMIN_IS_NOT_ADMIN_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#TRANSFER_ADMIN_IS_NOT_ADMIN}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#TRANSFER_ADMIN_IS_NOT_ADMIN}, {@code false} otherwise.
         */
        public boolean isTransferAdminIsNotAdmin() {
            return this.tag == Tag.TRANSFER_ADMIN_IS_NOT_ADMIN;
        }

        private MembersRemoveError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case USER_NOT_IN_TEAM:
                case OTHER:
                case REMOVE_LAST_ADMIN:
                case REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER:
                case REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER:
                case TRANSFER_DEST_USER_NOT_FOUND:
                case TRANSFER_DEST_USER_NOT_IN_TEAM:
                case TRANSFER_ADMIN_USER_NOT_FOUND:
                case TRANSFER_ADMIN_USER_NOT_IN_TEAM:
                case UNSPECIFIED_TRANSFER_ADMIN_ID:
                case TRANSFER_ADMIN_IS_NOT_ADMIN:
                    break;
            }
        }

        static final JsonWriter<MembersRemoveError> _writer = new JsonWriter<MembersRemoveError>()
        {
            public final void write(MembersRemoveError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case REMOVE_LAST_ADMIN:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("remove_last_admin");
                        g.writeEndObject();
                        break;
                    case REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("removed_and_transfer_dest_should_differ");
                        g.writeEndObject();
                        break;
                    case REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("removed_and_transfer_admin_should_differ");
                        g.writeEndObject();
                        break;
                    case TRANSFER_DEST_USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("transfer_dest_user_not_found");
                        g.writeEndObject();
                        break;
                    case TRANSFER_DEST_USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("transfer_dest_user_not_in_team");
                        g.writeEndObject();
                        break;
                    case TRANSFER_ADMIN_USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("transfer_admin_user_not_found");
                        g.writeEndObject();
                        break;
                    case TRANSFER_ADMIN_USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("transfer_admin_user_not_in_team");
                        g.writeEndObject();
                        break;
                    case UNSPECIFIED_TRANSFER_ADMIN_ID:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("unspecified_transfer_admin_id");
                        g.writeEndObject();
                        break;
                    case TRANSFER_ADMIN_IS_NOT_ADMIN:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("transfer_admin_is_not_admin");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersRemoveError> _reader = new JsonReader<MembersRemoveError>()
        {
            public final MembersRemoveError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case USER_NOT_FOUND: return MembersRemoveError.userNotFound();
                        case USER_NOT_IN_TEAM: return MembersRemoveError.userNotInTeam();
                        case OTHER: return MembersRemoveError.other();
                        case REMOVE_LAST_ADMIN: return MembersRemoveError.removeLastAdmin();
                        case REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER: return MembersRemoveError.removedAndTransferDestShouldDiffer();
                        case REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER: return MembersRemoveError.removedAndTransferAdminShouldDiffer();
                        case TRANSFER_DEST_USER_NOT_FOUND: return MembersRemoveError.transferDestUserNotFound();
                        case TRANSFER_DEST_USER_NOT_IN_TEAM: return MembersRemoveError.transferDestUserNotInTeam();
                        case TRANSFER_ADMIN_USER_NOT_FOUND: return MembersRemoveError.transferAdminUserNotFound();
                        case TRANSFER_ADMIN_USER_NOT_IN_TEAM: return MembersRemoveError.transferAdminUserNotInTeam();
                        case UNSPECIFIED_TRANSFER_ADMIN_ID: return MembersRemoveError.unspecifiedTransferAdminId();
                        case TRANSFER_ADMIN_IS_NOT_ADMIN: return MembersRemoveError.transferAdminIsNotAdmin();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersRemoveError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MembersRemoveError.userNotFound();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MembersRemoveError.userNotInTeam();
                            break;
                        }
                        case OTHER: {
                            value = MembersRemoveError.other();
                            break;
                        }
                        case REMOVE_LAST_ADMIN: {
                            value = MembersRemoveError.removeLastAdmin();
                            break;
                        }
                        case REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER: {
                            value = MembersRemoveError.removedAndTransferDestShouldDiffer();
                            break;
                        }
                        case REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER: {
                            value = MembersRemoveError.removedAndTransferAdminShouldDiffer();
                            break;
                        }
                        case TRANSFER_DEST_USER_NOT_FOUND: {
                            value = MembersRemoveError.transferDestUserNotFound();
                            break;
                        }
                        case TRANSFER_DEST_USER_NOT_IN_TEAM: {
                            value = MembersRemoveError.transferDestUserNotInTeam();
                            break;
                        }
                        case TRANSFER_ADMIN_USER_NOT_FOUND: {
                            value = MembersRemoveError.transferAdminUserNotFound();
                            break;
                        }
                        case TRANSFER_ADMIN_USER_NOT_IN_TEAM: {
                            value = MembersRemoveError.transferAdminUserNotInTeam();
                            break;
                        }
                        case UNSPECIFIED_TRANSFER_ADMIN_ID: {
                            value = MembersRemoveError.unspecifiedTransferAdminId();
                            break;
                        }
                        case TRANSFER_ADMIN_IS_NOT_ADMIN: {
                            value = MembersRemoveError.transferAdminIsNotAdmin();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("remove_last_admin", Tag.REMOVE_LAST_ADMIN);
            _values.put("removed_and_transfer_dest_should_differ", Tag.REMOVED_AND_TRANSFER_DEST_SHOULD_DIFFER);
            _values.put("removed_and_transfer_admin_should_differ", Tag.REMOVED_AND_TRANSFER_ADMIN_SHOULD_DIFFER);
            _values.put("transfer_dest_user_not_found", Tag.TRANSFER_DEST_USER_NOT_FOUND);
            _values.put("transfer_dest_user_not_in_team", Tag.TRANSFER_DEST_USER_NOT_IN_TEAM);
            _values.put("transfer_admin_user_not_found", Tag.TRANSFER_ADMIN_USER_NOT_FOUND);
            _values.put("transfer_admin_user_not_in_team", Tag.TRANSFER_ADMIN_USER_NOT_IN_TEAM);
            _values.put("unspecified_transfer_admin_id", Tag.UNSPECIFIED_TRANSFER_ADMIN_ID);
            _values.put("transfer_admin_is_not_admin", Tag.TRANSFER_ADMIN_IS_NOT_ADMIN);
        }

        public String toString() {
            return "MembersRemoveError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersRemoveError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersRemoveError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersSuspendError {
        // union MembersSuspendError

        /**
         * The discriminating tag type for {@link MembersSuspendError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM,
            /**
             * An unspecified error.
             */
            OTHER,
            /**
             * The user is not active, so it cannot be suspended.
             */
            SUSPEND_INACTIVE_USER,
            /**
             * The user is the last admin of the team, so it cannot be
             * suspended.
             */
            SUSPEND_LAST_ADMIN
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersSuspendError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MembersSuspendError USER_NOT_FOUND_INSTANCE = new MembersSuspendError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersSuspendError} that has its tag
         * set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersSuspendError} with its tag set to
         *     {@link Tag#USER_NOT_FOUND}.
         */
        public static MembersSuspendError userNotFound() {
            return MembersSuspendError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MembersSuspendError USER_NOT_IN_TEAM_INSTANCE = new MembersSuspendError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersSuspendError} that has its tag
         * set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MembersSuspendError} with its tag set to
         *     {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MembersSuspendError userNotInTeam() {
            return MembersSuspendError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        /**
         * An unspecified error.
         */
        private static final MembersSuspendError OTHER_INSTANCE = new MembersSuspendError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersSuspendError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersSuspendError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static MembersSuspendError other() {
            return MembersSuspendError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * The user is not active, so it cannot be suspended.
         */
        private static final MembersSuspendError SUSPEND_INACTIVE_USER_INSTANCE = new MembersSuspendError(Tag.SUSPEND_INACTIVE_USER);

        /**
         * Returns an instance of {@code MembersSuspendError} that has its tag
         * set to {@link Tag#SUSPEND_INACTIVE_USER}.
         *
         * <p> The user is not active, so it cannot be suspended. </p>
         *
         * @return Instance of {@code MembersSuspendError} with its tag set to
         *     {@link Tag#SUSPEND_INACTIVE_USER}.
         */
        public static MembersSuspendError suspendInactiveUser() {
            return MembersSuspendError.SUSPEND_INACTIVE_USER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#SUSPEND_INACTIVE_USER}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#SUSPEND_INACTIVE_USER}, {@code false} otherwise.
         */
        public boolean isSuspendInactiveUser() {
            return this.tag == Tag.SUSPEND_INACTIVE_USER;
        }

        /**
         * The user is the last admin of the team, so it cannot be suspended.
         */
        private static final MembersSuspendError SUSPEND_LAST_ADMIN_INSTANCE = new MembersSuspendError(Tag.SUSPEND_LAST_ADMIN);

        /**
         * Returns an instance of {@code MembersSuspendError} that has its tag
         * set to {@link Tag#SUSPEND_LAST_ADMIN}.
         *
         * <p> The user is the last admin of the team, so it cannot be
         * suspended. </p>
         *
         * @return Instance of {@code MembersSuspendError} with its tag set to
         *     {@link Tag#SUSPEND_LAST_ADMIN}.
         */
        public static MembersSuspendError suspendLastAdmin() {
            return MembersSuspendError.SUSPEND_LAST_ADMIN_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#SUSPEND_LAST_ADMIN}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#SUSPEND_LAST_ADMIN}, {@code false} otherwise.
         */
        public boolean isSuspendLastAdmin() {
            return this.tag == Tag.SUSPEND_LAST_ADMIN;
        }

        private MembersSuspendError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case USER_NOT_IN_TEAM:
                case OTHER:
                case SUSPEND_INACTIVE_USER:
                case SUSPEND_LAST_ADMIN:
                    break;
            }
        }

        static final JsonWriter<MembersSuspendError> _writer = new JsonWriter<MembersSuspendError>()
        {
            public final void write(MembersSuspendError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case SUSPEND_INACTIVE_USER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("suspend_inactive_user");
                        g.writeEndObject();
                        break;
                    case SUSPEND_LAST_ADMIN:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("suspend_last_admin");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersSuspendError> _reader = new JsonReader<MembersSuspendError>()
        {
            public final MembersSuspendError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case USER_NOT_FOUND: return MembersSuspendError.userNotFound();
                        case USER_NOT_IN_TEAM: return MembersSuspendError.userNotInTeam();
                        case OTHER: return MembersSuspendError.other();
                        case SUSPEND_INACTIVE_USER: return MembersSuspendError.suspendInactiveUser();
                        case SUSPEND_LAST_ADMIN: return MembersSuspendError.suspendLastAdmin();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersSuspendError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MembersSuspendError.userNotFound();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MembersSuspendError.userNotInTeam();
                            break;
                        }
                        case OTHER: {
                            value = MembersSuspendError.other();
                            break;
                        }
                        case SUSPEND_INACTIVE_USER: {
                            value = MembersSuspendError.suspendInactiveUser();
                            break;
                        }
                        case SUSPEND_LAST_ADMIN: {
                            value = MembersSuspendError.suspendLastAdmin();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("suspend_inactive_user", Tag.SUSPEND_INACTIVE_USER);
            _values.put("suspend_last_admin", Tag.SUSPEND_LAST_ADMIN);
        }

        public String toString() {
            return "MembersSuspendError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersSuspendError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersSuspendError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Exactly one of team_member_id, email, or external_id must be provided to
     * identify the user account.
     */
    public static class MembersUnsuspendArg {
        // struct MembersUnsuspendArg
        /**
         * Identity of user to unsuspend.
         */
        public final UserSelectorArg user;

        /**
         * Exactly one of team_member_id, email, or external_id must be provided
         * to identify the user account.
         *
         * @param user  Identity of user to unsuspend. {@code user} must not be
         *     {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public MembersUnsuspendArg(UserSelectorArg user) {
            this.user = user;
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
        }

        static final JsonWriter<MembersUnsuspendArg> _writer = new JsonWriter<MembersUnsuspendArg>()
        {
            public final void write(MembersUnsuspendArg x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                MembersUnsuspendArg._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(MembersUnsuspendArg x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("user");
                UserSelectorArg._writer.write(x.user, g);
            }
        };

        public static final JsonReader<MembersUnsuspendArg> _reader = new JsonReader<MembersUnsuspendArg>() {

            public final MembersUnsuspendArg read(JsonParser parser)
                throws IOException, JsonReadException
            {
                MembersUnsuspendArg result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final MembersUnsuspendArg readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                UserSelectorArg user = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("user".equals(fieldName)) {
                        user = UserSelectorArg._reader
                            .readField(parser, "user", user);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (user == null) {
                    throw new JsonReadException("Required field \"user\" is missing.", parser.getTokenLocation());
                }
                return new MembersUnsuspendArg(user);
            }
        };

        public String toString() {
            return "MembersUnsuspendArg." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "MembersUnsuspendArg." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static MembersUnsuspendArg fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    public static final class MembersUnsuspendError {
        // union MembersUnsuspendError

        /**
         * The discriminating tag type for {@link MembersUnsuspendError}.
         */
        public enum Tag {
            /**
             * No matching user found. The provided team_member_id, email, or
             * external_id does not exist on this team.
             */
            USER_NOT_FOUND,
            /**
             * The user is not a member of the team.
             */
            USER_NOT_IN_TEAM,
            /**
             * An unspecified error.
             */
            OTHER,
            /**
             * The user is unsuspended, so it cannot be unsuspended again.
             */
            UNSUSPEND_NON_SUSPENDED_MEMBER
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code MembersUnsuspendError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team.
         */
        private static final MembersUnsuspendError USER_NOT_FOUND_INSTANCE = new MembersUnsuspendError(Tag.USER_NOT_FOUND);

        /**
         * Returns an instance of {@code MembersUnsuspendError} that has its tag
         * set to {@link Tag#USER_NOT_FOUND}.
         *
         * <p> No matching user found. The provided team_member_id, email, or
         * external_id does not exist on this team. </p>
         *
         * @return Instance of {@code MembersUnsuspendError} with its tag set to
         *     {@link Tag#USER_NOT_FOUND}.
         */
        public static MembersUnsuspendError userNotFound() {
            return MembersUnsuspendError.USER_NOT_FOUND_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_FOUND}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_FOUND}, {@code false} otherwise.
         */
        public boolean isUserNotFound() {
            return this.tag == Tag.USER_NOT_FOUND;
        }

        /**
         * The user is not a member of the team.
         */
        private static final MembersUnsuspendError USER_NOT_IN_TEAM_INSTANCE = new MembersUnsuspendError(Tag.USER_NOT_IN_TEAM);

        /**
         * Returns an instance of {@code MembersUnsuspendError} that has its tag
         * set to {@link Tag#USER_NOT_IN_TEAM}.
         *
         * <p> The user is not a member of the team. </p>
         *
         * @return Instance of {@code MembersUnsuspendError} with its tag set to
         *     {@link Tag#USER_NOT_IN_TEAM}.
         */
        public static MembersUnsuspendError userNotInTeam() {
            return MembersUnsuspendError.USER_NOT_IN_TEAM_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#USER_NOT_IN_TEAM}, {@code false} otherwise.
         */
        public boolean isUserNotInTeam() {
            return this.tag == Tag.USER_NOT_IN_TEAM;
        }

        /**
         * An unspecified error.
         */
        private static final MembersUnsuspendError OTHER_INSTANCE = new MembersUnsuspendError(Tag.OTHER);

        /**
         * Returns an instance of {@code MembersUnsuspendError} that has its tag
         * set to {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code MembersUnsuspendError} with its tag set to
         *     {@link Tag#OTHER}.
         */
        public static MembersUnsuspendError other() {
            return MembersUnsuspendError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        /**
         * The user is unsuspended, so it cannot be unsuspended again.
         */
        private static final MembersUnsuspendError UNSUSPEND_NON_SUSPENDED_MEMBER_INSTANCE = new MembersUnsuspendError(Tag.UNSUSPEND_NON_SUSPENDED_MEMBER);

        /**
         * Returns an instance of {@code MembersUnsuspendError} that has its tag
         * set to {@link Tag#UNSUSPEND_NON_SUSPENDED_MEMBER}.
         *
         * <p> The user is unsuspended, so it cannot be unsuspended again. </p>
         *
         * @return Instance of {@code MembersUnsuspendError} with its tag set to
         *     {@link Tag#UNSUSPEND_NON_SUSPENDED_MEMBER}.
         */
        public static MembersUnsuspendError unsuspendNonSuspendedMember() {
            return MembersUnsuspendError.UNSUSPEND_NON_SUSPENDED_MEMBER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link
         * Tag#UNSUSPEND_NON_SUSPENDED_MEMBER}, {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link
         *     Tag#UNSUSPEND_NON_SUSPENDED_MEMBER}, {@code false} otherwise.
         */
        public boolean isUnsuspendNonSuspendedMember() {
            return this.tag == Tag.UNSUSPEND_NON_SUSPENDED_MEMBER;
        }

        private MembersUnsuspendError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case USER_NOT_FOUND:
                case USER_NOT_IN_TEAM:
                case OTHER:
                case UNSUSPEND_NON_SUSPENDED_MEMBER:
                    break;
            }
        }

        static final JsonWriter<MembersUnsuspendError> _writer = new JsonWriter<MembersUnsuspendError>()
        {
            public final void write(MembersUnsuspendError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case USER_NOT_FOUND:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_found");
                        g.writeEndObject();
                        break;
                    case USER_NOT_IN_TEAM:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("user_not_in_team");
                        g.writeEndObject();
                        break;
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                    case UNSUSPEND_NON_SUSPENDED_MEMBER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("unsuspend_non_suspended_member");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<MembersUnsuspendError> _reader = new JsonReader<MembersUnsuspendError>()
        {
            public final MembersUnsuspendError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) {
                        throw new JsonReadException("Unanticipated tag " + text + " without catch-all", parser.getTokenLocation());
                    }
                    switch (tag) {
                        case USER_NOT_FOUND: return MembersUnsuspendError.userNotFound();
                        case USER_NOT_IN_TEAM: return MembersUnsuspendError.userNotInTeam();
                        case OTHER: return MembersUnsuspendError.other();
                        case UNSUSPEND_NON_SUSPENDED_MEMBER: return MembersUnsuspendError.unsuspendNonSuspendedMember();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                MembersUnsuspendError value = null;
                if (tag != null) {
                    switch (tag) {
                        case USER_NOT_FOUND: {
                            value = MembersUnsuspendError.userNotFound();
                            break;
                        }
                        case USER_NOT_IN_TEAM: {
                            value = MembersUnsuspendError.userNotInTeam();
                            break;
                        }
                        case OTHER: {
                            value = MembersUnsuspendError.other();
                            break;
                        }
                        case UNSUSPEND_NON_SUSPENDED_MEMBER: {
                            value = MembersUnsuspendError.unsuspendNonSuspendedMember();
                            break;
                        }
                    }
                }
                if (value == null) {
                    throw new JsonReadException("Unanticipated tag " + text, parser.getTokenLocation());
                }
                JsonReader.expectObjectEnd(parser);
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("unsuspend_non_suspended_member", Tag.UNSUSPEND_NON_SUSPENDED_MEMBER);
        }

        public String toString() {
            return "MembersUnsuspendError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "MembersUnsuspendError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static MembersUnsuspendError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Input arguments that can be provided for most reports.
     */
    public static class DateRange {
        // struct DateRange
        /**
         * Optional starting date (inclusive)
         */
        public final java.util.Date startDate;
        /**
         * Optional ending date (exclusive)
         */
        public final java.util.Date endDate;

        /**
         * Input arguments that can be provided for most reports.
         *
         * @param startDate  Optional starting date (inclusive).
         * @param endDate  Optional ending date (exclusive).
         */
        public DateRange(java.util.Date startDate, java.util.Date endDate) {
            this.startDate = startDate;
            this.endDate = endDate;
        }

        static final JsonWriter<DateRange> _writer = new JsonWriter<DateRange>()
        {
            public final void write(DateRange x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DateRange._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(DateRange x, JsonGenerator g)
             throws IOException
            {
                if (x.startDate != null) {
                    g.writeFieldName("start_date");
                    writeDateIso(x.startDate, g);
                }
                if (x.endDate != null) {
                    g.writeFieldName("end_date");
                    writeDateIso(x.endDate, g);
                }
            }
        };

        public static final JsonReader<DateRange> _reader = new JsonReader<DateRange>() {

            public final DateRange read(JsonParser parser)
                throws IOException, JsonReadException
            {
                DateRange result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final DateRange readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.Date startDate = null;
                java.util.Date endDate = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("start_date".equals(fieldName)) {
                        startDate = JsonDateReader.DropboxV2
                            .readField(parser, "start_date", startDate);
                    }
                    else if ("end_date".equals(fieldName)) {
                        endDate = JsonDateReader.DropboxV2
                            .readField(parser, "end_date", endDate);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                return new DateRange(startDate, endDate);
            }
        };

        public String toString() {
            return "DateRange." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "DateRange." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static DateRange fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Errors that can originate from problems in input arguments to reports.
     */
    public static final class DateRangeError {
        // union DateRangeError

        /**
         * The discriminating tag type for {@link DateRangeError}.
         */
        public enum Tag {
            /**
             * An unspecified error.
             */
            OTHER  // *catch_all
        }

        /**
         * The discriminating tag for this instance.
         */
        public final Tag tag;

        /**
         * Returns the tag for this instance.
         *
         * <p> This class is a tagged union.  Tagged unions instances are always
         * associated to a specific tag.  Callers are recommended to use the tag
         * value in a {@code switch} statement to determine how to properly
         * handle this {@code DateRangeError}. </p>
         *
         * @return the tag for this instance.
         */
        public Tag getTag() {
            return this.tag;
        }

        /**
         * An unspecified error.
         */
        private static final DateRangeError OTHER_INSTANCE = new DateRangeError(Tag.OTHER);

        /**
         * Returns an instance of {@code DateRangeError} that has its tag set to
         * {@link Tag#OTHER}.
         *
         * <p> An unspecified error. </p>
         *
         * @return Instance of {@code DateRangeError} with its tag set to {@link
         *     Tag#OTHER}.
         */
        public static DateRangeError other() {
            return DateRangeError.OTHER_INSTANCE;
        }

        /**
         * Returns {@code true} if this instance has the tag {@link Tag#OTHER},
         * {@code false} otherwise.
         *
         * @return {@code true} if this instance is tagged as {@link Tag#OTHER},
         *     {@code false} otherwise.
         */
        public boolean isOther() {
            return this.tag == Tag.OTHER;
        }

        private DateRangeError(Tag t) {
            tag = t;
            validate();
        }

        private final void validate() {
            switch (this.tag) {
                case OTHER:
                    break;
            }
        }

        static final JsonWriter<DateRangeError> _writer = new JsonWriter<DateRangeError>()
        {
            public final void write(DateRangeError x, JsonGenerator g)
              throws IOException
            {
                switch (x.tag) {
                    case OTHER:
                        g.writeStartObject();
                        g.writeFieldName(".tag");
                        g.writeString("other");
                        g.writeEndObject();
                        break;
                }
            }
        };
        public static final JsonReader<DateRangeError> _reader = new JsonReader<DateRangeError>()
        {
            public final DateRangeError read(JsonParser parser)
              throws IOException, JsonReadException
            {
                if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
                    String text = parser.getText();
                    parser.nextToken();
                    Tag tag = _values.get(text);
                    if (tag == null) { return DateRangeError.other(); }
                    switch (tag) {
                        case OTHER: return DateRangeError.other();
                    }
                    throw new JsonReadException("Tag " + tag + " requires a value", parser.getTokenLocation());
                }
                JsonReader.expectObjectStart(parser);
                String[] tags = readTags(parser);
                assert tags != null && tags.length == 1;
                String text = tags[0];
                Tag tag = _values.get(text);
                DateRangeError value = null;
                if (tag != null) {
                    switch (tag) {
                        case OTHER: {
                            value = DateRangeError.other();
                            break;
                        }
                    }
                }
                JsonReader.expectObjectEnd(parser);
                if (value == null) { return DateRangeError.other(); }
                return value;
            }

        };
        private static final java.util.HashMap<String,Tag> _values;
        static {
            _values = new java.util.HashMap<String,Tag>();
            _values.put("other", Tag.OTHER);
        }

        public String toString() {
            return "DateRangeError." + _writer.writeToString(this, false);
        }
        public String toStringMultiline() {
            return "DateRangeError." +  _writer.writeToString(this, true);
        }
        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }
        public static DateRangeError fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Describes the number of users in a specific storage bucket.
     */
    public static class StorageBucket {
        // struct StorageBucket
        /**
         * The name of the storage bucket. For example, '1G' is a bucket of
         * users with storage size up to 1 Giga.
         */
        public final String bucket;
        /**
         * The number of people whose storage is in the range of this storage
         * bucket.
         */
        public final long users;

        /**
         * Describes the number of users in a specific storage bucket.
         *
         * @param bucket  The name of the storage bucket. For example, '1G' is a
         *     bucket of users with storage size up to 1 Giga. {@code bucket}
         *     must not be {@code null}.
         * @param users  The number of people whose storage is in the range of
         *     this storage bucket.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public StorageBucket(String bucket, long users) {
            this.bucket = bucket;
            if (bucket == null) {
                throw new IllegalArgumentException("Required value for 'bucket' is null");
            }
            this.users = users;
        }

        static final JsonWriter<StorageBucket> _writer = new JsonWriter<StorageBucket>()
        {
            public final void write(StorageBucket x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                StorageBucket._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(StorageBucket x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("bucket", x.bucket);
                g.writeNumberField("users", x.users);
            }
        };

        public static final JsonReader<StorageBucket> _reader = new JsonReader<StorageBucket>() {

            public final StorageBucket read(JsonParser parser)
                throws IOException, JsonReadException
            {
                StorageBucket result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final StorageBucket readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String bucket = null;
                Long users = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("bucket".equals(fieldName)) {
                        bucket = JsonReader.StringReader
                            .readField(parser, "bucket", bucket);
                    }
                    else if ("users".equals(fieldName)) {
                        users = JsonReader.UInt64Reader
                            .readField(parser, "users", users);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (bucket == null) {
                    throw new JsonReadException("Required field \"bucket\" is missing.", parser.getTokenLocation());
                }
                if (users == null) {
                    throw new JsonReadException("Required field \"users\" is missing.", parser.getTokenLocation());
                }
                return new StorageBucket(bucket, users);
            }
        };

        public String toString() {
            return "StorageBucket." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "StorageBucket." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static StorageBucket fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Base report structure.
     */
    public static class BaseDfbReport {
        // struct BaseDfbReport
        /**
         * First date present in the results as 'YYYY-MM-DD' or None.
         */
        public final String startDate;

        /**
         * Base report structure.
         *
         * @param startDate  First date present in the results as 'YYYY-MM-DD'
         *     or None. {@code startDate} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public BaseDfbReport(String startDate) {
            this.startDate = startDate;
            if (startDate == null) {
                throw new IllegalArgumentException("Required value for 'startDate' is null");
            }
        }

        static final JsonWriter<BaseDfbReport> _writer = new JsonWriter<BaseDfbReport>()
        {
            public final void write(BaseDfbReport x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                BaseDfbReport._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(BaseDfbReport x, JsonGenerator g)
             throws IOException
            {
                g.writeStringField("start_date", x.startDate);
            }
        };

        public static final JsonReader<BaseDfbReport> _reader = new JsonReader<BaseDfbReport>() {

            public final BaseDfbReport read(JsonParser parser)
                throws IOException, JsonReadException
            {
                BaseDfbReport result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final BaseDfbReport readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String startDate = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("start_date".equals(fieldName)) {
                        startDate = JsonReader.StringReader
                            .readField(parser, "start_date", startDate);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (startDate == null) {
                    throw new JsonReadException("Required field \"start_date\" is missing.", parser.getTokenLocation());
                }
                return new BaseDfbReport(startDate);
            }
        };

        public String toString() {
            return "BaseDfbReport." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "BaseDfbReport." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static BaseDfbReport fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Storage Report Result. Each of the items in the storage report is an
     * array of values, one value per day. If there is no data for a day, then
     * the value will be None.
     */
    public static class GetStorageReport extends BaseDfbReport  {
        // struct GetStorageReport
        /**
         * Sum of the shared, unshared, and datastore usages, for each day.
         */
        public final java.util.List<Long> totalUsage;
        /**
         * Array of the combined size (bytes) of team members' shared folders,
         * for each day.
         */
        public final java.util.List<Long> sharedUsage;
        /**
         * Array of the combined size (bytes) of team members' root namespaces,
         * for each day.
         */
        public final java.util.List<Long> unsharedUsage;
        /**
         * Array of the number of shared folders owned by team members, for each
         * day.
         */
        public final java.util.List<Long> sharedFolders;
        /**
         * Array of storage summaries of team members' account sizes. Each
         * storage summary is an array of key, value pairs, where each pair
         * describes a storage bucket. The key indicates the upper bound of the
         * bucket and the value is the number of users in that bucket. There is
         * one such summary per day. If there is no data for a day, the storage
         * summary will be empty.
         */
        public final java.util.List<java.util.List<StorageBucket>> memberStorageMap;

        /**
         * Storage Report Result. Each of the items in the storage report is an
         * array of values, one value per day. If there is no data for a day,
         * then the value will be None.
         *
         * @param startDate  First date present in the results as 'YYYY-MM-DD'
         *     or None. {@code startDate} must not be {@code null}.
         * @param totalUsage  Sum of the shared, unshared, and datastore usages,
         *     for each day. {@code totalUsage} must not contain a {@code null}
         *     item and not be {@code null}.
         * @param sharedUsage  Array of the combined size (bytes) of team
         *     members' shared folders, for each day. {@code sharedUsage} must
         *     not contain a {@code null} item and not be {@code null}.
         * @param unsharedUsage  Array of the combined size (bytes) of team
         *     members' root namespaces, for each day. {@code unsharedUsage}
         *     must not contain a {@code null} item and not be {@code null}.
         * @param sharedFolders  Array of the number of shared folders owned by
         *     team members, for each day. {@code sharedFolders} must not
         *     contain a {@code null} item and not be {@code null}.
         * @param memberStorageMap  Array of storage summaries of team members'
         *     account sizes. Each storage summary is an array of key, value
         *     pairs, where each pair describes a storage bucket. The key
         *     indicates the upper bound of the bucket and the value is the
         *     number of users in that bucket. There is one such summary per
         *     day. If there is no data for a day, the storage summary will be
         *     empty. {@code memberStorageMap} must not contain a {@code null}
         *     item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GetStorageReport(String startDate, java.util.List<Long> totalUsage, java.util.List<Long> sharedUsage, java.util.List<Long> unsharedUsage, java.util.List<Long> sharedFolders, java.util.List<java.util.List<StorageBucket>> memberStorageMap) {
            super(startDate);
            this.totalUsage = totalUsage;
            if (totalUsage == null) {
                throw new IllegalArgumentException("Required value for 'totalUsage' is null");
            }
            for (Long x : totalUsage) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'totalUsage' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'totalUsage'': type Nullable");
            }
            this.sharedUsage = sharedUsage;
            if (sharedUsage == null) {
                throw new IllegalArgumentException("Required value for 'sharedUsage' is null");
            }
            for (Long x : sharedUsage) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'sharedUsage' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'sharedUsage'': type Nullable");
            }
            this.unsharedUsage = unsharedUsage;
            if (unsharedUsage == null) {
                throw new IllegalArgumentException("Required value for 'unsharedUsage' is null");
            }
            for (Long x : unsharedUsage) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'unsharedUsage' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'unsharedUsage'': type Nullable");
            }
            this.sharedFolders = sharedFolders;
            if (sharedFolders == null) {
                throw new IllegalArgumentException("Required value for 'sharedFolders' is null");
            }
            for (Long x : sharedFolders) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'sharedFolders' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'sharedFolders'': type Nullable");
            }
            this.memberStorageMap = memberStorageMap;
            if (memberStorageMap == null) {
                throw new IllegalArgumentException("Required value for 'memberStorageMap' is null");
            }
            for (java.util.List<StorageBucket> x : memberStorageMap) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'memberStorageMap' is null");
                }
                for (StorageBucket x1 : x) {
                    if (x1 == null) {
                        throw new IllegalArgumentException("An item in list 'an item in list 'memberStorageMap'' is null");
                    }
                }
            }
        }

        static final JsonWriter<GetStorageReport> _writer = new JsonWriter<GetStorageReport>()
        {
            public final void write(GetStorageReport x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                BaseDfbReport._writer.writeFields(x, g);
                GetStorageReport._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GetStorageReport x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("total_usage");
                g.writeStartArray();
                for (Long item: x.totalUsage) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("shared_usage");
                g.writeStartArray();
                for (Long item: x.sharedUsage) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("unshared_usage");
                g.writeStartArray();
                for (Long item: x.unsharedUsage) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("shared_folders");
                g.writeStartArray();
                for (Long item: x.sharedFolders) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("member_storage_map");
                g.writeStartArray();
                for (java.util.List<StorageBucket> item: x.memberStorageMap) {
                    if (item != null) {
                        g.writeStartArray();
                        for (StorageBucket item1: item) {
                            if (item1 != null) {
                                StorageBucket._writer.write(item1, g);
                            }
                        }
                        g.writeEndArray();
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<GetStorageReport> _reader = new JsonReader<GetStorageReport>() {

            public final GetStorageReport read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GetStorageReport result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GetStorageReport readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String startDate = null;
                java.util.List<Long> totalUsage = null;
                java.util.List<Long> sharedUsage = null;
                java.util.List<Long> unsharedUsage = null;
                java.util.List<Long> sharedFolders = null;
                java.util.List<java.util.List<StorageBucket>> memberStorageMap = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("start_date".equals(fieldName)) {
                        startDate = JsonReader.StringReader
                            .readField(parser, "start_date", startDate);
                    }
                    else if ("total_usage".equals(fieldName)) {
                        totalUsage = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "total_usage", totalUsage);
                    }
                    else if ("shared_usage".equals(fieldName)) {
                        sharedUsage = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "shared_usage", sharedUsage);
                    }
                    else if ("unshared_usage".equals(fieldName)) {
                        unsharedUsage = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "unshared_usage", unsharedUsage);
                    }
                    else if ("shared_folders".equals(fieldName)) {
                        sharedFolders = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "shared_folders", sharedFolders);
                    }
                    else if ("member_storage_map".equals(fieldName)) {
                        memberStorageMap = JsonArrayReader.mk(JsonArrayReader.mk(StorageBucket._reader))
                            .readField(parser, "member_storage_map", memberStorageMap);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (startDate == null) {
                    throw new JsonReadException("Required field \"start_date\" is missing.", parser.getTokenLocation());
                }
                if (totalUsage == null) {
                    throw new JsonReadException("Required field \"total_usage\" is missing.", parser.getTokenLocation());
                }
                if (sharedUsage == null) {
                    throw new JsonReadException("Required field \"shared_usage\" is missing.", parser.getTokenLocation());
                }
                if (unsharedUsage == null) {
                    throw new JsonReadException("Required field \"unshared_usage\" is missing.", parser.getTokenLocation());
                }
                if (sharedFolders == null) {
                    throw new JsonReadException("Required field \"shared_folders\" is missing.", parser.getTokenLocation());
                }
                if (memberStorageMap == null) {
                    throw new JsonReadException("Required field \"member_storage_map\" is missing.", parser.getTokenLocation());
                }
                return new GetStorageReport(startDate, totalUsage, sharedUsage, unsharedUsage, sharedFolders, memberStorageMap);
            }
        };

        public String toString() {
            return "GetStorageReport." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GetStorageReport." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GetStorageReport fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Activity Report Result. Each of the items in the storage report is an
     * array of values, one value per day. If there is no data for a day, then
     * the value will be None.
     */
    public static class GetActivityReport extends BaseDfbReport  {
        // struct GetActivityReport
        /**
         * Array of total number of adds by team members.
         */
        public final java.util.List<Long> adds;
        /**
         * Array of number of edits by team members. If the same user edits the
         * same file multiple times this is counted as a single edit.
         */
        public final java.util.List<Long> edits;
        /**
         * Array of total number of deletes by team members.
         */
        public final java.util.List<Long> deletes;
        /**
         * Array of the number of users who have been active in the last 28
         * days.
         */
        public final java.util.List<Long> activeUsers28Day;
        /**
         * Array of the number of users who have been active in the last week.
         */
        public final java.util.List<Long> activeUsers7Day;
        /**
         * Array of the number of users who have been active in the last day.
         */
        public final java.util.List<Long> activeUsers1Day;
        /**
         * Array of the number of shared folders with some activity in the last
         * 28 days.
         */
        public final java.util.List<Long> activeSharedFolders28Day;
        /**
         * Array of the number of shared folders with some activity in the last
         * week.
         */
        public final java.util.List<Long> activeSharedFolders7Day;
        /**
         * Array of the number of shared folders with some activity in the last
         * day.
         */
        public final java.util.List<Long> activeSharedFolders1Day;
        /**
         * Array of the number of shared links created.
         */
        public final java.util.List<Long> sharedLinksCreated;
        /**
         * Array of the number of views by team users to shared links created by
         * the team.
         */
        public final java.util.List<Long> sharedLinksViewedByTeam;
        /**
         * Array of the number of views by users outside of the team to shared
         * links created by the team.
         */
        public final java.util.List<Long> sharedLinksViewedByOutsideUser;
        /**
         * Array of the number of views by non-logged-in users to shared links
         * created by the team.
         */
        public final java.util.List<Long> sharedLinksViewedByNotLoggedIn;
        /**
         * Array of the total number of views to shared links created by the
         * team.
         */
        public final java.util.List<Long> sharedLinksViewedTotal;

        /**
         * Activity Report Result. Each of the items in the storage report is an
         * array of values, one value per day. If there is no data for a day,
         * then the value will be None.
         *
         * @param startDate  First date present in the results as 'YYYY-MM-DD'
         *     or None. {@code startDate} must not be {@code null}.
         * @param adds  Array of total number of adds by team members. {@code
         *     adds} must not contain a {@code null} item and not be {@code
         *     null}.
         * @param edits  Array of number of edits by team members. If the same
         *     user edits the same file multiple times this is counted as a
         *     single edit. {@code edits} must not contain a {@code null} item
         *     and not be {@code null}.
         * @param deletes  Array of total number of deletes by team members.
         *     {@code deletes} must not contain a {@code null} item and not be
         *     {@code null}.
         * @param activeUsers28Day  Array of the number of users who have been
         *     active in the last 28 days. {@code activeUsers28Day} must not
         *     contain a {@code null} item and not be {@code null}.
         * @param activeUsers7Day  Array of the number of users who have been
         *     active in the last week. {@code activeUsers7Day} must not contain
         *     a {@code null} item and not be {@code null}.
         * @param activeUsers1Day  Array of the number of users who have been
         *     active in the last day. {@code activeUsers1Day} must not contain
         *     a {@code null} item and not be {@code null}.
         * @param activeSharedFolders28Day  Array of the number of shared
         *     folders with some activity in the last 28 days. {@code
         *     activeSharedFolders28Day} must not contain a {@code null} item
         *     and not be {@code null}.
         * @param activeSharedFolders7Day  Array of the number of shared folders
         *     with some activity in the last week. {@code
         *     activeSharedFolders7Day} must not contain a {@code null} item and
         *     not be {@code null}.
         * @param activeSharedFolders1Day  Array of the number of shared folders
         *     with some activity in the last day. {@code
         *     activeSharedFolders1Day} must not contain a {@code null} item and
         *     not be {@code null}.
         * @param sharedLinksCreated  Array of the number of shared links
         *     created. {@code sharedLinksCreated} must not contain a {@code
         *     null} item and not be {@code null}.
         * @param sharedLinksViewedByTeam  Array of the number of views by team
         *     users to shared links created by the team. {@code
         *     sharedLinksViewedByTeam} must not contain a {@code null} item and
         *     not be {@code null}.
         * @param sharedLinksViewedByOutsideUser  Array of the number of views
         *     by users outside of the team to shared links created by the team.
         *     {@code sharedLinksViewedByOutsideUser} must not contain a {@code
         *     null} item and not be {@code null}.
         * @param sharedLinksViewedByNotLoggedIn  Array of the number of views
         *     by non-logged-in users to shared links created by the team.
         *     {@code sharedLinksViewedByNotLoggedIn} must not contain a {@code
         *     null} item and not be {@code null}.
         * @param sharedLinksViewedTotal  Array of the total number of views to
         *     shared links created by the team. {@code sharedLinksViewedTotal}
         *     must not contain a {@code null} item and not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GetActivityReport(String startDate, java.util.List<Long> adds, java.util.List<Long> edits, java.util.List<Long> deletes, java.util.List<Long> activeUsers28Day, java.util.List<Long> activeUsers7Day, java.util.List<Long> activeUsers1Day, java.util.List<Long> activeSharedFolders28Day, java.util.List<Long> activeSharedFolders7Day, java.util.List<Long> activeSharedFolders1Day, java.util.List<Long> sharedLinksCreated, java.util.List<Long> sharedLinksViewedByTeam, java.util.List<Long> sharedLinksViewedByOutsideUser, java.util.List<Long> sharedLinksViewedByNotLoggedIn, java.util.List<Long> sharedLinksViewedTotal) {
            super(startDate);
            this.adds = adds;
            if (adds == null) {
                throw new IllegalArgumentException("Required value for 'adds' is null");
            }
            for (Long x : adds) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'adds' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'adds'': type Nullable");
            }
            this.edits = edits;
            if (edits == null) {
                throw new IllegalArgumentException("Required value for 'edits' is null");
            }
            for (Long x : edits) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'edits' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'edits'': type Nullable");
            }
            this.deletes = deletes;
            if (deletes == null) {
                throw new IllegalArgumentException("Required value for 'deletes' is null");
            }
            for (Long x : deletes) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'deletes' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'deletes'': type Nullable");
            }
            this.activeUsers28Day = activeUsers28Day;
            if (activeUsers28Day == null) {
                throw new IllegalArgumentException("Required value for 'activeUsers28Day' is null");
            }
            for (Long x : activeUsers28Day) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'activeUsers28Day' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'activeUsers28Day'': type Nullable");
            }
            this.activeUsers7Day = activeUsers7Day;
            if (activeUsers7Day == null) {
                throw new IllegalArgumentException("Required value for 'activeUsers7Day' is null");
            }
            for (Long x : activeUsers7Day) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'activeUsers7Day' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'activeUsers7Day'': type Nullable");
            }
            this.activeUsers1Day = activeUsers1Day;
            if (activeUsers1Day == null) {
                throw new IllegalArgumentException("Required value for 'activeUsers1Day' is null");
            }
            for (Long x : activeUsers1Day) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'activeUsers1Day' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'activeUsers1Day'': type Nullable");
            }
            this.activeSharedFolders28Day = activeSharedFolders28Day;
            if (activeSharedFolders28Day == null) {
                throw new IllegalArgumentException("Required value for 'activeSharedFolders28Day' is null");
            }
            for (Long x : activeSharedFolders28Day) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'activeSharedFolders28Day' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'activeSharedFolders28Day'': type Nullable");
            }
            this.activeSharedFolders7Day = activeSharedFolders7Day;
            if (activeSharedFolders7Day == null) {
                throw new IllegalArgumentException("Required value for 'activeSharedFolders7Day' is null");
            }
            for (Long x : activeSharedFolders7Day) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'activeSharedFolders7Day' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'activeSharedFolders7Day'': type Nullable");
            }
            this.activeSharedFolders1Day = activeSharedFolders1Day;
            if (activeSharedFolders1Day == null) {
                throw new IllegalArgumentException("Required value for 'activeSharedFolders1Day' is null");
            }
            for (Long x : activeSharedFolders1Day) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'activeSharedFolders1Day' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'activeSharedFolders1Day'': type Nullable");
            }
            this.sharedLinksCreated = sharedLinksCreated;
            if (sharedLinksCreated == null) {
                throw new IllegalArgumentException("Required value for 'sharedLinksCreated' is null");
            }
            for (Long x : sharedLinksCreated) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'sharedLinksCreated' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'sharedLinksCreated'': type Nullable");
            }
            this.sharedLinksViewedByTeam = sharedLinksViewedByTeam;
            if (sharedLinksViewedByTeam == null) {
                throw new IllegalArgumentException("Required value for 'sharedLinksViewedByTeam' is null");
            }
            for (Long x : sharedLinksViewedByTeam) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'sharedLinksViewedByTeam' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'sharedLinksViewedByTeam'': type Nullable");
            }
            this.sharedLinksViewedByOutsideUser = sharedLinksViewedByOutsideUser;
            if (sharedLinksViewedByOutsideUser == null) {
                throw new IllegalArgumentException("Required value for 'sharedLinksViewedByOutsideUser' is null");
            }
            for (Long x : sharedLinksViewedByOutsideUser) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'sharedLinksViewedByOutsideUser' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'sharedLinksViewedByOutsideUser'': type Nullable");
            }
            this.sharedLinksViewedByNotLoggedIn = sharedLinksViewedByNotLoggedIn;
            if (sharedLinksViewedByNotLoggedIn == null) {
                throw new IllegalArgumentException("Required value for 'sharedLinksViewedByNotLoggedIn' is null");
            }
            for (Long x : sharedLinksViewedByNotLoggedIn) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'sharedLinksViewedByNotLoggedIn' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'sharedLinksViewedByNotLoggedIn'': type Nullable");
            }
            this.sharedLinksViewedTotal = sharedLinksViewedTotal;
            if (sharedLinksViewedTotal == null) {
                throw new IllegalArgumentException("Required value for 'sharedLinksViewedTotal' is null");
            }
            for (Long x : sharedLinksViewedTotal) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'sharedLinksViewedTotal' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'sharedLinksViewedTotal'': type Nullable");
            }
        }

        static final JsonWriter<GetActivityReport> _writer = new JsonWriter<GetActivityReport>()
        {
            public final void write(GetActivityReport x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                BaseDfbReport._writer.writeFields(x, g);
                GetActivityReport._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GetActivityReport x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("adds");
                g.writeStartArray();
                for (Long item: x.adds) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("edits");
                g.writeStartArray();
                for (Long item: x.edits) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("deletes");
                g.writeStartArray();
                for (Long item: x.deletes) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("active_users_28_day");
                g.writeStartArray();
                for (Long item: x.activeUsers28Day) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("active_users_7_day");
                g.writeStartArray();
                for (Long item: x.activeUsers7Day) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("active_users_1_day");
                g.writeStartArray();
                for (Long item: x.activeUsers1Day) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("active_shared_folders_28_day");
                g.writeStartArray();
                for (Long item: x.activeSharedFolders28Day) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("active_shared_folders_7_day");
                g.writeStartArray();
                for (Long item: x.activeSharedFolders7Day) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("active_shared_folders_1_day");
                g.writeStartArray();
                for (Long item: x.activeSharedFolders1Day) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("shared_links_created");
                g.writeStartArray();
                for (Long item: x.sharedLinksCreated) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("shared_links_viewed_by_team");
                g.writeStartArray();
                for (Long item: x.sharedLinksViewedByTeam) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("shared_links_viewed_by_outside_user");
                g.writeStartArray();
                for (Long item: x.sharedLinksViewedByOutsideUser) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("shared_links_viewed_by_not_logged_in");
                g.writeStartArray();
                for (Long item: x.sharedLinksViewedByNotLoggedIn) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("shared_links_viewed_total");
                g.writeStartArray();
                for (Long item: x.sharedLinksViewedTotal) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<GetActivityReport> _reader = new JsonReader<GetActivityReport>() {

            public final GetActivityReport read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GetActivityReport result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GetActivityReport readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String startDate = null;
                java.util.List<Long> adds = null;
                java.util.List<Long> edits = null;
                java.util.List<Long> deletes = null;
                java.util.List<Long> activeUsers28Day = null;
                java.util.List<Long> activeUsers7Day = null;
                java.util.List<Long> activeUsers1Day = null;
                java.util.List<Long> activeSharedFolders28Day = null;
                java.util.List<Long> activeSharedFolders7Day = null;
                java.util.List<Long> activeSharedFolders1Day = null;
                java.util.List<Long> sharedLinksCreated = null;
                java.util.List<Long> sharedLinksViewedByTeam = null;
                java.util.List<Long> sharedLinksViewedByOutsideUser = null;
                java.util.List<Long> sharedLinksViewedByNotLoggedIn = null;
                java.util.List<Long> sharedLinksViewedTotal = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("start_date".equals(fieldName)) {
                        startDate = JsonReader.StringReader
                            .readField(parser, "start_date", startDate);
                    }
                    else if ("adds".equals(fieldName)) {
                        adds = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "adds", adds);
                    }
                    else if ("edits".equals(fieldName)) {
                        edits = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "edits", edits);
                    }
                    else if ("deletes".equals(fieldName)) {
                        deletes = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "deletes", deletes);
                    }
                    else if ("active_users_28_day".equals(fieldName)) {
                        activeUsers28Day = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "active_users_28_day", activeUsers28Day);
                    }
                    else if ("active_users_7_day".equals(fieldName)) {
                        activeUsers7Day = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "active_users_7_day", activeUsers7Day);
                    }
                    else if ("active_users_1_day".equals(fieldName)) {
                        activeUsers1Day = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "active_users_1_day", activeUsers1Day);
                    }
                    else if ("active_shared_folders_28_day".equals(fieldName)) {
                        activeSharedFolders28Day = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "active_shared_folders_28_day", activeSharedFolders28Day);
                    }
                    else if ("active_shared_folders_7_day".equals(fieldName)) {
                        activeSharedFolders7Day = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "active_shared_folders_7_day", activeSharedFolders7Day);
                    }
                    else if ("active_shared_folders_1_day".equals(fieldName)) {
                        activeSharedFolders1Day = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "active_shared_folders_1_day", activeSharedFolders1Day);
                    }
                    else if ("shared_links_created".equals(fieldName)) {
                        sharedLinksCreated = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "shared_links_created", sharedLinksCreated);
                    }
                    else if ("shared_links_viewed_by_team".equals(fieldName)) {
                        sharedLinksViewedByTeam = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "shared_links_viewed_by_team", sharedLinksViewedByTeam);
                    }
                    else if ("shared_links_viewed_by_outside_user".equals(fieldName)) {
                        sharedLinksViewedByOutsideUser = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "shared_links_viewed_by_outside_user", sharedLinksViewedByOutsideUser);
                    }
                    else if ("shared_links_viewed_by_not_logged_in".equals(fieldName)) {
                        sharedLinksViewedByNotLoggedIn = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "shared_links_viewed_by_not_logged_in", sharedLinksViewedByNotLoggedIn);
                    }
                    else if ("shared_links_viewed_total".equals(fieldName)) {
                        sharedLinksViewedTotal = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "shared_links_viewed_total", sharedLinksViewedTotal);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (startDate == null) {
                    throw new JsonReadException("Required field \"start_date\" is missing.", parser.getTokenLocation());
                }
                if (adds == null) {
                    throw new JsonReadException("Required field \"adds\" is missing.", parser.getTokenLocation());
                }
                if (edits == null) {
                    throw new JsonReadException("Required field \"edits\" is missing.", parser.getTokenLocation());
                }
                if (deletes == null) {
                    throw new JsonReadException("Required field \"deletes\" is missing.", parser.getTokenLocation());
                }
                if (activeUsers28Day == null) {
                    throw new JsonReadException("Required field \"active_users_28_day\" is missing.", parser.getTokenLocation());
                }
                if (activeUsers7Day == null) {
                    throw new JsonReadException("Required field \"active_users_7_day\" is missing.", parser.getTokenLocation());
                }
                if (activeUsers1Day == null) {
                    throw new JsonReadException("Required field \"active_users_1_day\" is missing.", parser.getTokenLocation());
                }
                if (activeSharedFolders28Day == null) {
                    throw new JsonReadException("Required field \"active_shared_folders_28_day\" is missing.", parser.getTokenLocation());
                }
                if (activeSharedFolders7Day == null) {
                    throw new JsonReadException("Required field \"active_shared_folders_7_day\" is missing.", parser.getTokenLocation());
                }
                if (activeSharedFolders1Day == null) {
                    throw new JsonReadException("Required field \"active_shared_folders_1_day\" is missing.", parser.getTokenLocation());
                }
                if (sharedLinksCreated == null) {
                    throw new JsonReadException("Required field \"shared_links_created\" is missing.", parser.getTokenLocation());
                }
                if (sharedLinksViewedByTeam == null) {
                    throw new JsonReadException("Required field \"shared_links_viewed_by_team\" is missing.", parser.getTokenLocation());
                }
                if (sharedLinksViewedByOutsideUser == null) {
                    throw new JsonReadException("Required field \"shared_links_viewed_by_outside_user\" is missing.", parser.getTokenLocation());
                }
                if (sharedLinksViewedByNotLoggedIn == null) {
                    throw new JsonReadException("Required field \"shared_links_viewed_by_not_logged_in\" is missing.", parser.getTokenLocation());
                }
                if (sharedLinksViewedTotal == null) {
                    throw new JsonReadException("Required field \"shared_links_viewed_total\" is missing.", parser.getTokenLocation());
                }
                return new GetActivityReport(startDate, adds, edits, deletes, activeUsers28Day, activeUsers7Day, activeUsers1Day, activeSharedFolders28Day, activeSharedFolders7Day, activeSharedFolders1Day, sharedLinksCreated, sharedLinksViewedByTeam, sharedLinksViewedByOutsideUser, sharedLinksViewedByNotLoggedIn, sharedLinksViewedTotal);
            }
        };

        public String toString() {
            return "GetActivityReport." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GetActivityReport." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GetActivityReport fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Membership Report Result. Each of the items in the storage report is an
     * array of values, one value per day. If there is no data for a day, then
     * the value will be None.
     */
    public static class GetMembershipReport extends BaseDfbReport  {
        // struct GetMembershipReport
        /**
         * Team size, for each day.
         */
        public final java.util.List<Long> teamSize;
        /**
         * The number of pending invites to the team, for each day.
         */
        public final java.util.List<Long> pendingInvites;
        /**
         * The number of members that joined the team, for each day.
         */
        public final java.util.List<Long> membersJoined;
        /**
         * The number of members that joined the team, for each day.
         */
        public final java.util.List<Long> suspendedMembers;
        /**
         * The total number of licenses the team has, for each day.
         */
        public final java.util.List<Long> licenses;

        /**
         * Membership Report Result. Each of the items in the storage report is
         * an array of values, one value per day. If there is no data for a day,
         * then the value will be None.
         *
         * @param startDate  First date present in the results as 'YYYY-MM-DD'
         *     or None. {@code startDate} must not be {@code null}.
         * @param teamSize  Team size, for each day. {@code teamSize} must not
         *     contain a {@code null} item and not be {@code null}.
         * @param pendingInvites  The number of pending invites to the team, for
         *     each day. {@code pendingInvites} must not contain a {@code null}
         *     item and not be {@code null}.
         * @param membersJoined  The number of members that joined the team, for
         *     each day. {@code membersJoined} must not contain a {@code null}
         *     item and not be {@code null}.
         * @param suspendedMembers  The number of members that joined the team,
         *     for each day. {@code suspendedMembers} must not contain a {@code
         *     null} item and not be {@code null}.
         * @param licenses  The total number of licenses the team has, for each
         *     day. {@code licenses} must not contain a {@code null} item and
         *     not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GetMembershipReport(String startDate, java.util.List<Long> teamSize, java.util.List<Long> pendingInvites, java.util.List<Long> membersJoined, java.util.List<Long> suspendedMembers, java.util.List<Long> licenses) {
            super(startDate);
            this.teamSize = teamSize;
            if (teamSize == null) {
                throw new IllegalArgumentException("Required value for 'teamSize' is null");
            }
            for (Long x : teamSize) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'teamSize' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'teamSize'': type Nullable");
            }
            this.pendingInvites = pendingInvites;
            if (pendingInvites == null) {
                throw new IllegalArgumentException("Required value for 'pendingInvites' is null");
            }
            for (Long x : pendingInvites) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'pendingInvites' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'pendingInvites'': type Nullable");
            }
            this.membersJoined = membersJoined;
            if (membersJoined == null) {
                throw new IllegalArgumentException("Required value for 'membersJoined' is null");
            }
            for (Long x : membersJoined) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'membersJoined' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'membersJoined'': type Nullable");
            }
            this.suspendedMembers = suspendedMembers;
            if (suspendedMembers == null) {
                throw new IllegalArgumentException("Required value for 'suspendedMembers' is null");
            }
            for (Long x : suspendedMembers) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'suspendedMembers' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'suspendedMembers'': type Nullable");
            }
            this.licenses = licenses;
            if (licenses == null) {
                throw new IllegalArgumentException("Required value for 'licenses' is null");
            }
            for (Long x : licenses) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'licenses' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'licenses'': type Nullable");
            }
        }

        static final JsonWriter<GetMembershipReport> _writer = new JsonWriter<GetMembershipReport>()
        {
            public final void write(GetMembershipReport x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                BaseDfbReport._writer.writeFields(x, g);
                GetMembershipReport._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GetMembershipReport x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("team_size");
                g.writeStartArray();
                for (Long item: x.teamSize) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("pending_invites");
                g.writeStartArray();
                for (Long item: x.pendingInvites) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("members_joined");
                g.writeStartArray();
                for (Long item: x.membersJoined) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("suspended_members");
                g.writeStartArray();
                for (Long item: x.suspendedMembers) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("licenses");
                g.writeStartArray();
                for (Long item: x.licenses) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<GetMembershipReport> _reader = new JsonReader<GetMembershipReport>() {

            public final GetMembershipReport read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GetMembershipReport result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GetMembershipReport readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String startDate = null;
                java.util.List<Long> teamSize = null;
                java.util.List<Long> pendingInvites = null;
                java.util.List<Long> membersJoined = null;
                java.util.List<Long> suspendedMembers = null;
                java.util.List<Long> licenses = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("start_date".equals(fieldName)) {
                        startDate = JsonReader.StringReader
                            .readField(parser, "start_date", startDate);
                    }
                    else if ("team_size".equals(fieldName)) {
                        teamSize = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "team_size", teamSize);
                    }
                    else if ("pending_invites".equals(fieldName)) {
                        pendingInvites = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "pending_invites", pendingInvites);
                    }
                    else if ("members_joined".equals(fieldName)) {
                        membersJoined = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "members_joined", membersJoined);
                    }
                    else if ("suspended_members".equals(fieldName)) {
                        suspendedMembers = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "suspended_members", suspendedMembers);
                    }
                    else if ("licenses".equals(fieldName)) {
                        licenses = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "licenses", licenses);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (startDate == null) {
                    throw new JsonReadException("Required field \"start_date\" is missing.", parser.getTokenLocation());
                }
                if (teamSize == null) {
                    throw new JsonReadException("Required field \"team_size\" is missing.", parser.getTokenLocation());
                }
                if (pendingInvites == null) {
                    throw new JsonReadException("Required field \"pending_invites\" is missing.", parser.getTokenLocation());
                }
                if (membersJoined == null) {
                    throw new JsonReadException("Required field \"members_joined\" is missing.", parser.getTokenLocation());
                }
                if (suspendedMembers == null) {
                    throw new JsonReadException("Required field \"suspended_members\" is missing.", parser.getTokenLocation());
                }
                if (licenses == null) {
                    throw new JsonReadException("Required field \"licenses\" is missing.", parser.getTokenLocation());
                }
                return new GetMembershipReport(startDate, teamSize, pendingInvites, membersJoined, suspendedMembers, licenses);
            }
        };

        public String toString() {
            return "GetMembershipReport." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GetMembershipReport." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GetMembershipReport fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Each of the items is an array of values, one value per day. The value is
     * the number of devices active within a time window, ending with that day.
     * If there is no data for a day, then the value will be None.
     */
    public static class DevicesActive {
        // struct DevicesActive
        /**
         * Array of number of linked windows (desktop) clients with activity.
         */
        public final java.util.List<Long> windows;
        /**
         * Array of number of linked mac (desktop) clients with activity.
         */
        public final java.util.List<Long> macos;
        /**
         * Array of number of linked linus (desktop) clients with activity.
         */
        public final java.util.List<Long> linux;
        /**
         * Array of number of linked ios devices with activity.
         */
        public final java.util.List<Long> ios;
        /**
         * Array of number of linked android devices with activity.
         */
        public final java.util.List<Long> android;
        /**
         * Array of number of other linked devices (blackberry, windows phone,
         * etc)  with activity.
         */
        public final java.util.List<Long> other;
        /**
         * Array of total number of linked clients with activity.
         */
        public final java.util.List<Long> total;

        /**
         * Each of the items is an array of values, one value per day. The value
         * is the number of devices active within a time window, ending with
         * that day. If there is no data for a day, then the value will be None.
         *
         * @param windows  Array of number of linked windows (desktop) clients
         *     with activity. {@code windows} must not contain a {@code null}
         *     item and not be {@code null}.
         * @param macos  Array of number of linked mac (desktop) clients with
         *     activity. {@code macos} must not contain a {@code null} item and
         *     not be {@code null}.
         * @param linux  Array of number of linked linus (desktop) clients with
         *     activity. {@code linux} must not contain a {@code null} item and
         *     not be {@code null}.
         * @param ios  Array of number of linked ios devices with activity.
         *     {@code ios} must not contain a {@code null} item and not be
         *     {@code null}.
         * @param android  Array of number of linked android devices with
         *     activity. {@code android} must not contain a {@code null} item
         *     and not be {@code null}.
         * @param other  Array of number of other linked devices (blackberry,
         *     windows phone, etc)  with activity. {@code other} must not
         *     contain a {@code null} item and not be {@code null}.
         * @param total  Array of total number of linked clients with activity.
         *     {@code total} must not contain a {@code null} item and not be
         *     {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public DevicesActive(java.util.List<Long> windows, java.util.List<Long> macos, java.util.List<Long> linux, java.util.List<Long> ios, java.util.List<Long> android, java.util.List<Long> other, java.util.List<Long> total) {
            this.windows = windows;
            if (windows == null) {
                throw new IllegalArgumentException("Required value for 'windows' is null");
            }
            for (Long x : windows) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'windows' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'windows'': type Nullable");
            }
            this.macos = macos;
            if (macos == null) {
                throw new IllegalArgumentException("Required value for 'macos' is null");
            }
            for (Long x : macos) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'macos' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'macos'': type Nullable");
            }
            this.linux = linux;
            if (linux == null) {
                throw new IllegalArgumentException("Required value for 'linux' is null");
            }
            for (Long x : linux) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'linux' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'linux'': type Nullable");
            }
            this.ios = ios;
            if (ios == null) {
                throw new IllegalArgumentException("Required value for 'ios' is null");
            }
            for (Long x : ios) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'ios' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'ios'': type Nullable");
            }
            this.android = android;
            if (android == null) {
                throw new IllegalArgumentException("Required value for 'android' is null");
            }
            for (Long x : android) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'android' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'android'': type Nullable");
            }
            this.other = other;
            if (other == null) {
                throw new IllegalArgumentException("Required value for 'other' is null");
            }
            for (Long x : other) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'other' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'other'': type Nullable");
            }
            this.total = total;
            if (total == null) {
                throw new IllegalArgumentException("Required value for 'total' is null");
            }
            for (Long x : total) {
                if (x == null) {
                    throw new IllegalArgumentException("An item in list 'total' is null");
                }
                throw new RuntimeException("XXX Don't know how to validate  'an item in list 'total'': type Nullable");
            }
        }

        static final JsonWriter<DevicesActive> _writer = new JsonWriter<DevicesActive>()
        {
            public final void write(DevicesActive x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                DevicesActive._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(DevicesActive x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("windows");
                g.writeStartArray();
                for (Long item: x.windows) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("macos");
                g.writeStartArray();
                for (Long item: x.macos) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("linux");
                g.writeStartArray();
                for (Long item: x.linux) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("ios");
                g.writeStartArray();
                for (Long item: x.ios) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("android");
                g.writeStartArray();
                for (Long item: x.android) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("other");
                g.writeStartArray();
                for (Long item: x.other) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
                g.writeFieldName("total");
                g.writeStartArray();
                for (Long item: x.total) {
                    if (item != null) {
                        g.writeNumber(item);
                    }
                }
                g.writeEndArray();
            }
        };

        public static final JsonReader<DevicesActive> _reader = new JsonReader<DevicesActive>() {

            public final DevicesActive read(JsonParser parser)
                throws IOException, JsonReadException
            {
                DevicesActive result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final DevicesActive readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                java.util.List<Long> windows = null;
                java.util.List<Long> macos = null;
                java.util.List<Long> linux = null;
                java.util.List<Long> ios = null;
                java.util.List<Long> android = null;
                java.util.List<Long> other = null;
                java.util.List<Long> total = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("windows".equals(fieldName)) {
                        windows = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "windows", windows);
                    }
                    else if ("macos".equals(fieldName)) {
                        macos = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "macos", macos);
                    }
                    else if ("linux".equals(fieldName)) {
                        linux = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "linux", linux);
                    }
                    else if ("ios".equals(fieldName)) {
                        ios = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "ios", ios);
                    }
                    else if ("android".equals(fieldName)) {
                        android = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "android", android);
                    }
                    else if ("other".equals(fieldName)) {
                        other = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "other", other);
                    }
                    else if ("total".equals(fieldName)) {
                        total = JsonArrayReader.mk(JsonReader.UInt64Reader)
                            .readField(parser, "total", total);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (windows == null) {
                    throw new JsonReadException("Required field \"windows\" is missing.", parser.getTokenLocation());
                }
                if (macos == null) {
                    throw new JsonReadException("Required field \"macos\" is missing.", parser.getTokenLocation());
                }
                if (linux == null) {
                    throw new JsonReadException("Required field \"linux\" is missing.", parser.getTokenLocation());
                }
                if (ios == null) {
                    throw new JsonReadException("Required field \"ios\" is missing.", parser.getTokenLocation());
                }
                if (android == null) {
                    throw new JsonReadException("Required field \"android\" is missing.", parser.getTokenLocation());
                }
                if (other == null) {
                    throw new JsonReadException("Required field \"other\" is missing.", parser.getTokenLocation());
                }
                if (total == null) {
                    throw new JsonReadException("Required field \"total\" is missing.", parser.getTokenLocation());
                }
                return new DevicesActive(windows, macos, linux, ios, android, other, total);
            }
        };

        public String toString() {
            return "DevicesActive." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "DevicesActive." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static DevicesActive fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }


    /**
     * Devices Report Result. Contains subsections for different time ranges of
     * activity. Each of the items in each subsection of the storage report is
     * an array of values, one value per day. If there is no data for a day,
     * then the value will be None.
     */
    public static class GetDevicesReport extends BaseDfbReport  {
        // struct GetDevicesReport
        /**
         * Report of the number of devices active in the last day.
         */
        public final DevicesActive active1Day;
        /**
         * Report of the number of devices active in the last 7 days.
         */
        public final DevicesActive active7Day;
        /**
         * Report of the number of devices active in the last 28 days.
         */
        public final DevicesActive active28Day;

        /**
         * Devices Report Result. Contains subsections for different time ranges
         * of activity. Each of the items in each subsection of the storage
         * report is an array of values, one value per day. If there is no data
         * for a day, then the value will be None.
         *
         * @param startDate  First date present in the results as 'YYYY-MM-DD'
         *     or None. {@code startDate} must not be {@code null}.
         * @param active1Day  Report of the number of devices active in the last
         *     day. {@code active1Day} must not be {@code null}.
         * @param active7Day  Report of the number of devices active in the last
         *     7 days. {@code active7Day} must not be {@code null}.
         * @param active28Day  Report of the number of devices active in the
         *     last 28 days. {@code active28Day} must not be {@code null}.
         *
         * @throws IllegalArgumentException  if any argument does not meet its
         *     preconditions.
         */
        public GetDevicesReport(String startDate, DevicesActive active1Day, DevicesActive active7Day, DevicesActive active28Day) {
            super(startDate);
            this.active1Day = active1Day;
            if (active1Day == null) {
                throw new IllegalArgumentException("Required value for 'active1Day' is null");
            }
            this.active7Day = active7Day;
            if (active7Day == null) {
                throw new IllegalArgumentException("Required value for 'active7Day' is null");
            }
            this.active28Day = active28Day;
            if (active28Day == null) {
                throw new IllegalArgumentException("Required value for 'active28Day' is null");
            }
        }

        static final JsonWriter<GetDevicesReport> _writer = new JsonWriter<GetDevicesReport>()
        {
            public final void write(GetDevicesReport x, JsonGenerator g)
             throws IOException
            {
                g.writeStartObject();
                BaseDfbReport._writer.writeFields(x, g);
                GetDevicesReport._writer.writeFields(x, g);
                g.writeEndObject();
            }
            public final void writeFields(GetDevicesReport x, JsonGenerator g)
             throws IOException
            {
                g.writeFieldName("active_1_day");
                DevicesActive._writer.write(x.active1Day, g);
                g.writeFieldName("active_7_day");
                DevicesActive._writer.write(x.active7Day, g);
                g.writeFieldName("active_28_day");
                DevicesActive._writer.write(x.active28Day, g);
            }
        };

        public static final JsonReader<GetDevicesReport> _reader = new JsonReader<GetDevicesReport>() {

            public final GetDevicesReport read(JsonParser parser)
                throws IOException, JsonReadException
            {
                GetDevicesReport result;
                JsonReader.expectObjectStart(parser);
                result = readFields(parser);
                JsonReader.expectObjectEnd(parser);
                return result;
            }

            public final GetDevicesReport readFields(JsonParser parser)
                throws IOException, JsonReadException
            {
                String startDate = null;
                DevicesActive active1Day = null;
                DevicesActive active7Day = null;
                DevicesActive active28Day = null;
                while (parser.getCurrentToken() == JsonToken.FIELD_NAME) {
                    String fieldName = parser.getCurrentName();
                    parser.nextToken();
                    if ("start_date".equals(fieldName)) {
                        startDate = JsonReader.StringReader
                            .readField(parser, "start_date", startDate);
                    }
                    else if ("active_1_day".equals(fieldName)) {
                        active1Day = DevicesActive._reader
                            .readField(parser, "active_1_day", active1Day);
                    }
                    else if ("active_7_day".equals(fieldName)) {
                        active7Day = DevicesActive._reader
                            .readField(parser, "active_7_day", active7Day);
                    }
                    else if ("active_28_day".equals(fieldName)) {
                        active28Day = DevicesActive._reader
                            .readField(parser, "active_28_day", active28Day);
                    }
                    else { JsonReader.skipValue(parser); }
                }
                if (startDate == null) {
                    throw new JsonReadException("Required field \"start_date\" is missing.", parser.getTokenLocation());
                }
                if (active1Day == null) {
                    throw new JsonReadException("Required field \"active_1_day\" is missing.", parser.getTokenLocation());
                }
                if (active7Day == null) {
                    throw new JsonReadException("Required field \"active_7_day\" is missing.", parser.getTokenLocation());
                }
                if (active28Day == null) {
                    throw new JsonReadException("Required field \"active_28_day\" is missing.", parser.getTokenLocation());
                }
                return new GetDevicesReport(startDate, active1Day, active7Day, active28Day);
            }
        };

        public String toString() {
            return "GetDevicesReport." + _writer.writeToString(this, false);
        }

        public String toStringMultiline() {
            return "GetDevicesReport." + _writer.writeToString(this, true);
        }

        public String toJson(Boolean longForm) {
            return _writer.writeToString(this, longForm);
        }

        public static GetDevicesReport fromJson(String s)
            throws JsonReadException
        {
            return _reader.readFully(s);
        }
    }

    /**
     * Exception thrown by {@link DbxTeam#getInfo}.
     */
    public static class GetInfoException extends DbxApiException {
        public GetInfoException(String requestId, LocalizedText userMessage) {
            super(requestId, userMessage, buildMessage("get_info", userMessage));
        }
    }
    /**
     * Retrieves information about a team.
     */
    public TeamGetInfoResult getInfo()
            throws GetInfoException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/get_info",
                                   null,
                                   false,
                                   null,
                                   TeamGetInfoResult._reader,
                                   JsonReader.VoidReader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GetInfoException(ew.requestId, ew.userMessage);
        }
    }

    /**
     * Exception thrown by {@link DbxTeam#devicesListMemberDevicesBuilder}.
     */
    public static class DevicesListMemberDevicesException extends DbxApiException {
        /**
         * The error reported by devicesListMemberDevices.
         */
        public final ListMemberDevicesError errorValue;

        public DevicesListMemberDevicesException(String requestId, LocalizedText userMessage, ListMemberDevicesError errorValue) {
            super(requestId, userMessage, buildMessage("devices/list_member_devices", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * List all device sessions of a team's member.
     */
    private ListMemberDevicesResult devicesListMemberDevices(ListMemberDevicesArg arg)
            throws DevicesListMemberDevicesException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/devices/list_member_devices",
                                   arg,
                                   false,
                                   ListMemberDevicesArg._writer,
                                   ListMemberDevicesResult._reader,
                                   ListMemberDevicesError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new DevicesListMemberDevicesException(ew.requestId, ew.userMessage, (ListMemberDevicesError) (ew.errValue));
        }
    }
    /**
     * List all device sessions of a team's member.
     *
     * @param teamMemberId  The team's member id. {@code teamMemberId} must not
     *     be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public ListMemberDevicesResult devicesListMemberDevices(String teamMemberId)
          throws DevicesListMemberDevicesException, DbxException
    {
        ListMemberDevicesArg arg = new ListMemberDevicesArg(teamMemberId, null, null, null);
        return devicesListMemberDevices(arg);
    }
    /**
     * The builder object returned by {@link #devicesListMemberDevicesBuilder}
     */
    public final class DevicesListMemberDevicesBuilder
    {
        private String teamMemberId;
        private Boolean includeWebSessions;
        private Boolean includeDesktopClients;
        private Boolean includeMobileClients;

        private DevicesListMemberDevicesBuilder(String teamMemberId)
        {
            if (teamMemberId == null) {
                throw new IllegalArgumentException("Required value for 'teamMemberId' is null");
            }
            this.teamMemberId = teamMemberId;
        }

        /**
         * Set value for optional request field {@code includeWebSessions}.
         *
         * @param includeWebSessions  Whether to list web sessions of the team's
         *     member.
         */
        public DevicesListMemberDevicesBuilder includeWebSessions(boolean includeWebSessions)
        {
            this.includeWebSessions = includeWebSessions;
            return this;
        }

        /**
         * Set value for optional request field {@code includeDesktopClients}.
         *
         * @param includeDesktopClients  Whether to list linked desktop devices
         *     of the team's member.
         */
        public DevicesListMemberDevicesBuilder includeDesktopClients(boolean includeDesktopClients)
        {
            this.includeDesktopClients = includeDesktopClients;
            return this;
        }

        /**
         * Set value for optional request field {@code includeMobileClients}.
         *
         * @param includeMobileClients  Whether to list linked mobile devices of
         *     the team's member.
         */
        public DevicesListMemberDevicesBuilder includeMobileClients(boolean includeMobileClients)
        {
            this.includeMobileClients = includeMobileClients;
            return this;
        }

        /**
         * Issues the request.
         */
        public ListMemberDevicesResult start() throws DevicesListMemberDevicesException, DbxException
        {
            ListMemberDevicesArg arg = new ListMemberDevicesArg(teamMemberId, includeWebSessions, includeDesktopClients, includeMobileClients);
            return DbxTeam.this.devicesListMemberDevices(arg);
        }
    }

    /**
     * List all device sessions of a team's member.
     *
     * @param teamMemberId  The team's member id. {@code teamMemberId} must not
     *     be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public DevicesListMemberDevicesBuilder devicesListMemberDevicesBuilder(String teamMemberId)
    {
        return new DevicesListMemberDevicesBuilder(teamMemberId);
    }

    /**
     * Exception thrown by {@link DbxTeam#devicesListTeamDevicesBuilder}.
     */
    public static class DevicesListTeamDevicesException extends DbxApiException {
        /**
         * The error reported by devicesListTeamDevices.
         */
        public final ListTeamDevicesError errorValue;

        public DevicesListTeamDevicesException(String requestId, LocalizedText userMessage, ListTeamDevicesError errorValue) {
            super(requestId, userMessage, buildMessage("devices/list_team_devices", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * List all device sessions of a team.
     */
    private ListTeamDevicesResult devicesListTeamDevices(ListTeamDevicesArg arg)
            throws DevicesListTeamDevicesException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/devices/list_team_devices",
                                   arg,
                                   false,
                                   ListTeamDevicesArg._writer,
                                   ListTeamDevicesResult._reader,
                                   ListTeamDevicesError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new DevicesListTeamDevicesException(ew.requestId, ew.userMessage, (ListTeamDevicesError) (ew.errValue));
        }
    }
    /**
     * List all device sessions of a team.
     */
    public ListTeamDevicesResult devicesListTeamDevices()
          throws DevicesListTeamDevicesException, DbxException
    {
        ListTeamDevicesArg arg = new ListTeamDevicesArg(null, null, null, null);
        return devicesListTeamDevices(arg);
    }
    /**
     * The builder object returned by {@link #devicesListTeamDevicesBuilder}
     */
    public final class DevicesListTeamDevicesBuilder
    {
        private String cursor;
        private Boolean includeWebSessions;
        private Boolean includeDesktopClients;
        private Boolean includeMobileClients;

        private DevicesListTeamDevicesBuilder()
        {
        }

        /**
         * Set value for optional request field {@code cursor}.
         *
         * @param cursor  At the first call to the {@link
         *     DbxTeam#devicesListTeamDevicesBuilder} the cursor shouldn't be
         *     passed. Then, if the result of the call includes a cursor, the
         *     following requests should include the received cursors in order
         *     to receive the next sub list of team devices.
         */
        public DevicesListTeamDevicesBuilder cursor(String cursor)
        {
            this.cursor = cursor;
            return this;
        }

        /**
         * Set value for optional request field {@code includeWebSessions}.
         *
         * @param includeWebSessions  Whether to list web sessions of the team
         *     members.
         */
        public DevicesListTeamDevicesBuilder includeWebSessions(boolean includeWebSessions)
        {
            this.includeWebSessions = includeWebSessions;
            return this;
        }

        /**
         * Set value for optional request field {@code includeDesktopClients}.
         *
         * @param includeDesktopClients  Whether to list desktop clients of the
         *     team members.
         */
        public DevicesListTeamDevicesBuilder includeDesktopClients(boolean includeDesktopClients)
        {
            this.includeDesktopClients = includeDesktopClients;
            return this;
        }

        /**
         * Set value for optional request field {@code includeMobileClients}.
         *
         * @param includeMobileClients  Whether to list mobile clients of the
         *     team members.
         */
        public DevicesListTeamDevicesBuilder includeMobileClients(boolean includeMobileClients)
        {
            this.includeMobileClients = includeMobileClients;
            return this;
        }

        /**
         * Issues the request.
         */
        public ListTeamDevicesResult start() throws DevicesListTeamDevicesException, DbxException
        {
            ListTeamDevicesArg arg = new ListTeamDevicesArg(cursor, includeWebSessions, includeDesktopClients, includeMobileClients);
            return DbxTeam.this.devicesListTeamDevices(arg);
        }
    }

    /**
     * List all device sessions of a team.
     */
    public DevicesListTeamDevicesBuilder devicesListTeamDevicesBuilder()
    {
        return new DevicesListTeamDevicesBuilder();
    }

    /**
     * Exception thrown by {@link DbxTeam#devicesRevokeDeviceSession}.
     */
    public static class DevicesRevokeDeviceSessionException extends DbxApiException {
        /**
         * The error reported by devicesRevokeDeviceSession.
         */
        public final RevokeDeviceSessionError errorValue;

        public DevicesRevokeDeviceSessionException(String requestId, LocalizedText userMessage, RevokeDeviceSessionError errorValue) {
            super(requestId, userMessage, buildMessage("devices/revoke_device_session", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Revoke a device session of a team's member
     */
    private void devicesRevokeDeviceSession(RevokeDeviceSessionArg arg)
            throws DevicesRevokeDeviceSessionException, DbxException
    {
        try {
            client.rpcStyle(client.getHost().api,
                            "2/team/devices/revoke_device_session",
                            arg,
                            false,
                            RevokeDeviceSessionArg._writer,
                            JsonReader.VoidReader,
                            RevokeDeviceSessionError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new DevicesRevokeDeviceSessionException(ew.requestId, ew.userMessage, (RevokeDeviceSessionError) (ew.errValue));
        }
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#devicesRevokeDeviceSessionBatch(java.util.List)}.
     */
    public static class DevicesRevokeDeviceSessionBatchException extends DbxApiException {
        /**
         * The error reported by devicesRevokeDeviceSessionBatch.
         */
        public final RevokeDeviceSessionBatchError errorValue;

        public DevicesRevokeDeviceSessionBatchException(String requestId, LocalizedText userMessage, RevokeDeviceSessionBatchError errorValue) {
            super(requestId, userMessage, buildMessage("devices/revoke_device_session_batch", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Revoke a list of device sessions of team members
     */
    private RevokeDeviceSessionBatchResult devicesRevokeDeviceSessionBatch(RevokeDeviceSessionBatchArg arg)
            throws DevicesRevokeDeviceSessionBatchException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/devices/revoke_device_session_batch",
                                   arg,
                                   false,
                                   RevokeDeviceSessionBatchArg._writer,
                                   RevokeDeviceSessionBatchResult._reader,
                                   RevokeDeviceSessionBatchError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new DevicesRevokeDeviceSessionBatchException(ew.requestId, ew.userMessage, (RevokeDeviceSessionBatchError) (ew.errValue));
        }
    }
    /**
     * Revoke a list of device sessions of team members
     *
     * @param revokeDevices  . {@code revokeDevices} must not contain a {@code
     *     null} item and not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public RevokeDeviceSessionBatchResult devicesRevokeDeviceSessionBatch(java.util.List<RevokeDeviceSessionArg> revokeDevices)
          throws DevicesRevokeDeviceSessionBatchException, DbxException
    {
        RevokeDeviceSessionBatchArg arg = new RevokeDeviceSessionBatchArg(revokeDevices);
        return devicesRevokeDeviceSessionBatch(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#groupsList(long)}.
     */
    public static class GroupsListException extends DbxApiException {
        public GroupsListException(String requestId, LocalizedText userMessage) {
            super(requestId, userMessage, buildMessage("groups/list", userMessage));
        }
    }
    /**
     * Lists groups on a team. Permission : Team Information
     */
    private GroupsListResult groupsList(GroupsListArg arg)
            throws GroupsListException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/list",
                                   arg,
                                   false,
                                   GroupsListArg._writer,
                                   GroupsListResult._reader,
                                   JsonReader.VoidReader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsListException(ew.requestId, ew.userMessage);
        }
    }
    /**
     * Lists groups on a team. Permission : Team Information
     */
    public GroupsListResult groupsList()
          throws GroupsListException, DbxException
    {
        GroupsListArg arg = new GroupsListArg(null);
        return groupsList(arg);
    }
    /**
     * Lists groups on a team. Permission : Team Information
     *
     * @param limit  Number of results to return per call. {@code limit} must be
     *     greater than or equal to 1 and be less than or equal to 1000.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupsListResult groupsList(long limit)
          throws GroupsListException, DbxException
    {
        GroupsListArg arg = new GroupsListArg(limit);
        return groupsList(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#groupsListContinue(String)}.
     */
    public static class GroupsListContinueException extends DbxApiException {
        /**
         * The error reported by groupsListContinue.
         */
        public final GroupsListContinueError errorValue;

        public GroupsListContinueException(String requestId, LocalizedText userMessage, GroupsListContinueError errorValue) {
            super(requestId, userMessage, buildMessage("groups/list/continue", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Once a cursor has been retrieved from {@link DbxTeam#groupsList(long)},
     * use this to paginate through all groups. Permission : Team information
     */
    private GroupsListResult groupsListContinue(GroupsListContinueArg arg)
            throws GroupsListContinueException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/list/continue",
                                   arg,
                                   false,
                                   GroupsListContinueArg._writer,
                                   GroupsListResult._reader,
                                   GroupsListContinueError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsListContinueException(ew.requestId, ew.userMessage, (GroupsListContinueError) (ew.errValue));
        }
    }
    /**
     * Once a cursor has been retrieved from {@link DbxTeam#groupsList(long)},
     * use this to paginate through all groups. Permission : Team information
     *
     * @param cursor  Indicates from what point to get the next set of groups.
     *     {@code cursor} must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupsListResult groupsListContinue(String cursor)
          throws GroupsListContinueException, DbxException
    {
        GroupsListContinueArg arg = new GroupsListContinueArg(cursor);
        return groupsListContinue(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#groupsGetInfo}.
     */
    public static class GroupsGetInfoException extends DbxApiException {
        /**
         * The error reported by groupsGetInfo.
         */
        public final GroupsGetInfoError errorValue;

        public GroupsGetInfoException(String requestId, LocalizedText userMessage, GroupsGetInfoError errorValue) {
            super(requestId, userMessage, buildMessage("groups/get_info", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Retrieves information about one or more groups. Permission : Team
     * Information
     */
    private java.util.List<GroupsGetInfoItem> groupsGetInfo(GroupsSelector arg)
            throws GroupsGetInfoException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/get_info",
                                   arg,
                                   false,
                                   GroupsSelector._writer,
                                   JsonArrayReader.mk(GroupsGetInfoItem._reader),
                                   GroupsGetInfoError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsGetInfoException(ew.requestId, ew.userMessage, (GroupsGetInfoError) (ew.errValue));
        }
    }

    /**
     * Exception thrown by {@link DbxTeam#groupsCreate(String,String)}.
     */
    public static class GroupsCreateException extends DbxApiException {
        /**
         * The error reported by groupsCreate.
         */
        public final GroupCreateError errorValue;

        public GroupsCreateException(String requestId, LocalizedText userMessage, GroupCreateError errorValue) {
            super(requestId, userMessage, buildMessage("groups/create", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Creates a new, empty group, with a requested name. Permission : Team
     * member management
     */
    private GroupFullInfo groupsCreate(GroupCreateArg arg)
            throws GroupsCreateException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/create",
                                   arg,
                                   false,
                                   GroupCreateArg._writer,
                                   GroupFullInfo._reader,
                                   GroupCreateError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsCreateException(ew.requestId, ew.userMessage, (GroupCreateError) (ew.errValue));
        }
    }
    /**
     * Creates a new, empty group, with a requested name. Permission : Team
     * member management
     *
     * @param groupName  Group name. {@code groupName} must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupFullInfo groupsCreate(String groupName)
          throws GroupsCreateException, DbxException
    {
        GroupCreateArg arg = new GroupCreateArg(groupName, null);
        return groupsCreate(arg);
    }
    /**
     * Creates a new, empty group, with a requested name. Permission : Team
     * member management
     *
     * @param groupName  Group name. {@code groupName} must not be {@code null}.
     * @param groupExternalId  Optional argument. The creator of a team can
     *     associate an arbitrary external ID to the group.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupFullInfo groupsCreate(String groupName, String groupExternalId)
          throws GroupsCreateException, DbxException
    {
        GroupCreateArg arg = new GroupCreateArg(groupName, groupExternalId);
        return groupsCreate(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#groupsDelete}.
     */
    public static class GroupsDeleteException extends DbxApiException {
        /**
         * The error reported by groupsDelete.
         */
        public final GroupDeleteError errorValue;

        public GroupsDeleteException(String requestId, LocalizedText userMessage, GroupDeleteError errorValue) {
            super(requestId, userMessage, buildMessage("groups/delete", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Deletes a group. The group is deleted immediately. However the revoking
     * of group-owned resources may take additional time. Use the {@link
     * DbxTeam#groupsJobStatusGet(String)} to determine whether this process has
     * completed. Permission : Team member management
     */
    private DbxAsync.LaunchEmptyResult groupsDelete(GroupSelector arg)
            throws GroupsDeleteException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/delete",
                                   arg,
                                   false,
                                   GroupSelector._writer,
                                   DbxAsync.LaunchEmptyResult._reader,
                                   GroupDeleteError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsDeleteException(ew.requestId, ew.userMessage, (GroupDeleteError) (ew.errValue));
        }
    }

    /**
     * Exception thrown by {@link DbxTeam#groupsUpdateBuilder}.
     */
    public static class GroupsUpdateException extends DbxApiException {
        /**
         * The error reported by groupsUpdate.
         */
        public final GroupUpdateError errorValue;

        public GroupsUpdateException(String requestId, LocalizedText userMessage, GroupUpdateError errorValue) {
            super(requestId, userMessage, buildMessage("groups/update", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Updates a group's name and/or external ID. Permission : Team member
     * management
     */
    private GroupFullInfo groupsUpdate(GroupUpdateArgs arg)
            throws GroupsUpdateException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/update",
                                   arg,
                                   false,
                                   GroupUpdateArgs._writer,
                                   GroupFullInfo._reader,
                                   GroupUpdateError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsUpdateException(ew.requestId, ew.userMessage, (GroupUpdateError) (ew.errValue));
        }
    }
    /**
     * Updates a group's name and/or external ID. Permission : Team member
     * management
     *
     * @param group  Specify a group. {@code group} must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupFullInfo groupsUpdate(GroupSelector group)
          throws GroupsUpdateException, DbxException
    {
        GroupUpdateArgs arg = new GroupUpdateArgs(group, null, null);
        return groupsUpdate(arg);
    }
    /**
     * The builder object returned by {@link #groupsUpdateBuilder}
     */
    public final class GroupsUpdateBuilder
    {
        private GroupSelector group;
        private String newGroupName;
        private String newGroupExternalId;

        private GroupsUpdateBuilder(GroupSelector group)
        {
            if (group == null) {
                throw new IllegalArgumentException("Required value for 'group' is null");
            }
            this.group = group;
        }

        /**
         * Set value for optional request field {@code newGroupName}.
         *
         * @param newGroupName  Optional argument. Set group name to this if
         *     provided.
         */
        public GroupsUpdateBuilder newGroupName(String newGroupName)
        {
            this.newGroupName = newGroupName;
            return this;
        }

        /**
         * Set value for optional request field {@code newGroupExternalId}.
         *
         * @param newGroupExternalId  Optional argument. New group external ID.
         *     If the argument is None, the group's external_id won't be
         *     updated. If the argument is empty string, the group's external id
         *     will be cleared.
         */
        public GroupsUpdateBuilder newGroupExternalId(String newGroupExternalId)
        {
            this.newGroupExternalId = newGroupExternalId;
            return this;
        }

        /**
         * Issues the request.
         */
        public GroupFullInfo start() throws GroupsUpdateException, DbxException
        {
            GroupUpdateArgs arg = new GroupUpdateArgs(group, newGroupName, newGroupExternalId);
            return DbxTeam.this.groupsUpdate(arg);
        }
    }

    /**
     * Updates a group's name and/or external ID. Permission : Team member
     * management
     *
     * @param group  Specify a group. {@code group} must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupsUpdateBuilder groupsUpdateBuilder(GroupSelector group)
    {
        return new GroupsUpdateBuilder(group);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#groupsMembersAdd(DbxTeam.GroupSelector,java.util.List)}.
     */
    public static class GroupsMembersAddException extends DbxApiException {
        /**
         * The error reported by groupsMembersAdd.
         */
        public final GroupMembersAddError errorValue;

        public GroupsMembersAddException(String requestId, LocalizedText userMessage, GroupMembersAddError errorValue) {
            super(requestId, userMessage, buildMessage("groups/members/add", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Adds members to a group. The members are added immediately. However the
     * granting of group-owned resources may take additional time. Use the
     * {@link DbxTeam#groupsJobStatusGet(String)} to determine whether this
     * process has completed. Permission : Team member management
     */
    private GroupMembersChangeResult groupsMembersAdd(GroupMembersAddArg arg)
            throws GroupsMembersAddException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/members/add",
                                   arg,
                                   false,
                                   GroupMembersAddArg._writer,
                                   GroupMembersChangeResult._reader,
                                   GroupMembersAddError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsMembersAddException(ew.requestId, ew.userMessage, (GroupMembersAddError) (ew.errValue));
        }
    }
    /**
     * Adds members to a group. The members are added immediately. However the
     * granting of group-owned resources may take additional time. Use the
     * {@link DbxTeam#groupsJobStatusGet(String)} to determine whether this
     * process has completed. Permission : Team member management
     *
     * @param group  Group to which users will be added. {@code group} must not
     *     be {@code null}.
     * @param members  List of users to be added to the group. {@code members}
     *     must not contain a {@code null} item and not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupMembersChangeResult groupsMembersAdd(GroupSelector group, java.util.List<MemberAccess> members)
          throws GroupsMembersAddException, DbxException
    {
        GroupMembersAddArg arg = new GroupMembersAddArg(group, members);
        return groupsMembersAdd(arg);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#groupsMembersRemove(DbxTeam.GroupSelector,java.util.List)}.
     */
    public static class GroupsMembersRemoveException extends DbxApiException {
        /**
         * The error reported by groupsMembersRemove.
         */
        public final GroupMembersRemoveError errorValue;

        public GroupsMembersRemoveException(String requestId, LocalizedText userMessage, GroupMembersRemoveError errorValue) {
            super(requestId, userMessage, buildMessage("groups/members/remove", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Removes members from a group. The members are removed immediately.
     * However the revoking of group-owned resources may take additional time.
     * Use the {@link DbxTeam#groupsJobStatusGet(String)} to determine whether
     * this process has completed. Permission : Team member management
     */
    private GroupMembersChangeResult groupsMembersRemove(GroupMembersRemoveArg arg)
            throws GroupsMembersRemoveException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/members/remove",
                                   arg,
                                   false,
                                   GroupMembersRemoveArg._writer,
                                   GroupMembersChangeResult._reader,
                                   GroupMembersRemoveError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsMembersRemoveException(ew.requestId, ew.userMessage, (GroupMembersRemoveError) (ew.errValue));
        }
    }
    /**
     * Removes members from a group. The members are removed immediately.
     * However the revoking of group-owned resources may take additional time.
     * Use the {@link DbxTeam#groupsJobStatusGet(String)} to determine whether
     * this process has completed. Permission : Team member management
     *
     * @param group  . {@code group} must not be {@code null}.
     * @param users  . {@code users} must not contain a {@code null} item and
     *     not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public GroupMembersChangeResult groupsMembersRemove(GroupSelector group, java.util.List<UserSelectorArg> users)
          throws GroupsMembersRemoveException, DbxException
    {
        GroupMembersRemoveArg arg = new GroupMembersRemoveArg(group, users);
        return groupsMembersRemove(arg);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#groupsMembersSetAccessType(DbxTeam.GroupSelector,DbxTeam.UserSelectorArg,DbxTeam.GroupAccessType)}.
     */
    public static class GroupsMembersSetAccessTypeException extends DbxApiException {
        /**
         * The error reported by groupsMembersSetAccessType.
         */
        public final GroupMemberSelectorError errorValue;

        public GroupsMembersSetAccessTypeException(String requestId, LocalizedText userMessage, GroupMemberSelectorError errorValue) {
            super(requestId, userMessage, buildMessage("groups/members/set_access_type", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Sets a member's access type in a group. Permission : Team member
     * management
     */
    private java.util.List<GroupsGetInfoItem> groupsMembersSetAccessType(GroupMembersSetAccessTypeArg arg)
            throws GroupsMembersSetAccessTypeException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/members/set_access_type",
                                   arg,
                                   false,
                                   GroupMembersSetAccessTypeArg._writer,
                                   JsonArrayReader.mk(GroupsGetInfoItem._reader),
                                   GroupMemberSelectorError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsMembersSetAccessTypeException(ew.requestId, ew.userMessage, (GroupMemberSelectorError) (ew.errValue));
        }
    }
    /**
     * Sets a member's access type in a group. Permission : Team member
     * management
     *
     * @param group  Specify a group. {@code group} must not be {@code null}.
     * @param user  Identity of a user that is a member of {@code group}. {@code
     *     user} must not be {@code null}.
     * @param accessType  New group access type the user will have. {@code
     *     accessType} must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public java.util.List<GroupsGetInfoItem> groupsMembersSetAccessType(GroupSelector group, UserSelectorArg user, GroupAccessType accessType)
          throws GroupsMembersSetAccessTypeException, DbxException
    {
        GroupMembersSetAccessTypeArg arg = new GroupMembersSetAccessTypeArg(group, user, accessType);
        return groupsMembersSetAccessType(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#groupsJobStatusGet(String)}.
     */
    public static class GroupsJobStatusGetException extends DbxApiException {
        /**
         * The error reported by groupsJobStatusGet.
         */
        public final GroupsPollError errorValue;

        public GroupsJobStatusGetException(String requestId, LocalizedText userMessage, GroupsPollError errorValue) {
            super(requestId, userMessage, buildMessage("groups/job_status/get", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Once an async_job_id is returned from {@link DbxTeam#groupsDelete},
     * {@link DbxTeam#groupsMembersAdd(DbxTeam.GroupSelector,java.util.List)} ,
     * or {@link
     * DbxTeam#groupsMembersRemove(DbxTeam.GroupSelector,java.util.List)} use
     * this method to poll the status of granting/revoking group members' access
     * to group-owned resources. Permission : Team member management
     */
    private DbxAsync.PollEmptyResult groupsJobStatusGet(DbxAsync.PollArg arg)
            throws GroupsJobStatusGetException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/groups/job_status/get",
                                   arg,
                                   false,
                                   DbxAsync.PollArg._writer,
                                   DbxAsync.PollEmptyResult._reader,
                                   GroupsPollError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new GroupsJobStatusGetException(ew.requestId, ew.userMessage, (GroupsPollError) (ew.errValue));
        }
    }
    /**
     * Once an async_job_id is returned from {@link DbxTeam#groupsDelete},
     * {@link DbxTeam#groupsMembersAdd(DbxTeam.GroupSelector,java.util.List)} ,
     * or {@link
     * DbxTeam#groupsMembersRemove(DbxTeam.GroupSelector,java.util.List)} use
     * this method to poll the status of granting/revoking group members' access
     * to group-owned resources. Permission : Team member management
     *
     * @param asyncJobId  Id of the asynchronous job. This is the value of a
     *     response returned from the method that launched the job. {@code
     *     asyncJobId} must have length of at least 1 and not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public DbxAsync.PollEmptyResult groupsJobStatusGet(String asyncJobId)
          throws GroupsJobStatusGetException, DbxException
    {
        DbxAsync.PollArg arg = new DbxAsync.PollArg(asyncJobId);
        return groupsJobStatusGet(arg);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#linkedAppsListMemberLinkedApps(String)}.
     */
    public static class LinkedAppsListMemberLinkedAppsException extends DbxApiException {
        /**
         * The error reported by linkedAppsListMemberLinkedApps.
         */
        public final ListMemberAppsError errorValue;

        public LinkedAppsListMemberLinkedAppsException(String requestId, LocalizedText userMessage, ListMemberAppsError errorValue) {
            super(requestId, userMessage, buildMessage("linked_apps/list_member_linked_apps", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * List all linked applications of the team member. Note, this endpoint
     * doesn't list any team-linked applications.
     */
    private ListMemberAppsResult linkedAppsListMemberLinkedApps(ListMemberAppsArg arg)
            throws LinkedAppsListMemberLinkedAppsException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/linked_apps/list_member_linked_apps",
                                   arg,
                                   false,
                                   ListMemberAppsArg._writer,
                                   ListMemberAppsResult._reader,
                                   ListMemberAppsError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new LinkedAppsListMemberLinkedAppsException(ew.requestId, ew.userMessage, (ListMemberAppsError) (ew.errValue));
        }
    }
    /**
     * List all linked applications of the team member. Note, this endpoint
     * doesn't list any team-linked applications.
     *
     * @param teamMemberId  The team member id. {@code teamMemberId} must not be
     *     {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public ListMemberAppsResult linkedAppsListMemberLinkedApps(String teamMemberId)
          throws LinkedAppsListMemberLinkedAppsException, DbxException
    {
        ListMemberAppsArg arg = new ListMemberAppsArg(teamMemberId);
        return linkedAppsListMemberLinkedApps(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#linkedAppsListTeamLinkedApps(String)}.
     */
    public static class LinkedAppsListTeamLinkedAppsException extends DbxApiException {
        /**
         * The error reported by linkedAppsListTeamLinkedApps.
         */
        public final ListTeamAppsError errorValue;

        public LinkedAppsListTeamLinkedAppsException(String requestId, LocalizedText userMessage, ListTeamAppsError errorValue) {
            super(requestId, userMessage, buildMessage("linked_apps/list_team_linked_apps", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * List all applications linked to the team members' accounts. Note, this
     * endpoint doesn't list any team-linked applications.
     */
    private ListTeamAppsResult linkedAppsListTeamLinkedApps(ListTeamAppsArg arg)
            throws LinkedAppsListTeamLinkedAppsException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/linked_apps/list_team_linked_apps",
                                   arg,
                                   false,
                                   ListTeamAppsArg._writer,
                                   ListTeamAppsResult._reader,
                                   ListTeamAppsError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new LinkedAppsListTeamLinkedAppsException(ew.requestId, ew.userMessage, (ListTeamAppsError) (ew.errValue));
        }
    }
    /**
     * List all applications linked to the team members' accounts. Note, this
     * endpoint doesn't list any team-linked applications.
     */
    public ListTeamAppsResult linkedAppsListTeamLinkedApps()
          throws LinkedAppsListTeamLinkedAppsException, DbxException
    {
        ListTeamAppsArg arg = new ListTeamAppsArg(null);
        return linkedAppsListTeamLinkedApps(arg);
    }
    /**
     * List all applications linked to the team members' accounts. Note, this
     * endpoint doesn't list any team-linked applications.
     *
     * @param cursor  At the first call to the {@link
     *     DbxTeam#linkedAppsListTeamLinkedApps(String)} the cursor shouldn't be
     *     passed. Then, if the result of the call includes a cursor, the
     *     following requests should include the received cursors in order to
     *     receive the next sub list of the team applications.
     */
    public ListTeamAppsResult linkedAppsListTeamLinkedApps(String cursor)
          throws LinkedAppsListTeamLinkedAppsException, DbxException
    {
        ListTeamAppsArg arg = new ListTeamAppsArg(cursor);
        return linkedAppsListTeamLinkedApps(arg);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#linkedAppsRevokeLinkedApp(String,String,boolean)}.
     */
    public static class LinkedAppsRevokeLinkedAppException extends DbxApiException {
        /**
         * The error reported by linkedAppsRevokeLinkedApp.
         */
        public final RevokeLinkedAppError errorValue;

        public LinkedAppsRevokeLinkedAppException(String requestId, LocalizedText userMessage, RevokeLinkedAppError errorValue) {
            super(requestId, userMessage, buildMessage("linked_apps/revoke_linked_app", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Revoke a linked application of the team member
     */
    private void linkedAppsRevokeLinkedApp(RevokeLinkedApiAppArg arg)
            throws LinkedAppsRevokeLinkedAppException, DbxException
    {
        try {
            client.rpcStyle(client.getHost().api,
                            "2/team/linked_apps/revoke_linked_app",
                            arg,
                            false,
                            RevokeLinkedApiAppArg._writer,
                            JsonReader.VoidReader,
                            RevokeLinkedAppError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new LinkedAppsRevokeLinkedAppException(ew.requestId, ew.userMessage, (RevokeLinkedAppError) (ew.errValue));
        }
    }
    /**
     * Revoke a linked application of the team member
     *
     * @param appId  The application's unique id. {@code appId} must not be
     *     {@code null}.
     * @param teamMemberId  The unique id of the member owning the device.
     *     {@code teamMemberId} must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public void linkedAppsRevokeLinkedApp(String appId, String teamMemberId)
          throws LinkedAppsRevokeLinkedAppException, DbxException
    {
        RevokeLinkedApiAppArg arg = new RevokeLinkedApiAppArg(appId, teamMemberId, null);
        linkedAppsRevokeLinkedApp(arg);
    }
    /**
     * Revoke a linked application of the team member
     *
     * @param appId  The application's unique id. {@code appId} must not be
     *     {@code null}.
     * @param teamMemberId  The unique id of the member owning the device.
     *     {@code teamMemberId} must not be {@code null}.
     * @param keepAppFolder  Whether to keep the application dedicated folder
     *     (in case the application uses  one).
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public void linkedAppsRevokeLinkedApp(String appId, String teamMemberId, boolean keepAppFolder)
          throws LinkedAppsRevokeLinkedAppException, DbxException
    {
        RevokeLinkedApiAppArg arg = new RevokeLinkedApiAppArg(appId, teamMemberId, keepAppFolder);
        linkedAppsRevokeLinkedApp(arg);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#linkedAppsRevokeLinkedAppBatch(java.util.List)}.
     */
    public static class LinkedAppsRevokeLinkedAppBatchException extends DbxApiException {
        /**
         * The error reported by linkedAppsRevokeLinkedAppBatch.
         */
        public final RevokeLinkedAppBatchError errorValue;

        public LinkedAppsRevokeLinkedAppBatchException(String requestId, LocalizedText userMessage, RevokeLinkedAppBatchError errorValue) {
            super(requestId, userMessage, buildMessage("linked_apps/revoke_linked_app_batch", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Revoke a list of linked applications of the team members
     */
    private RevokeLinkedAppBatchResult linkedAppsRevokeLinkedAppBatch(RevokeLinkedApiAppBatchArg arg)
            throws LinkedAppsRevokeLinkedAppBatchException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/linked_apps/revoke_linked_app_batch",
                                   arg,
                                   false,
                                   RevokeLinkedApiAppBatchArg._writer,
                                   RevokeLinkedAppBatchResult._reader,
                                   RevokeLinkedAppBatchError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new LinkedAppsRevokeLinkedAppBatchException(ew.requestId, ew.userMessage, (RevokeLinkedAppBatchError) (ew.errValue));
        }
    }
    /**
     * Revoke a list of linked applications of the team members
     *
     * @param revokeLinkedApp  . {@code revokeLinkedApp} must not contain a
     *     {@code null} item and not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public RevokeLinkedAppBatchResult linkedAppsRevokeLinkedAppBatch(java.util.List<RevokeLinkedApiAppArg> revokeLinkedApp)
          throws LinkedAppsRevokeLinkedAppBatchException, DbxException
    {
        RevokeLinkedApiAppBatchArg arg = new RevokeLinkedApiAppBatchArg(revokeLinkedApp);
        return linkedAppsRevokeLinkedAppBatch(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersList(long)}.
     */
    public static class MembersListException extends DbxApiException {
        /**
         * The error reported by membersList.
         */
        public final MembersListError errorValue;

        public MembersListException(String requestId, LocalizedText userMessage, MembersListError errorValue) {
            super(requestId, userMessage, buildMessage("members/list", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Lists members of a team. Permission : Team information
     */
    private MembersListResult membersList(MembersListArg arg)
            throws MembersListException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/list",
                                   arg,
                                   false,
                                   MembersListArg._writer,
                                   MembersListResult._reader,
                                   MembersListError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersListException(ew.requestId, ew.userMessage, (MembersListError) (ew.errValue));
        }
    }
    /**
     * Lists members of a team. Permission : Team information
     */
    public MembersListResult membersList()
          throws MembersListException, DbxException
    {
        MembersListArg arg = new MembersListArg(null);
        return membersList(arg);
    }
    /**
     * Lists members of a team. Permission : Team information
     *
     * @param limit  Number of results to return per call. {@code limit} must be
     *     greater than or equal to 1 and be less than or equal to 1000.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersListResult membersList(long limit)
          throws MembersListException, DbxException
    {
        MembersListArg arg = new MembersListArg(limit);
        return membersList(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersListContinue(String)}.
     */
    public static class MembersListContinueException extends DbxApiException {
        /**
         * The error reported by membersListContinue.
         */
        public final MembersListContinueError errorValue;

        public MembersListContinueException(String requestId, LocalizedText userMessage, MembersListContinueError errorValue) {
            super(requestId, userMessage, buildMessage("members/list/continue", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Once a cursor has been retrieved from {@link DbxTeam#membersList(long)},
     * use this to paginate through all team members. Permission : Team
     * information
     */
    private MembersListResult membersListContinue(MembersListContinueArg arg)
            throws MembersListContinueException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/list/continue",
                                   arg,
                                   false,
                                   MembersListContinueArg._writer,
                                   MembersListResult._reader,
                                   MembersListContinueError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersListContinueException(ew.requestId, ew.userMessage, (MembersListContinueError) (ew.errValue));
        }
    }
    /**
     * Once a cursor has been retrieved from {@link DbxTeam#membersList(long)},
     * use this to paginate through all team members. Permission : Team
     * information
     *
     * @param cursor  Indicates from what point to get the next set of members.
     *     {@code cursor} must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersListResult membersListContinue(String cursor)
          throws MembersListContinueException, DbxException
    {
        MembersListContinueArg arg = new MembersListContinueArg(cursor);
        return membersListContinue(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersGetInfo(java.util.List)}.
     */
    public static class MembersGetInfoException extends DbxApiException {
        /**
         * The error reported by membersGetInfo.
         */
        public final MembersGetInfoError errorValue;

        public MembersGetInfoException(String requestId, LocalizedText userMessage, MembersGetInfoError errorValue) {
            super(requestId, userMessage, buildMessage("members/get_info", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Returns information about multiple team members. Permission : Team
     * information This endpoint will return an empty member_info item, for IDs
     * (or emails) that cannot be matched to a valid team member.
     */
    private java.util.List<MembersGetInfoItem> membersGetInfo(MembersGetInfoArgs arg)
            throws MembersGetInfoException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/get_info",
                                   arg,
                                   false,
                                   MembersGetInfoArgs._writer,
                                   JsonArrayReader.mk(MembersGetInfoItem._reader),
                                   MembersGetInfoError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersGetInfoException(ew.requestId, ew.userMessage, (MembersGetInfoError) (ew.errValue));
        }
    }
    /**
     * Returns information about multiple team members. Permission : Team
     * information This endpoint will return an empty member_info item, for IDs
     * (or emails) that cannot be matched to a valid team member.
     *
     * @param members  List of team members. {@code members} must not contain a
     *     {@code null} item and not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public java.util.List<MembersGetInfoItem> membersGetInfo(java.util.List<UserSelectorArg> members)
          throws MembersGetInfoException, DbxException
    {
        MembersGetInfoArgs arg = new MembersGetInfoArgs(members);
        return membersGetInfo(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersAdd(java.util.List,boolean)}.
     */
    public static class MembersAddException extends DbxApiException {
        public MembersAddException(String requestId, LocalizedText userMessage) {
            super(requestId, userMessage, buildMessage("members/add", userMessage));
        }
    }
    /**
     * Adds members to a team. Permission : Team member management A maximum of
     * 20 members can be specified in a single call. If no Dropbox account
     * exists with the email address specified, a new Dropbox account will be
     * created with the given email address, and that account will be invited to
     * the team. If a personal Dropbox account exists with the email address
     * specified in the call, this call will create a placeholder Dropbox
     * account for the user on the team and send an email inviting the user to
     * migrate their existing personal account onto the team. Team member
     * management apps are required to set an initial given_name and surname for
     * a user to use in the team invitation and for 'Perform as team member'
     * actions taken on the user before they become 'active'.
     */
    private MembersAddLaunch membersAdd(MembersAddArg arg)
            throws MembersAddException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/add",
                                   arg,
                                   false,
                                   MembersAddArg._writer,
                                   MembersAddLaunch._reader,
                                   JsonReader.VoidReader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersAddException(ew.requestId, ew.userMessage);
        }
    }
    /**
     * Adds members to a team. Permission : Team member management A maximum of
     * 20 members can be specified in a single call. If no Dropbox account
     * exists with the email address specified, a new Dropbox account will be
     * created with the given email address, and that account will be invited to
     * the team. If a personal Dropbox account exists with the email address
     * specified in the call, this call will create a placeholder Dropbox
     * account for the user on the team and send an email inviting the user to
     * migrate their existing personal account onto the team. Team member
     * management apps are required to set an initial given_name and surname for
     * a user to use in the team invitation and for 'Perform as team member'
     * actions taken on the user before they become 'active'.
     *
     * @param newMembers  Details of new members to be added to the team. {@code
     *     newMembers} must not contain a {@code null} item and not be {@code
     *     null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersAddLaunch membersAdd(java.util.List<MemberAddArg> newMembers)
          throws MembersAddException, DbxException
    {
        MembersAddArg arg = new MembersAddArg(newMembers, null);
        return membersAdd(arg);
    }
    /**
     * Adds members to a team. Permission : Team member management A maximum of
     * 20 members can be specified in a single call. If no Dropbox account
     * exists with the email address specified, a new Dropbox account will be
     * created with the given email address, and that account will be invited to
     * the team. If a personal Dropbox account exists with the email address
     * specified in the call, this call will create a placeholder Dropbox
     * account for the user on the team and send an email inviting the user to
     * migrate their existing personal account onto the team. Team member
     * management apps are required to set an initial given_name and surname for
     * a user to use in the team invitation and for 'Perform as team member'
     * actions taken on the user before they become 'active'.
     *
     * @param newMembers  Details of new members to be added to the team. {@code
     *     newMembers} must not contain a {@code null} item and not be {@code
     *     null}.
     * @param forceAsync  Whether to force the add to happen asynchronously.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersAddLaunch membersAdd(java.util.List<MemberAddArg> newMembers, boolean forceAsync)
          throws MembersAddException, DbxException
    {
        MembersAddArg arg = new MembersAddArg(newMembers, forceAsync);
        return membersAdd(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersAddJobStatusGet(String)}.
     */
    public static class MembersAddJobStatusGetException extends DbxApiException {
        /**
         * The error reported by membersAddJobStatusGet.
         */
        public final DbxAsync.PollError errorValue;

        public MembersAddJobStatusGetException(String requestId, LocalizedText userMessage, DbxAsync.PollError errorValue) {
            super(requestId, userMessage, buildMessage("members/add/job_status/get", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Once an async_job_id is returned from {@link
     * DbxTeam#membersAdd(java.util.List,boolean)} , use this to poll the status
     * of the asynchronous request. Permission : Team member management
     */
    private MembersAddJobStatus membersAddJobStatusGet(DbxAsync.PollArg arg)
            throws MembersAddJobStatusGetException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/add/job_status/get",
                                   arg,
                                   false,
                                   DbxAsync.PollArg._writer,
                                   MembersAddJobStatus._reader,
                                   DbxAsync.PollError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersAddJobStatusGetException(ew.requestId, ew.userMessage, (DbxAsync.PollError) (ew.errValue));
        }
    }
    /**
     * Once an async_job_id is returned from {@link
     * DbxTeam#membersAdd(java.util.List,boolean)} , use this to poll the status
     * of the asynchronous request. Permission : Team member management
     *
     * @param asyncJobId  Id of the asynchronous job. This is the value of a
     *     response returned from the method that launched the job. {@code
     *     asyncJobId} must have length of at least 1 and not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersAddJobStatus membersAddJobStatusGet(String asyncJobId)
          throws MembersAddJobStatusGetException, DbxException
    {
        DbxAsync.PollArg arg = new DbxAsync.PollArg(asyncJobId);
        return membersAddJobStatusGet(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersSetProfileBuilder}.
     */
    public static class MembersSetProfileException extends DbxApiException {
        /**
         * The error reported by membersSetProfile.
         */
        public final MembersSetProfileError errorValue;

        public MembersSetProfileException(String requestId, LocalizedText userMessage, MembersSetProfileError errorValue) {
            super(requestId, userMessage, buildMessage("members/set_profile", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Updates a team member's profile. Permission : Team member management
     */
    private TeamMemberInfo membersSetProfile(MembersSetProfileArg arg)
            throws MembersSetProfileException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/set_profile",
                                   arg,
                                   false,
                                   MembersSetProfileArg._writer,
                                   TeamMemberInfo._reader,
                                   MembersSetProfileError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersSetProfileException(ew.requestId, ew.userMessage, (MembersSetProfileError) (ew.errValue));
        }
    }
    /**
     * Updates a team member's profile. Permission : Team member management
     *
     * @param user  Identity of user whose profile will be set. {@code user}
     *     must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public TeamMemberInfo membersSetProfile(UserSelectorArg user)
          throws MembersSetProfileException, DbxException
    {
        MembersSetProfileArg arg = new MembersSetProfileArg(user, null, null, null, null);
        return membersSetProfile(arg);
    }
    /**
     * The builder object returned by {@link #membersSetProfileBuilder}
     */
    public final class MembersSetProfileBuilder
    {
        private UserSelectorArg user;
        private String newEmail;
        private String newExternalId;
        private String newGivenName;
        private String newSurname;

        private MembersSetProfileBuilder(UserSelectorArg user)
        {
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
            this.user = user;
        }

        /**
         * Set value for optional request field {@code newEmail}.
         *
         * @param newEmail  New email for member.
         */
        public MembersSetProfileBuilder newEmail(String newEmail)
        {
            this.newEmail = newEmail;
            return this;
        }

        /**
         * Set value for optional request field {@code newExternalId}.
         *
         * @param newExternalId  New external ID for member.
         */
        public MembersSetProfileBuilder newExternalId(String newExternalId)
        {
            this.newExternalId = newExternalId;
            return this;
        }

        /**
         * Set value for optional request field {@code newGivenName}.
         *
         * @param newGivenName  New given name for member.
         */
        public MembersSetProfileBuilder newGivenName(String newGivenName)
        {
            this.newGivenName = newGivenName;
            return this;
        }

        /**
         * Set value for optional request field {@code newSurname}.
         *
         * @param newSurname  New surname for member.
         */
        public MembersSetProfileBuilder newSurname(String newSurname)
        {
            this.newSurname = newSurname;
            return this;
        }

        /**
         * Issues the request.
         */
        public TeamMemberInfo start() throws MembersSetProfileException, DbxException
        {
            MembersSetProfileArg arg = new MembersSetProfileArg(user, newEmail, newExternalId, newGivenName, newSurname);
            return DbxTeam.this.membersSetProfile(arg);
        }
    }

    /**
     * Updates a team member's profile. Permission : Team member management
     *
     * @param user  Identity of user whose profile will be set. {@code user}
     *     must not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersSetProfileBuilder membersSetProfileBuilder(UserSelectorArg user)
    {
        return new MembersSetProfileBuilder(user);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#membersSetAdminPermissions(DbxTeam.UserSelectorArg,DbxTeam.AdminTier)}.
     */
    public static class MembersSetAdminPermissionsException extends DbxApiException {
        /**
         * The error reported by membersSetAdminPermissions.
         */
        public final MembersSetPermissionsError errorValue;

        public MembersSetAdminPermissionsException(String requestId, LocalizedText userMessage, MembersSetPermissionsError errorValue) {
            super(requestId, userMessage, buildMessage("members/set_admin_permissions", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Updates a team member's permissions. Permission : Team member management
     */
    private MembersSetPermissionsResult membersSetAdminPermissions(MembersSetPermissionsArg arg)
            throws MembersSetAdminPermissionsException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/set_admin_permissions",
                                   arg,
                                   false,
                                   MembersSetPermissionsArg._writer,
                                   MembersSetPermissionsResult._reader,
                                   MembersSetPermissionsError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersSetAdminPermissionsException(ew.requestId, ew.userMessage, (MembersSetPermissionsError) (ew.errValue));
        }
    }
    /**
     * Updates a team member's permissions. Permission : Team member management
     *
     * @param user  Identity of user whose role will be set. {@code user} must
     *     not be {@code null}.
     * @param newRole  The new role of the member. {@code newRole} must not be
     *     {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersSetPermissionsResult membersSetAdminPermissions(UserSelectorArg user, AdminTier newRole)
          throws MembersSetAdminPermissionsException, DbxException
    {
        MembersSetPermissionsArg arg = new MembersSetPermissionsArg(user, newRole);
        return membersSetAdminPermissions(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersSendWelcomeEmail}.
     */
    public static class MembersSendWelcomeEmailException extends DbxApiException {
        /**
         * The error reported by membersSendWelcomeEmail.
         */
        public final MembersSendWelcomeError errorValue;

        public MembersSendWelcomeEmailException(String requestId, LocalizedText userMessage, MembersSendWelcomeError errorValue) {
            super(requestId, userMessage, buildMessage("members/send_welcome_email", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Sends welcome email to pending team member. Permission : Team member
     * management Exactly one of team_member_id, email, or external_id must be
     * provided to identify the user account. No-op if team member is not
     * pending.
     */
    private void membersSendWelcomeEmail(UserSelectorArg arg)
            throws MembersSendWelcomeEmailException, DbxException
    {
        try {
            client.rpcStyle(client.getHost().api,
                            "2/team/members/send_welcome_email",
                            arg,
                            false,
                            UserSelectorArg._writer,
                            JsonReader.VoidReader,
                            MembersSendWelcomeError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersSendWelcomeEmailException(ew.requestId, ew.userMessage, (MembersSendWelcomeError) (ew.errValue));
        }
    }

    /**
     * Exception thrown by {@link DbxTeam#membersRemoveBuilder}.
     */
    public static class MembersRemoveException extends DbxApiException {
        /**
         * The error reported by membersRemove.
         */
        public final MembersRemoveError errorValue;

        public MembersRemoveException(String requestId, LocalizedText userMessage, MembersRemoveError errorValue) {
            super(requestId, userMessage, buildMessage("members/remove", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Removes a member from a team. Permission : Team member management Exactly
     * one of team_member_id, email, or external_id must be provided to identify
     * the user account. This is not a deactivation where the account can be
     * re-activated again. Calling {@link
     * DbxTeam#membersAdd(java.util.List,boolean)} with the removed user's email
     * address will create a new account with a new team_member_id that will not
     * have access to any content that was shared with the initial account. This
     * endpoint can also be used to cancel a pending invite to join the team.
     * This endpoint may initiate an asynchronous job. To obtain the final
     * result of the job, the client should periodically poll {@link
     * DbxTeam#membersRemoveJobStatusGet(String)}.
     */
    private DbxAsync.LaunchEmptyResult membersRemove(MembersRemoveArg arg)
            throws MembersRemoveException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/remove",
                                   arg,
                                   false,
                                   MembersRemoveArg._writer,
                                   DbxAsync.LaunchEmptyResult._reader,
                                   MembersRemoveError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersRemoveException(ew.requestId, ew.userMessage, (MembersRemoveError) (ew.errValue));
        }
    }
    /**
     * Removes a member from a team. Permission : Team member management Exactly
     * one of team_member_id, email, or external_id must be provided to identify
     * the user account. This is not a deactivation where the account can be
     * re-activated again. Calling {@link
     * DbxTeam#membersAdd(java.util.List,boolean)} with the removed user's email
     * address will create a new account with a new team_member_id that will not
     * have access to any content that was shared with the initial account. This
     * endpoint can also be used to cancel a pending invite to join the team.
     * This endpoint may initiate an asynchronous job. To obtain the final
     * result of the job, the client should periodically poll {@link
     * DbxTeam#membersRemoveJobStatusGet(String)}.
     *
     * @param user  Identity of user to remove/suspend. {@code user} must not be
     *     {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public DbxAsync.LaunchEmptyResult membersRemove(UserSelectorArg user)
          throws MembersRemoveException, DbxException
    {
        MembersRemoveArg arg = new MembersRemoveArg(user, null, null, null);
        return membersRemove(arg);
    }
    /**
     * The builder object returned by {@link #membersRemoveBuilder}
     */
    public final class MembersRemoveBuilder
    {
        private UserSelectorArg user;
        private Boolean wipeData;
        private UserSelectorArg transferDestId;
        private UserSelectorArg transferAdminId;

        private MembersRemoveBuilder(UserSelectorArg user)
        {
            if (user == null) {
                throw new IllegalArgumentException("Required value for 'user' is null");
            }
            this.user = user;
        }

        /**
         * Set value for optional request field {@code wipeData}.
         *
         * @param wipeData  If provided, controls if the user's data will be
         *     deleted on their linked devices.
         */
        public MembersRemoveBuilder wipeData(boolean wipeData)
        {
            this.wipeData = wipeData;
            return this;
        }

        /**
         * Set value for optional request field {@code transferDestId}.
         *
         * @param transferDestId  If provided, files from the deleted member
         *     account will be transferred to this user.
         */
        public MembersRemoveBuilder transferDestId(UserSelectorArg transferDestId)
        {
            this.transferDestId = transferDestId;
            return this;
        }

        /**
         * Set value for optional request field {@code transferAdminId}.
         *
         * @param transferAdminId  If provided, errors during the transfer
         *     process will be sent via email to this user. If the
         *     transfer_dest_id argument was provided, then this argument must
         *     be provided as well.
         */
        public MembersRemoveBuilder transferAdminId(UserSelectorArg transferAdminId)
        {
            this.transferAdminId = transferAdminId;
            return this;
        }

        /**
         * Issues the request.
         */
        public DbxAsync.LaunchEmptyResult start() throws MembersRemoveException, DbxException
        {
            MembersRemoveArg arg = new MembersRemoveArg(user, wipeData, transferDestId, transferAdminId);
            return DbxTeam.this.membersRemove(arg);
        }
    }

    /**
     * Removes a member from a team. Permission : Team member management Exactly
     * one of team_member_id, email, or external_id must be provided to identify
     * the user account. This is not a deactivation where the account can be
     * re-activated again. Calling {@link
     * DbxTeam#membersAdd(java.util.List,boolean)} with the removed user's email
     * address will create a new account with a new team_member_id that will not
     * have access to any content that was shared with the initial account. This
     * endpoint can also be used to cancel a pending invite to join the team.
     * This endpoint may initiate an asynchronous job. To obtain the final
     * result of the job, the client should periodically poll {@link
     * DbxTeam#membersRemoveJobStatusGet(String)}.
     *
     * @param user  Identity of user to remove/suspend. {@code user} must not be
     *     {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public MembersRemoveBuilder membersRemoveBuilder(UserSelectorArg user)
    {
        return new MembersRemoveBuilder(user);
    }

    /**
     * Exception thrown by {@link DbxTeam#membersRemoveJobStatusGet(String)}.
     */
    public static class MembersRemoveJobStatusGetException extends DbxApiException {
        /**
         * The error reported by membersRemoveJobStatusGet.
         */
        public final DbxAsync.PollError errorValue;

        public MembersRemoveJobStatusGetException(String requestId, LocalizedText userMessage, DbxAsync.PollError errorValue) {
            super(requestId, userMessage, buildMessage("members/remove/job_status/get", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Once an async_job_id is returned from {@link
     * DbxTeam#membersRemoveBuilder} , use this to poll the status of the
     * asynchronous request. Permission : Team member management
     */
    private DbxAsync.PollEmptyResult membersRemoveJobStatusGet(DbxAsync.PollArg arg)
            throws MembersRemoveJobStatusGetException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/members/remove/job_status/get",
                                   arg,
                                   false,
                                   DbxAsync.PollArg._writer,
                                   DbxAsync.PollEmptyResult._reader,
                                   DbxAsync.PollError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersRemoveJobStatusGetException(ew.requestId, ew.userMessage, (DbxAsync.PollError) (ew.errValue));
        }
    }
    /**
     * Once an async_job_id is returned from {@link
     * DbxTeam#membersRemoveBuilder} , use this to poll the status of the
     * asynchronous request. Permission : Team member management
     *
     * @param asyncJobId  Id of the asynchronous job. This is the value of a
     *     response returned from the method that launched the job. {@code
     *     asyncJobId} must have length of at least 1 and not be {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public DbxAsync.PollEmptyResult membersRemoveJobStatusGet(String asyncJobId)
          throws MembersRemoveJobStatusGetException, DbxException
    {
        DbxAsync.PollArg arg = new DbxAsync.PollArg(asyncJobId);
        return membersRemoveJobStatusGet(arg);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#membersSuspend(DbxTeam.UserSelectorArg,boolean)}.
     */
    public static class MembersSuspendException extends DbxApiException {
        /**
         * The error reported by membersSuspend.
         */
        public final MembersSuspendError errorValue;

        public MembersSuspendException(String requestId, LocalizedText userMessage, MembersSuspendError errorValue) {
            super(requestId, userMessage, buildMessage("members/suspend", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Suspend a member from a team. Permission : Team member management Exactly
     * one of team_member_id, email, or external_id must be provided to identify
     * the user account.
     */
    private void membersSuspend(MembersDeactivateArg arg)
            throws MembersSuspendException, DbxException
    {
        try {
            client.rpcStyle(client.getHost().api,
                            "2/team/members/suspend",
                            arg,
                            false,
                            MembersDeactivateArg._writer,
                            JsonReader.VoidReader,
                            MembersSuspendError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersSuspendException(ew.requestId, ew.userMessage, (MembersSuspendError) (ew.errValue));
        }
    }
    /**
     * Suspend a member from a team. Permission : Team member management Exactly
     * one of team_member_id, email, or external_id must be provided to identify
     * the user account.
     *
     * @param user  Identity of user to remove/suspend. {@code user} must not be
     *     {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public void membersSuspend(UserSelectorArg user)
          throws MembersSuspendException, DbxException
    {
        MembersDeactivateArg arg = new MembersDeactivateArg(user, null);
        membersSuspend(arg);
    }
    /**
     * Suspend a member from a team. Permission : Team member management Exactly
     * one of team_member_id, email, or external_id must be provided to identify
     * the user account.
     *
     * @param user  Identity of user to remove/suspend. {@code user} must not be
     *     {@code null}.
     * @param wipeData  If provided, controls if the user's data will be deleted
     *     on their linked devices.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public void membersSuspend(UserSelectorArg user, boolean wipeData)
          throws MembersSuspendException, DbxException
    {
        MembersDeactivateArg arg = new MembersDeactivateArg(user, wipeData);
        membersSuspend(arg);
    }

    /**
     * Exception thrown by {@link
     * DbxTeam#membersUnsuspend(DbxTeam.UserSelectorArg)}.
     */
    public static class MembersUnsuspendException extends DbxApiException {
        /**
         * The error reported by membersUnsuspend.
         */
        public final MembersUnsuspendError errorValue;

        public MembersUnsuspendException(String requestId, LocalizedText userMessage, MembersUnsuspendError errorValue) {
            super(requestId, userMessage, buildMessage("members/unsuspend", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Unsuspend a member from a team. Permission : Team member management
     * Exactly one of team_member_id, email, or external_id must be provided to
     * identify the user account.
     */
    private void membersUnsuspend(MembersUnsuspendArg arg)
            throws MembersUnsuspendException, DbxException
    {
        try {
            client.rpcStyle(client.getHost().api,
                            "2/team/members/unsuspend",
                            arg,
                            false,
                            MembersUnsuspendArg._writer,
                            JsonReader.VoidReader,
                            MembersUnsuspendError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new MembersUnsuspendException(ew.requestId, ew.userMessage, (MembersUnsuspendError) (ew.errValue));
        }
    }
    /**
     * Unsuspend a member from a team. Permission : Team member management
     * Exactly one of team_member_id, email, or external_id must be provided to
     * identify the user account.
     *
     * @param user  Identity of user to unsuspend. {@code user} must not be
     *     {@code null}.
     *
     * @throws IllegalArgumentException  if any argument does not meet its
     *     preconditions.
     */
    public void membersUnsuspend(UserSelectorArg user)
          throws MembersUnsuspendException, DbxException
    {
        MembersUnsuspendArg arg = new MembersUnsuspendArg(user);
        membersUnsuspend(arg);
    }

    /**
     * Exception thrown by {@link DbxTeam#reportsGetStorageBuilder}.
     */
    public static class ReportsGetStorageException extends DbxApiException {
        /**
         * The error reported by reportsGetStorage.
         */
        public final DateRangeError errorValue;

        public ReportsGetStorageException(String requestId, LocalizedText userMessage, DateRangeError errorValue) {
            super(requestId, userMessage, buildMessage("reports/get_storage", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Retrieves reporting data about a team's storage usage.
     */
    private GetStorageReport reportsGetStorage(DateRange arg)
            throws ReportsGetStorageException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/reports/get_storage",
                                   arg,
                                   false,
                                   DateRange._writer,
                                   GetStorageReport._reader,
                                   DateRangeError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new ReportsGetStorageException(ew.requestId, ew.userMessage, (DateRangeError) (ew.errValue));
        }
    }
    /**
     * Retrieves reporting data about a team's storage usage.
     */
    public GetStorageReport reportsGetStorage()
          throws ReportsGetStorageException, DbxException
    {
        DateRange arg = new DateRange(null, null);
        return reportsGetStorage(arg);
    }
    /**
     * The builder object returned by {@link #reportsGetStorageBuilder}
     */
    public final class ReportsGetStorageBuilder
    {
        private java.util.Date startDate;
        private java.util.Date endDate;

        private ReportsGetStorageBuilder()
        {
        }

        /**
         * Set value for optional request field {@code startDate}.
         *
         * @param startDate  Optional starting date (inclusive).
         */
        public ReportsGetStorageBuilder startDate(java.util.Date startDate)
        {
            this.startDate = startDate;
            return this;
        }

        /**
         * Set value for optional request field {@code endDate}.
         *
         * @param endDate  Optional ending date (exclusive).
         */
        public ReportsGetStorageBuilder endDate(java.util.Date endDate)
        {
            this.endDate = endDate;
            return this;
        }

        /**
         * Issues the request.
         */
        public GetStorageReport start() throws ReportsGetStorageException, DbxException
        {
            DateRange arg = new DateRange(startDate, endDate);
            return DbxTeam.this.reportsGetStorage(arg);
        }
    }

    /**
     * Retrieves reporting data about a team's storage usage.
     */
    public ReportsGetStorageBuilder reportsGetStorageBuilder()
    {
        return new ReportsGetStorageBuilder();
    }

    /**
     * Exception thrown by {@link DbxTeam#reportsGetActivityBuilder}.
     */
    public static class ReportsGetActivityException extends DbxApiException {
        /**
         * The error reported by reportsGetActivity.
         */
        public final DateRangeError errorValue;

        public ReportsGetActivityException(String requestId, LocalizedText userMessage, DateRangeError errorValue) {
            super(requestId, userMessage, buildMessage("reports/get_activity", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Retrieves reporting data about a team's user activity.
     */
    private GetActivityReport reportsGetActivity(DateRange arg)
            throws ReportsGetActivityException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/reports/get_activity",
                                   arg,
                                   false,
                                   DateRange._writer,
                                   GetActivityReport._reader,
                                   DateRangeError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new ReportsGetActivityException(ew.requestId, ew.userMessage, (DateRangeError) (ew.errValue));
        }
    }
    /**
     * Retrieves reporting data about a team's user activity.
     */
    public GetActivityReport reportsGetActivity()
          throws ReportsGetActivityException, DbxException
    {
        DateRange arg = new DateRange(null, null);
        return reportsGetActivity(arg);
    }
    /**
     * The builder object returned by {@link #reportsGetActivityBuilder}
     */
    public final class ReportsGetActivityBuilder
    {
        private java.util.Date startDate;
        private java.util.Date endDate;

        private ReportsGetActivityBuilder()
        {
        }

        /**
         * Set value for optional request field {@code startDate}.
         *
         * @param startDate  Optional starting date (inclusive).
         */
        public ReportsGetActivityBuilder startDate(java.util.Date startDate)
        {
            this.startDate = startDate;
            return this;
        }

        /**
         * Set value for optional request field {@code endDate}.
         *
         * @param endDate  Optional ending date (exclusive).
         */
        public ReportsGetActivityBuilder endDate(java.util.Date endDate)
        {
            this.endDate = endDate;
            return this;
        }

        /**
         * Issues the request.
         */
        public GetActivityReport start() throws ReportsGetActivityException, DbxException
        {
            DateRange arg = new DateRange(startDate, endDate);
            return DbxTeam.this.reportsGetActivity(arg);
        }
    }

    /**
     * Retrieves reporting data about a team's user activity.
     */
    public ReportsGetActivityBuilder reportsGetActivityBuilder()
    {
        return new ReportsGetActivityBuilder();
    }

    /**
     * Exception thrown by {@link DbxTeam#reportsGetMembershipBuilder}.
     */
    public static class ReportsGetMembershipException extends DbxApiException {
        /**
         * The error reported by reportsGetMembership.
         */
        public final DateRangeError errorValue;

        public ReportsGetMembershipException(String requestId, LocalizedText userMessage, DateRangeError errorValue) {
            super(requestId, userMessage, buildMessage("reports/get_membership", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Retrieves reporting data about a team's membership.
     */
    private GetMembershipReport reportsGetMembership(DateRange arg)
            throws ReportsGetMembershipException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/reports/get_membership",
                                   arg,
                                   false,
                                   DateRange._writer,
                                   GetMembershipReport._reader,
                                   DateRangeError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new ReportsGetMembershipException(ew.requestId, ew.userMessage, (DateRangeError) (ew.errValue));
        }
    }
    /**
     * Retrieves reporting data about a team's membership.
     */
    public GetMembershipReport reportsGetMembership()
          throws ReportsGetMembershipException, DbxException
    {
        DateRange arg = new DateRange(null, null);
        return reportsGetMembership(arg);
    }
    /**
     * The builder object returned by {@link #reportsGetMembershipBuilder}
     */
    public final class ReportsGetMembershipBuilder
    {
        private java.util.Date startDate;
        private java.util.Date endDate;

        private ReportsGetMembershipBuilder()
        {
        }

        /**
         * Set value for optional request field {@code startDate}.
         *
         * @param startDate  Optional starting date (inclusive).
         */
        public ReportsGetMembershipBuilder startDate(java.util.Date startDate)
        {
            this.startDate = startDate;
            return this;
        }

        /**
         * Set value for optional request field {@code endDate}.
         *
         * @param endDate  Optional ending date (exclusive).
         */
        public ReportsGetMembershipBuilder endDate(java.util.Date endDate)
        {
            this.endDate = endDate;
            return this;
        }

        /**
         * Issues the request.
         */
        public GetMembershipReport start() throws ReportsGetMembershipException, DbxException
        {
            DateRange arg = new DateRange(startDate, endDate);
            return DbxTeam.this.reportsGetMembership(arg);
        }
    }

    /**
     * Retrieves reporting data about a team's membership.
     */
    public ReportsGetMembershipBuilder reportsGetMembershipBuilder()
    {
        return new ReportsGetMembershipBuilder();
    }

    /**
     * Exception thrown by {@link DbxTeam#reportsGetDevicesBuilder}.
     */
    public static class ReportsGetDevicesException extends DbxApiException {
        /**
         * The error reported by reportsGetDevices.
         */
        public final DateRangeError errorValue;

        public ReportsGetDevicesException(String requestId, LocalizedText userMessage, DateRangeError errorValue) {
            super(requestId, userMessage, buildMessage("reports/get_devices", userMessage, errorValue));
            this.errorValue = errorValue;
        }
    }
    /**
     * Retrieves reporting data about a team's linked devices.
     */
    private GetDevicesReport reportsGetDevices(DateRange arg)
            throws ReportsGetDevicesException, DbxException
    {
        try {
            return client.rpcStyle(client.getHost().api,
                                   "2/team/reports/get_devices",
                                   arg,
                                   false,
                                   DateRange._writer,
                                   GetDevicesReport._reader,
                                   DateRangeError._reader);
        }
        catch (DbxRequestUtil.ErrorWrapper ew) {
            throw new ReportsGetDevicesException(ew.requestId, ew.userMessage, (DateRangeError) (ew.errValue));
        }
    }
    /**
     * Retrieves reporting data about a team's linked devices.
     */
    public GetDevicesReport reportsGetDevices()
          throws ReportsGetDevicesException, DbxException
    {
        DateRange arg = new DateRange(null, null);
        return reportsGetDevices(arg);
    }
    /**
     * The builder object returned by {@link #reportsGetDevicesBuilder}
     */
    public final class ReportsGetDevicesBuilder
    {
        private java.util.Date startDate;
        private java.util.Date endDate;

        private ReportsGetDevicesBuilder()
        {
        }

        /**
         * Set value for optional request field {@code startDate}.
         *
         * @param startDate  Optional starting date (inclusive).
         */
        public ReportsGetDevicesBuilder startDate(java.util.Date startDate)
        {
            this.startDate = startDate;
            return this;
        }

        /**
         * Set value for optional request field {@code endDate}.
         *
         * @param endDate  Optional ending date (exclusive).
         */
        public ReportsGetDevicesBuilder endDate(java.util.Date endDate)
        {
            this.endDate = endDate;
            return this;
        }

        /**
         * Issues the request.
         */
        public GetDevicesReport start() throws ReportsGetDevicesException, DbxException
        {
            DateRange arg = new DateRange(startDate, endDate);
            return DbxTeam.this.reportsGetDevices(arg);
        }
    }

    /**
     * Retrieves reporting data about a team's linked devices.
     */
    public ReportsGetDevicesBuilder reportsGetDevicesBuilder()
    {
        return new ReportsGetDevicesBuilder();
    }
}
